{"parent_id": "010cdca5-621f-41e8-879f-c331c85d289b", "subject": "hedieuhanh", "section": "HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG", "title_path": "HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG", "content": "[hedieuhanh / HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG] BÀI GIẢNG MÔN HỆ ĐIỀU HÀNH Giảng viên: Bộ môn: Email: TS. Đào Thị Thúy Quỳnh Khoa học máy tính - Khoa CNTT1 quynhdao.ptit@gmail.com", "order_start": 0, "order_end": 131, "word_count": 24}
{"parent_id": "b00b934a-72ef-4a55-a7fd-03c66ce8540c", "subject": "hedieuhanh", "section": "TÀI LIỆU THAM KHẢO", "title_path": "TÀI LIỆU THAM KHẢO", "content": "[hedieuhanh / TÀI LIỆU THAM KHẢO] 1. Silberschatz A., Galvin G., Operating systems concepts, 9th ed, John Willey&Sons, 2013 2. Từ Minh Phƣơng, Bài giảng Hệ điều hành 3. Hà Quang Thụy. Nguyên lý các hệ điều hành. Nxb KHKT 2009 4. Nguyễn Thanh Tùng. Giáo trình hệ điều hành. ĐHBK HN 1999 Điểm chuyên cần: 10% Điểm trung bình kiểm tra: 10% Điểm thực hành: 10% Thi cuối kỳ: 70% 1. Chƣơng 1: Giới thiệu chung 2. Chƣơng 2: Hệ thống file 3. Chƣơng 3: Quản lý bộ nhớ 4. Chƣơng 4: Quản lý tiến trình", "order_start": 0, "order_end": 456, "word_count": 91}
{"parent_id": "e6f8c65d-977c-4980-a3a0-34951faa337f", "subject": "hedieuhanh", "section": "CHƢƠNG 1: GIỚI THIỆU CHUNG", "title_path": "CHƢƠNG 1: GIỚI THIỆU CHUNG", "content": "[hedieuhanh / CHƢƠNG 1: GIỚI THIỆU CHUNG] 1. Các thành phần của hệ thống máy tính 2. Khái niệm hệ điều hành 3. Các dịch vụ do HDH cung cấp 4. Giao diện lập trình của HDH 5. Quá trình phát triển và một số khái niệm quan trọng Cấu trúc HDH ■ Một số HDH cụ thể", "order_start": 0, "order_end": 215, "word_count": 51}
{"parent_id": "504d83aa-7db8-4b47-8f99-52f6876b3bc1", "subject": "hedieuhanh", "section": "CÁC THÀNH PHẦN CỦA HỆ THỐNG MÁY TÍNH", "title_path": "CÁC THÀNH PHẦN CỦA HỆ THỐNG MÁY TÍNH", "content": "[hedieuhanh / CÁC THÀNH PHẦN CỦA HỆ THỐNG MÁY TÍNH] Phần cứng: cung cấp các tài nguyên cần thiết cho việc tính toán, xử lý dữ liệu Phần mềm: các chƣơng trình cụ thể. (phần mềm hệ thống và phần mềm ứng dụng), HDH: phần mềm đóng vai trò trung gian giữa phần cứng và người sử dụng chƣơng trình ứng dụng, làm cho việc sử dụng hệ thống máy tính đƣợc tiện lợi và hiệu quả", "order_start": 0, "order_end": 313, "word_count": 67}
{"parent_id": "34d5f921-bbd2-46f7-a0bf-fa47044ed0f4", "subject": "hedieuhanh", "section": "II. KHÁI NIỆM HỆ ĐIỀU HÀNH", "title_path": "II. KHÁI NIỆM HỆ ĐIỀU HÀNH", "content": "[hedieuhanh / II. KHÁI NIỆM HỆ ĐIỀU HÀNH] Đƣợc định nghĩa thông qua mục đích, vai trò, và chức năng trong hệ thống máy tính Hệ thống phần mềm đóng vai trò trung gian giữa ngƣời sử dụng và phần cứng của máy tính nhằm thực hiện 2 chức năng cơ bản: Quản lý tài nguyên Quản lý việc thực hiện các chƣơng trình => Một cách thuận lợi và hiệu quả! II. KHÁI NIỆM HỆ ĐIỀU HÀNH 1. Quản lý tài nguyên Đảm bảo cho tài nguyên hệ thống đƣợc sử dụng một cách có ích và hiệu quả Các tài nguyên: bộ xử lý (CPU), bộ nhớ chính, bộ nhớ ngoài (các đĩa), các thiết bị vào ra Phân phối tài nguyên cho các ứng dụng hiệu quả:  Yêu cầu tài nguyên đƣợc HDH thu nhận và đáp ứng bằng cách cấp cho chƣơng trình các tài nguyên tƣơng ứng HDH cần lƣu trữ tình trạng tài nguyên Đảm bảo không xâm phạm tài nguyên cấp cho chƣơng trình khác Ví dụ: Lƣu trữ thông tin trên đĩa => HDH cần biết những vùng nào trên đĩa chƣa đƣợc sử dụng để ghi thông tin lên những vùng này. Việc ghi thông tin cũng cần tính toán sao cho quá trình truy cập khi cần có thể thực hiện nhanh nhất.", "order_start": 0, "order_end": 992, "word_count": 216}
{"parent_id": "f6f59572-b0f9-4258-8796-1c6360307346", "subject": "hedieuhanh", "section": "II. KHÁI NIỆM HỆ ĐIỀU HÀNH", "title_path": "II. KHÁI NIỆM HỆ ĐIỀU HÀNH", "content": "[hedieuhanh / II. KHÁI NIỆM HỆ ĐIỀU HÀNH] 2. Quản lý việc thực hiện các chương trình Nhiệm vụ quan trọng nhất của máy tính là thực hiện các chƣơng trình, 1 chƣơng trình đang trong quá trình chạy gọi là tiến trình (process). Chƣơng trình cần đƣợc quản lý để thực hiện thuận lợi, tránh lỗi, đồng thời đảm bảo môi trƣờng để việc xây dựng và thực hiện chƣơng trình đƣợc thuận lợi. Để chạy chƣơng trình cần thực hiện một số thao tác nhất định =>Hdh giúp việc chạy chƣơng trình dễ dàng hơn, ngƣời dùng không cần phải thực hiện thao tác Để tạo môi trƣờng thuận lợi cho chtr, hđh tạo ra các máy ảo: Là máy logic với các tài nguyên ảo Tài nguyên ảo mô phỏng tài nguyên thực đƣợc thực hiện bằng phần mềm Cung cấp các dịch vụ cơ bản nhƣ tài nguyên thực Dễ sử dụng hơn, số lƣợng tài nguyên ảo có thể lớn hơn số lƣợng tài nguyên thực Một trong những nhiệm vụ chủ yếu của HDH là tạo ra môi trƣờng thuận lợi cho các chƣơng trình khác thực hiện và giúp ngƣời sử dụng hệ thống dễ dàng. Các dịch vụ có thể thay đổi theo từng HDH. Một số HDH có thể cung cấp nhiều dịch vụ khi hệ điều hành khác có thể cung cấp ít dịch vụ hơn.", "order_start": 0, "order_end": 1064, "word_count": 228}
{"parent_id": "f6f59572-b0f9-4258-8796-1c6360307346", "subject": "hedieuhanh", "section": "II. KHÁI NIỆM HỆ ĐIỀU HÀNH", "title_path": "II. KHÁI NIỆM HỆ ĐIỀU HÀNH", "content": "[hedieuhanh / II. KHÁI NIỆM HỆ ĐIỀU HÀNH] ện và giúp ngƣời sử dụng hệ thống dễ dàng. Các dịch vụ có thể thay đổi theo từng HDH. Một số HDH có thể cung cấp nhiều dịch vụ khi hệ điều hành khác có thể cung cấp ít dịch vụ hơn. Ví dụ nhƣ MS-DOS không cung cấp dịch vụ về bảo mật trong khi Windows NT lại rất chú trọng tới dịch vụ này.", "order_start": 1064, "order_end": 1351, "word_count": 67}
{"parent_id": "695168cd-7821-4fa1-9aaa-9c9fb7af431f", "subject": "hedieuhanh", "section": "Tải và chạy chương trình:", "title_path": "Tải và chạy chương trình:", "content": "[hedieuhanh / Tải và chạy chương trình:] Để thực hiện, chƣơng trình đƣợc tải từ đĩa vào bộ nhớ, sau đó đƣợc trao quyền thực hiện các lệnh Khi thực hiện xong, cần giải phóng bộ nhớ và các tài nguyên Toàn bộ quá trình này tƣơng đối phức tạp song lại diễn ra thƣờng xuyên. => HDH sẽ thực hiện công việc phức tạp và lặp đi lặp lại này Do HDH là chƣơng trình đầu tiên đƣợc thực hiện khi khởi động hệ thống nên HDH tự tải mình vào bộ nhớ Giao diện với ngƣời dùng: cho phép giao tiếp giữa HDH và ngƣời dùng: Dƣới dạng dòng lệnh, Giao diện đồ họa Thực hiện các thao tác vào/ ra dữ liệu", "order_start": 0, "order_end": 536, "word_count": 118}
{"parent_id": "c739adc2-165a-42c9-b095-b9183e65c9d9", "subject": "hedieuhanh", "section": "III. CÁC DỊCH VỤ DO HDH CUNG CẤP", "title_path": "III. CÁC DỊCH VỤ DO HDH CUNG CẤP", "content": "[hedieuhanh / III. CÁC DỊCH VỤ DO HDH CUNG CẤP] Làm việc với hệ thống file: nhu cầu đọc, ghi, tạo, xóa, chép file hoặc làm việc với thƣ mục; quản lý quyền truy cập, sao lƣu. Phát hiện và xử lý lỗi Phát hiện và xử lý kịp thời các lỗi xuất hiện trong phần cứng cũng nhƣ phần mềm => Đảm bảo cho hệ thống hoạt động ổn định, an toàn Ví dụ: các lỗi phần cứng nhƣ hết bộ nhớ, mất điện, máy in hết mực, hết giấy,.. Truyền thông: Cung cấp dịch vụ cho phép thiết lập liên lạc và truyền", "order_start": 0, "order_end": 427, "word_count": 95}
{"parent_id": "4e28cfb4-6def-4ceb-a334-bf4cd3db7ec3", "subject": "hedieuhanh", "section": "III. CÁC DỊCH VỤ DO HDH CUNG CẤP", "title_path": "III. CÁC DỊCH VỤ DO HDH CUNG CẤP", "content": "[hedieuhanh / III. CÁC DỊCH VỤ DO HDH CUNG CẤP] Cấp phát tài nguyên: Trong các hệ thống cho phép nhiều chƣơng trình thực hiện đồng thời cần có cơ chế cấp phát và phân phối tài nguyên hợp lý => ngƣời dùng và trình ứng dụng không phải tự thực hiện việc cấp phát tài nguyên mà vẫn đảm bảo cấp ptá công bằng và hiệu quả. Dịch vụ an ninh và bảo mật  Đối với hệ thống nhiều ngƣời dùng thƣờng xuất hiện yêu cầu bảo mật thông tin, tức là ngƣời dùng này không tiếp cận đƣợc thông tin của ngƣời khác nếu không đƣợc cho phép => cần đảm bảo để tiến trình không truy cập trái phép tài nguyên (nhƣ vùng nhớ, file mở) của tiến trình khác hay chính HDH sẽ thực hiện bằng cách kiểm soát truy cấp tới tài nguyên", "order_start": 0, "order_end": 648, "word_count": 139}
{"parent_id": "ed75759a-2e67-4b04-b19a-8614f6e26db2", "subject": "hedieuhanh", "section": "IV. GIAO DIỆN LẬP TRÌNH CỦA HDH", "title_path": "IV. GIAO DIỆN LẬP TRÌNH CỦA HDH", "content": "[hedieuhanh / IV. GIAO DIỆN LẬP TRÌNH CỦA HDH] Để các chƣơng trình có thể sử dụng đƣợc những dịch vụ, HDH cung cấp giao diện lập trình. Giao diện này bao gồm các lời gọi hệ thống (system call) mà chƣơng trình sử dụng yêu cầu một dịch vụ nào đó từ phía HDH. Lời gọi hệ thống: các lệnh đặc biệt mà CTUD gọi khi cần yêu cầu HDH thực hiện một việc gì đó Lời gọi hệ thống đƣợc thực hiện qua những thƣ viện hàm gọi là thƣ viện hệ thống. Các hàm này sẽ giúp ngƣời lập trình gọi lời gọi hệ thống tƣơng ứng của hệ điều hành.", "order_start": 0, "order_end": 468, "word_count": 105}
{"parent_id": "5acbcf30-d900-4df3-90a4-20a4f709c320", "subject": "hedieuhanh", "section": "V. QUÁ TRÌNH PHÁT TRIỂN", "title_path": "V. QUÁ TRÌNH PHÁT TRIỂN", "content": "[hedieuhanh / V. QUÁ TRÌNH PHÁT TRIỂN] Các hệ thống đơn giản (những năm 40-50 của thế kỷ trƣớc): tốc độ xử lý của máy tính rất thấp, việc vào/ra đƣợc thực hiện thủ công và khó khăn. Việc nạp chƣơng trình đƣợc thực hiện nhờ công tắc, mạch hàn sẵn, bìa đục lỗ. Trong thời kỳ này, lập trình viên tƣơng tác trực tiếp với phần cứng. => Máy tính thời kỳ này chƣa có HDH.", "order_start": 0, "order_end": 325, "word_count": 70}
{"parent_id": "45fbdbb1-1b8c-4ce3-a46d-4258af1f5724", "subject": "hedieuhanh", "section": "Xử lý theo mẻ:", "title_path": "Xử lý theo mẻ:", "content": "[hedieuhanh / Xử lý theo mẻ:] Chƣơng trình đƣợc phân thành các mẻ: gồm những chƣơng trình có yêu cầu giống nhau Toàn bộ mẻ đƣợc nạp vào băng từ và đƣợc tải vào máy để thực hiện lần lƣợt Chương trình giám sát (monitor): mỗi khi một chƣơng trình của mẻ kết thúc, chƣơng trình giám sát tự động nạp chƣơng trình tiếp theo vào máy và cho phép nó chạy => Giảm đáng kể thời gian chuyển đổi giữa hai chƣơng trình trong cùng một mẻ Trình giám sát là dạng đơn giản nhất của HDH Nhƣợc điểm: Mỗi khi có yêu cầu vào/ra, CPU phải dừng việc xử lý dữ liệu để chờ quá trình vào ra kết thúc. Do tốc độ vào/ra thấp hơn tốc độ CPU rất nhiều nên CPU thƣờng xuyên phải chờ đợi 1 thời BỘ MÔN: KHOA HỌC MÁY TÍNH – KHOA CNTT1", "order_start": 0, "order_end": 670, "word_count": 145}
{"parent_id": "be2cc7f2-3198-4594-946b-0a22945733c1", "subject": "hedieuhanh", "section": "Đa chƣơng trình (đa nhiệm):", "title_path": "Đa chƣơng trình (đa nhiệm):", "content": "[hedieuhanh / Đa chƣơng trình (đa nhiệm):] Hệ thống chứa đồng thời nhiều chƣơng trình trong bộ nhớ Khi một chƣơng trình phải dừng lại để thực hiện vào ra, HDH sẽ chuyển CPU sang thực hiện một chƣơng trình khác => Giảm thời gian chạy không tải của CPU", "order_start": 0, "order_end": 207, "word_count": 43}
{"parent_id": "1651e847-efd4-4ea2-94bb-2bad89e11abb", "subject": "hedieuhanh", "section": "(a) Don chvong trinh", "title_path": "(a) Don chvong trinh", "content": "[hedieuhanh / (a) Don chvong trinh] Chuong trinh A Chay Chò dąi Chay Chà dąi Chuong trinh B Chà doi Chay Chò dgi Chay Chò dgi", "order_start": 0, "order_end": 89, "word_count": 20}
{"parent_id": "ea4d60bc-973a-4723-beb6-1437e6dac89d", "subject": "hedieuhanh", "section": "(b) Da chvong trình", "title_path": "(b) Da chvong trình", "content": "[hedieuhanh / (b) Da chvong trình] Thời gian chờ đợi của CPU trong chế độ đa chƣơng trình giảm đáng kể so với trong trƣờng hợp đơn chƣơng trình HDH phức tạp hơn rất nhiều so với HDH đơn chƣơng trình Đòi hỏi hỗ trợ từ phần cứng, đặc biệt khả năng vào/ra bằng ngắt và DMA", "order_start": 0, "order_end": 234, "word_count": 51}
{"parent_id": "eb2ebda2-c90d-4bf7-81c4-505c71bc37d8", "subject": "hedieuhanh", "section": "V. QUÁ TRÌNH PHÁT TRIỂN", "title_path": "V. QUÁ TRÌNH PHÁT TRIỂN", "content": "[hedieuhanh / V. QUÁ TRÌNH PHÁT TRIỂN] Đa chƣơng trình (Hạn chế) Mặc dù đa chương trình cho phép sử dụng hiệu quả CPU và các tài nguyên khác của hệ thống song kỹ thuật này không cho người dùng tương tác với hệ thống. Các máy tính thế hệ sau cho phép máy tính và người dùng làm việc trực tiếp thông quan màn hình và bàn phím. Đối với các hệ thống này thì thời gian từ khi người dùng gõ lệnh cho tới khi máy tính phản xạ lại tương đối nhỏ. Kỹ thuật đa chương trình không đảm bảo được thời gian đáp ứng ngắn như vậy.", "order_start": 0, "order_end": 474, "word_count": 104}
{"parent_id": "80df5374-99d1-4e2e-97c1-256cdd8925aa", "subject": "hedieuhanh", "section": "Chia sẻ thời gian:", "title_path": "Chia sẻ thời gian:", "content": "[hedieuhanh / Chia sẻ thời gian:] Chia sẻ thời gian có thể coi nhƣ đa chƣơng trình cải tiến CPU lần lƣợt thực hiện các công việc khác nhau trong những khoảng thời gian ngắn gọi là lƣợng tử thời gian Chuyển đổi giữa các công việc diễn ra với tần số cao và tốc độ CPU lớn => Tất cả ngƣời dùng đều có cảm giác máy tính chỉ thực hiện chƣơng trình của mình => CPU đƣợc chia sẻ giữa những ngƣời dùng khác nhau tƣơng tác trực tiếp với hệ thống Quản lý tiến trình: Tạo và xoá tiến trình Tạm treo và khôi phục các tiến trình bị treo Đồng bộ hoá các tiến trình (lập lịch cho các tiến trình .v.v.) Giải quyết các bế tắc, ví dụ nhƣ khi có xung đột về tài nguyên Tạo cơ chế liên lạc giữa các tiến trình Quản lý bộ nhớ: Quản lý việc phân phối bộ nhớ giữa các tiến trình Tạo ra bộ nhớ ảo và ánh xạ địa chỉ bộ nhớ ảo vào bộ nhớ thực Cung cấp và giải phóng bộ nhớ theo yêu cầu của các tiến trình Quản lý không gian nhớ đã đƣợc cấp và không gian còn trống (Tiến trình: chƣơng trình đang trong thời gian thực hiện)", "order_start": 0, "order_end": 961, "word_count": 213}
{"parent_id": "d7a8795a-c1a4-4cf9-b678-1835cf2aaab7", "subject": "hedieuhanh", "section": "Quản lý vào ra:", "title_path": "Quản lý vào ra:", "content": "[hedieuhanh / Quản lý vào ra:] Đơn giản hoá và tăng hiệu quả quá trình trao đổi thông tin giữa các tiến trình với thiết bị vào ra Quản lý tệp và thƣ mục: Tạo, xóa tệp và thƣ mục Đọc ghi tệp Ánh xạ tệp và thƣ mục sang bộ nhớ ngoài Hỗ trợ mạng và xử lý phân tán Giao diện với ngƣời dùng Các chƣơng trình tiện ích và ứng dụng", "order_start": 0, "order_end": 291, "word_count": 68}
{"parent_id": "181bc865-a886-405e-8e61-4575c599abaf", "subject": "hedieuhanh", "section": "VI. CẤU TRÚC HDH 2. NHÂN CỦA HDH", "title_path": "VI. CẤU TRÚC HDH 2. NHÂN CỦA HDH", "content": "[hedieuhanh / VI. CẤU TRÚC HDH 2. NHÂN CỦA HDH] HDH gồm rất nhiều thành phần, tuy nhiên độ quan trọng của các tp khác nhau, có những tp không thể thiếu là cơ sở cho toàn hệ thống hoạt động, một số tp của HDH cung cấp chức năng kém quan trọng hơn. => chỉ tải những thành phần quan trọng không thể thiếu đƣợc vào bộ nhớ gọi là nhân. Nhân (kernel) là phần cốt lõi, thực hiện các chức năng cơ bản nhất, quan trọng nhất của HDH và thường xuyên được giữ trong bộ nhớ", "order_start": 0, "order_end": 412, "word_count": 89}
{"parent_id": "fa5f05eb-4080-4e3c-9b66-b96d4733b007", "subject": "hedieuhanh", "section": "VI. CẤU TRÚC HDH 2. NHÂN CỦA HDH", "title_path": "VI. CẤU TRÚC HDH 2. NHÂN CỦA HDH", "content": "[hedieuhanh / VI. CẤU TRÚC HDH 2. NHÂN CỦA HDH] Máy tính hiện đại thƣờng đƣợc thiết kế với hai chế độ thực hiện chƣơng trình. Nhân chạy trong chế độ đặc quyền – chế độ nhân: là chế độ mà chƣơng trình thực hiện trng đó có đầy đủ quyền truy cập và điều khiển phần cứng máy tính. Chế độ ngƣời dùng: ch trình thực hiện trong chế độ ngƣời dùng bị hạn chế rất nhiều quyền truy cập và sử dụng phần cứng. Việc phân biệt chế độ nhân và chế độ ngƣời dùng nhằm mục đích ngăn không cho CTUD vô tình hoặc cố ý thực hiện những thao tác làm ảnh hƣởng tới hệ thống.", "order_start": 0, "order_end": 501, "word_count": 110}
{"parent_id": "432c6f96-2453-4ea4-8be4-d05ab385e3b9", "subject": "hedieuhanh", "section": "Cấu trúc nguyên khối", "title_path": "Cấu trúc nguyên khối", "content": "[hedieuhanh / Cấu trúc nguyên khối] Toàn bộ chƣơng trình và dữ liệu của HDH có chung 1 không gian nhớ HDH trở thành một tập hợp các thủ tục hay các chƣơng trình con Ƣu điểm: nhanh, không mất thời gian giữa các không gian nhớ Nhƣợc điểm: Không an toàn: khi bất kỳ thành phần nào có sự cố thì toàn bộ hệ thống sẽ không hoạt động đc; Ko mềm dẻo và khó sửa đổi, thêm bớt tp nào sẽ ảnh hƣởng tới toàn bộ hệ thống, khi có lỗi khó xác định lỗi do tpnào gây ra. Linux", "order_start": 0, "order_end": 423, "word_count": 96}
{"parent_id": "a51573d0-3f51-4361-b8eb-7321f8e9bc01", "subject": "hedieuhanh", "section": "Cấu trúc vi nhân", "title_path": "Cấu trúc vi nhân", "content": "[hedieuhanh / Cấu trúc vi nhân] Nhân có kích thƣớc nhỏ, chỉ chứa các chức năng quan trọng nhất Các chức năng còn lại đƣợc đặt vào các modul riêng: chạy trong chế độ đặc quyền hoặc ngƣời dùng. Khi có yêu cầu từ ứng dụng, nhân sẽ chuyển cho module tƣơng ứng để xử lý và nhận lại kết quả, nhân chủ yếu đóng vai trò trung gia liên lạc. Ƣu điểm: mềm dẻo, an toàn Nhƣợc điểm: tốc độ chậm hơn so với cấu trúc nguyên khối", "order_start": 0, "order_end": 381, "word_count": 83}
{"parent_id": "cb1682a2-08c1-4dfb-8eb6-662a644ce032", "subject": "hedieuhanh", "section": "Cấu trúc phân lớp", "title_path": "Cấu trúc phân lớp", "content": "[hedieuhanh / Cấu trúc phân lớp] Các thành phần đƣợc chia thành các lớp nằm chồng lên nhau Mỗi lớp chỉ có thể liên lạc với lớp nằm kề bên trên và kề bên dƣới Mỗi lớp chỉ có thể sử dụng dịch vụ do lớp nằm ngay bên dƣới cung cấp Ƣu điểm: chia nhỏ chứng năng, dễ sử dụng, dễ sửa lỗi Nhƣợc điểm: khó thiết kế do khó sắp xếp các chức năng, tốc độ chậm hơn cấu trúc nguyên khối PHÂN CÚNG", "order_start": 0, "order_end": 348, "word_count": 80}
{"parent_id": "a0f182bd-671e-44c6-b148-4fa4dbd4ea70", "subject": "hedieuhanh", "section": "CHƢƠNG 2: HỆ THỐNG FILE", "title_path": "CHƢƠNG 2: HỆ THỐNG FILE", "content": "[hedieuhanh / CHƢƠNG 2: HỆ THỐNG FILE] Các khái niệm 2. Các phƣơng pháp truy cập file 3. Các thao tác với file Thƣ mục 5. Cấp phát không gian cho file - Quản lý không gian trống trên đĩa Độ tin cậy của hệ thống file Bảo mật cho hệ thống file Hệ thống file FAT Hệ thống máy tính phải có khả năng lƣu lại đƣợc các thông tin, dữ liệu Hệ thống lƣu trữ của các loại máy tính cao cấp thƣờng có kích thƣớc rất lớn nên sẽ chứa rất nhiều dữ liệu Lƣợng dữ liệu lƣu trữ quá lớn, nếu không khéo trong việc quản lý truy cập sẽ khó khăn và hao tốn thời gian. => cần có các hình thức tổ chức, sắp xếp dữ liệu một cách hợp lý và xây dựng các thuật toán tối ƣu để có thể truy cập nhanh chóng, hiệu quả", "order_start": 0, "order_end": 645, "word_count": 147}
{"parent_id": "487fb84d-b0f2-4c13-8d3a-6bed508408c3", "subject": "hedieuhanh", "section": "I. CÁC KHÁI NIỆM", "title_path": "I. CÁC KHÁI NIỆM", "content": "[hedieuhanh / I. CÁC KHÁI NIỆM] File được định nghĩa như tập hợp các thông tin liên quan đến nhau được đặt tên và được lưu trữ trên bộ nhớ ngoài Thuộc tính của file: để quản lý file ngoài nội dung, HĐH còn định nghĩa các thuộc tính, tính chất. File có các thuộc tính nhƣ sau: Tên file Kiểu file Kích thƣớc file Ngƣời tạo file, ngƣời sở hữu Quyền truy cập file Thời gian tạo file, sửa file, truy cập lần cuối Vị trí file", "order_start": 0, "order_end": 387, "word_count": 82}
{"parent_id": "8fb7eece-f0d7-4d02-8ada-167fd10991f8", "subject": "hedieuhanh", "section": "Đặt tên cho file:", "title_path": "Đặt tên cho file:", "content": "[hedieuhanh / Đặt tên cho file:] Cho phép xác định file Là thông tin ngƣời dùng thƣờng sử dụng nhất khi làm việc với file Quy tắc đặt tên cho file của một số HDH: ấu trúc file:", "order_start": 0, "order_end": 143, "word_count": 32}
{"parent_id": "cbd88386-b107-4ad5-9f93-49de9321d095", "subject": "hedieuhanh", "section": "I. CÁC KHÁI NIỆM", "title_path": "I. CÁC KHÁI NIỆM", "content": "[hedieuhanh / I. CÁC KHÁI NIỆM] Các thông tin trong file có thể rất khác nhau Có những file chứa nhiều thông tin không có cấu trúc: file văn bản. File có cấu trúc nhƣ: file CSDL, file excel. => Cấu trúc của file cũng rất khác nhau và phụ thuộc vào thông tin chứa trong file HDH có cần biết và hỗ trợ các kiểu cấu trúc file? Hỗ trợ cấu trúc file ở mức HDH: Ƣu điểm: Các thao tác với file sẽ dễ dàng hơn đối với ngƣời lập trình ứng dụng HDH có thể kiểm soát đƣợc các thao tác với file Nhƣợc điểm: Tăng kích thƣớc hệ thống Tính mềm dẻo của HDH bị giảm Thực tế các HDH chỉ coi file là tập hợp các byte không cấu trúc", "order_start": 0, "order_end": 580, "word_count": 129}
{"parent_id": "ca890ffb-481f-48a7-b999-aa35f602f238", "subject": "hedieuhanh", "section": "I. CÁC KHÁI NIỆM", "title_path": "I. CÁC KHÁI NIỆM", "content": "[hedieuhanh / I. CÁC KHÁI NIỆM] Đa số HDH không hỗ trợ và quản lý kiểu cấu trúc file Cấu trúc file do chƣơng trình ứng dụng và ngƣời dùng tự quản lý Trong HDH UNIX, DOS, WINDOWS, file đƣợc xem nhƣ tập hợp các byte. Các chƣơng trình ứng dụng khác nhau sẽ tự tạo ra và quản lý cấu trúc file riêng mình. Ví dụ: chƣơng trình đồ họa lƣu file dƣới dạng mã nhị phân đã đƣợc giải nén, chƣơng trình hệ thống quản lý dữ liệu sẽ tạo ra file bao gồm các bản ghi.", "order_start": 0, "order_end": 418, "word_count": 93}
{"parent_id": "8a7f2303-5626-4c09-828c-a8c45ae84437", "subject": "hedieuhanh", "section": "II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE", "title_path": "II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE", "content": "[hedieuhanh / II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE] Để đọc/ghi file hệ điều hành phải quy định cách thức truy cập tới nội dung file. Mỗi HDH có thể hỗ trợ một hoặc nhiều cách truy cập khác nhau. Truy cập tuần tự: Thông tin đƣợc đọc, ghi theo từng byte/ bản ghi lần lƣợt từ đầu file Sử dụng 1 con trỏ để định vị vị trí hiện thời trong file Kiểu truy cập này phù hợp với một số thiết bị và một số thiết bị nhớ và một số ứng dụng", "order_start": 0, "order_end": 374, "word_count": 86}
{"parent_id": "9882e2d5-5470-459e-a77b-7df13e3d05a1", "subject": "hedieuhanh", "section": "II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE", "title_path": "II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE", "content": "[hedieuhanh / II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE] Truy cập trực tiếp: File đƣợc xem nhƣ các khối/ bản ghi đƣợc đánh số Các khối có thể truy cập theo thứ tự bất kỳ Chẳng hạn ta có thể đọc khối 50 sau đó đọc khổi 13 rồi khối 101. Việc truy cập trực tiếp dựa trên đặc điểm của đĩa cho phép truy cập các khối bất kỳ File đƣợc chứa trong các khối khác nhau của đĩa do vậy cũng cho phép truy cập không tuần theo thứ tự", "order_start": 0, "order_end": 362, "word_count": 83}
{"parent_id": "c741e086-23b7-4aad-8a64-69eebc666306", "subject": "hedieuhanh", "section": "II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE", "title_path": "II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE", "content": "[hedieuhanh / II. CÁC PHƯƠNG PHÁP TRUY CẬP FILE] Truy cập dựa trên chỉ số: Cho phép truy cập tới bản ghi trong file, không theo số thứ tự hoặc vị trí của bản ghi trong file mà theo khóa ứng với bản ghi đó. File chứa 1 chỉ số riêng: gồm các khóa và con trỏ chỉ tới các bản ghi trong file Truy cập: tìm khóa tƣơng ứng trong chỉ mục, sau đó theo con trỏ xác định bản ghi và truy cập trực tiếp tới nó", "order_start": 0, "order_end": 347, "word_count": 80}
{"parent_id": "fc48adad-c504-41d6-a48e-dbf8bcf34423", "subject": "hedieuhanh", "section": "Tạo file:", "title_path": "Tạo file:", "content": "[hedieuhanh / Tạo file:] Tạo file trống chƣa có data; đƣợc dành 1 chỗ trong thƣ mục kèm theo một số thuộc tính nhƣ thời gian tạo file, tên file, ngƣời tạo file,...", "order_start": 0, "order_end": 138, "word_count": 29}
{"parent_id": "bce3ad62-fb8a-4ce2-9e09-f4cd6d14bc02", "subject": "hedieuhanh", "section": "Xóa file:", "title_path": "Xóa file:", "content": "[hedieuhanh / Xóa file:] Giải phóng không gian mà dữ liệu của file chiếm trên đĩa Giải phóng chỗ của file trong thƣ mục Việc giải phóng không gian có thể đơn thuần là đánh dấu không gian nhƣ không gian tự do.", "order_start": 0, "order_end": 183, "word_count": 39}
{"parent_id": "866133ed-1c93-4e2b-944d-88a69bfcb02e", "subject": "hedieuhanh", "section": "Mở file:", "title_path": "Mở file:", "content": "[hedieuhanh / Mở file:] Thực hiện trƣớc khi ghi và đọc file Đọc các thuộc tính của file trên đĩa vào bộ nhớ để tăng tốc độ cho thao tác đọc ghi tiếp theo.", "order_start": 0, "order_end": 130, "word_count": 30}
{"parent_id": "b27e547e-a860-4278-8e25-28b74cbef505", "subject": "hedieuhanh", "section": "Đóng file:", "title_path": "Đóng file:", "content": "[hedieuhanh / Đóng file:] Xóa các thông tin về file ra khỏi bảng trong bộ nhớ để nhƣờng chỗ cho các file sắp mở. Rất nhiều hệ điều hành hạn chế số lƣợng file đƣợc mởcùng một lúc nên việc đóng các file đã truy cập xong là rất quan trọng. Ghi vào file Đọc file", "order_start": 0, "order_end": 232, "word_count": 52}
{"parent_id": "8d2c22dd-5c72-4670-b225-ed3ec6d8cc14", "subject": "hedieuhanh", "section": "IV. THƯ MỤC", "title_path": "IV. THƯ MỤC", "content": "[hedieuhanh / IV. THƯ MỤC] 1. Khái niệm Số lƣợng file lƣu trữ trên đĩa rất lớn => phải tổ chức để dễ dàng quản lý, truy cập files Không gian trên đĩa đƣợc chia thành các phần (partition/ volume) gọi là đĩa logic Ví dụ: trên máy tính PC có 1 ổ cứng và có thể chia thành các ổ C,D,E => đĩa logic Để quản lý file trên các đĩa logic, thông tin về file đƣợc lƣu trong thƣ mục của đĩa Thƣ mục = ∑ các khoản mục ~ files Khoản mục chứa các thông tin về file: tên, kích thƣớc, vị trí, kiểu file,… hoặc con trỏ tới nơi lƣu trữ thông tin này Coi thƣ mục nhƣ 1 bảng, mỗi dòng là khoản mục ứng với 1 file Các cách lƣu thông tin về file trong thƣ mục: Toàn bộ thuộc tính của file đƣợc lƣu trong thƣ mục, file chỉ chứa data => kích thƣớc khoản mục, thƣ mục lớn Một phần thuộc tính đƣợc lƣu trữ luôn cùng với dữ liệu của file.", "order_start": 0, "order_end": 783, "word_count": 175}
{"parent_id": "8d2c22dd-5c72-4670-b225-ed3ec6d8cc14", "subject": "hedieuhanh", "section": "IV. THƯ MỤC", "title_path": "IV. THƯ MỤC", "content": "[hedieuhanh / IV. THƯ MỤC] hƣ mục: Toàn bộ thuộc tính của file đƣợc lƣu trong thƣ mục, file chỉ chứa data => kích thƣớc khoản mục, thƣ mục lớn Một phần thuộc tính đƣợc lƣu trữ luôn cùng với dữ liệu của file. Thƣ mục chỉ lƣu thông tin tối thiểu cần thiết cho việc tìm kiếm vị trí file trên đĩa => kích thƣớc giảm", "order_start": 783, "order_end": 1067, "word_count": 62}
{"parent_id": "a9732716-f9a3-46f9-9b73-0947d45e06d0", "subject": "hedieuhanh", "section": "Mở file:", "title_path": "Mở file:", "content": "[hedieuhanh / Mở file:] HDH tìm trong thƣ mục khoản mục ứng với tên file cần mở Đọc các thuộc tính và vị trí dữ liệu của file vào bảng chứa thông tin về các file đang mở Nếu khoản mục trỏ tới CTDL khác chứa thuộc tính file, cấu trúc này sẽ đƣợc đọc vào bảng Tìm kiếm file: cấu trúc thƣ mục phải cho phép tìm kiếm file theo tên file Tạo file: tạo khoản mục mới và thêm vào thƣ mục Xóa file: thông tin về file và khoản mục tƣơng ứng bị xóa khỏi thƣ mục Duyệt thƣ mục: liệt kê các file trong thƣ mục và thông tin chứa trong khoản mục của file Đổi tên file: chỉ cần thực hiện với thƣ mục chứ không liên quan đến dữ liệu của file Thƣ mục 1 mức: Đơn giản nhất Chỉ có 1 thƣ mục duy nhất và tất cả các file đƣợc giữ trong thƣ mục này Khó chọn tên cho file Tìm kiếm file khó Thƣ mục 2 mức: Phân cho mỗi ngƣời dùng 1 thƣ mục riêng (UFD: User File Directory), chứa các file của mình Khi ngƣời dùng truy cập file, file sẽ đƣợc tìm kiếm trong thƣ mục ứng với tên ngƣời đó => các ngƣời dùng khác nhau có thể đặt tên file trùng nhau Cô lập ngƣời dùng Các file mà nhiều ngƣời dùng truy cập tới => chép vào từng thƣ mục của từng ngƣời dùng =", "order_start": 0, "order_end": 1100, "word_count": 246}
{"parent_id": "a9732716-f9a3-46f9-9b73-0947d45e06d0", "subject": "hedieuhanh", "section": "Mở file:", "title_path": "Mở file:", "content": "[hedieuhanh / Mở file:] i tên ngƣời đó => các ngƣời dùng khác nhau có thể đặt tên file trùng nhau Cô lập ngƣời dùng Các file mà nhiều ngƣời dùng truy cập tới => chép vào từng thƣ mục của từng ngƣời dùng => lãng phí Thƣ mục cấu trúc cây: Thƣ mục con có thể chứa các thƣ mục con khác và các files Hệ thống thƣ mục đƣợc biểu diễn phân cấp nhƣ 1 cây: cành là thƣ mục, lá là file Thƣ mục cấu trúc cây (tt): Phân biệt khoản mục file và khoản mục của thƣ mục con: thêm bit đặc biệt trong khoản mục 1: khoản mục của thƣ mục mức dƣới 0: khoản mục của file Tại mỗi thời điểm, ngƣời dùng làm việc với thƣ mục hiện thời (current directory) Tổ chức cây thƣ mục cho từng đĩa: Trong hệ thống file nhƣ FAT của DOS, cây thƣ mục đƣợc xây cho từng đĩa.", "order_start": 1100, "order_end": 1809, "word_count": 158}
{"parent_id": "a9732716-f9a3-46f9-9b73-0947d45e06d0", "subject": "hedieuhanh", "section": "Mở file:", "title_path": "Mở file:", "content": "[hedieuhanh / Mở file:] i thời điểm, ngƣời dùng làm việc với thƣ mục hiện thời (current directory) Tổ chức cây thƣ mục cho từng đĩa: Trong hệ thống file nhƣ FAT của DOS, cây thƣ mục đƣợc xây cho từng đĩa. Hệ thống thƣ mục đƣợc coi là rừng, mỗi cây trên 1 đĩa Linux: toàn hệ thống chỉ gồm 1 cây thƣ mục", "order_start": 1809, "order_end": 2086, "word_count": 61}
{"parent_id": "2aa93283-f96d-4edd-b014-902f5b00c760", "subject": "hedieuhanh", "section": "IV. THƯ MỤC", "title_path": "IV. THƯ MỤC", "content": "[hedieuhanh / IV. THƯ MỤC] 3. Cấu trúc hệ thống thư mục Thƣ mục cấu trúc đồ thị không tuần hoàn (acyclic graph ): Chia sẻ files và thƣ mục để có thể xuất hiện ở nhiều thƣ mục riêng khác nhau Mở rộng của cấu trúc cây: lá và cành có thể đồng thời thuộc về những cành khác nhau Triển khai: Sử dụng liên kết: con trỏ tới thƣ mục hoặc file khác Tạo bản sao của file và thƣ mục cần chia sẻ và chứa vào các thƣ mục khác nhau => phải đảm bảo tính đồng bộ và nhất quán Thư mục gốc Mềm dẻo nhƣng phức tạp Mô tả vị trí của file trong thƣ mục Đƣờng dẫn tuyệt đối: Đƣờng dẫn từ gốc của cây thƣ mục, đi qua các thƣ mục trung gian, dẫn tới file C:\\bc\\bin\\bc.exe Đƣờng dẫn tƣơng đối: Tính từ thƣ mục hiện thời Thêm 2 khoản mục đặc biệt trong thƣ mục: “.”, “..", "order_start": 0, "order_end": 716, "word_count": 160}
{"parent_id": "2aa93283-f96d-4edd-b014-902f5b00c760", "subject": "hedieuhanh", "section": "IV. THƯ MỤC", "title_path": "IV. THƯ MỤC", "content": "[hedieuhanh / IV. THƯ MỤC] ừ gốc của cây thƣ mục, đi qua các thƣ mục trung gian, dẫn tới file C:\\bc\\bin\\bc.exe Đƣờng dẫn tƣơng đối: Tính từ thƣ mục hiện thời Thêm 2 khoản mục đặc biệt trong thƣ mục: “.”, “..”", "order_start": 716, "order_end": 897, "word_count": 38}
{"parent_id": "d57e5181-1210-431d-a082-0f4fe37023cd", "subject": "hedieuhanh", "section": "Danh sách:", "title_path": "Danh sách:", "content": "[hedieuhanh / Danh sách:] Tổ chức thƣ mục dƣới dạng danh sách các khoản mục Tìm kiếm khoản mục đƣợc thực hiện bằng cách duyệt lần lƣợt danh sách Thêm file mới vào thƣ mục:  Duyệt cả thƣ mục để kiểm tra xem khoản mục với tên file nhƣ vậy đã có chƣa Khoản mục mới đƣợc thêm vào cuối danh sách hoặc 1 ô trong bảng Mở file, xóa file Tìm kiếm trong danh sách chậm Lƣu trữ thƣ mục trong bộ nhớ", "order_start": 0, "order_end": 362, "word_count": 81}
{"parent_id": "600841e4-3da8-44a5-a458-0ebcb2ee9d06", "subject": "hedieuhanh", "section": "Cây nhị phân:", "title_path": "Cây nhị phân:", "content": "[hedieuhanh / Cây nhị phân:] Tăng tốc độ tìm kiếm nhờ CTDL có hỗ trợ sắp xếp Hệ thống file NTFS của WinNT Bảng băm (hash table): Dùng hàm băm để tính vị trí của khoản mục trong thƣ mục theo tên file Thời gian tìm kiếm nhanh Hàm băm phụ thuộc vào kích thƣớc của bảng băm => kích thƣớc bảng cố định", "order_start": 0, "order_end": 267, "word_count": 59}
{"parent_id": "f6b3c53d-fd92-48af-851e-26967dba4dca", "subject": "hedieuhanh", "section": "IV. THƯ MỤC", "title_path": "IV. THƯ MỤC", "content": "[hedieuhanh / IV. THƯ MỤC] 5. Tổ chức bên trong của thư mục Tổ chức thƣ mục của DOS: Mỗi đĩa logic có cây thƣ mục riêng, bắt đầu từ thƣ mục gốc ROOT Thƣ mục gốc đƣợc đặt ở phần đầu của đĩa, ngay sau sector khởi động BOOT và bảng FAT Thƣ mục gốc chứa files và các thƣ mục con Thƣ mục con có thể chứa files và các thƣ mục cấp dƣới nữa Đƣợc tổ chức dƣới dạng bảng: mỗi khoản mục chiếm 1 dòng trong bảng và có kích thƣớc cố định 32 bytes Tổ chức thƣ mục của Linux: Thƣ mục hệ thống file Ext2 của Linux có cách tổ chức đơn giản Khoản mục chứa tên file và địa chỉ I-node Thông tin còn lại về các thuộc tính file và vị trí các khối dữ liệu đƣợc lƣu trên I-node chứ không phải thƣ mục Kích thƣớc khoản mục phụ thuộc vào độ dài tên file Phần đầu của khoản mục có trƣờng cho biết kích thƣớc khoản mục", "order_start": 0, "order_end": 763, "word_count": 172}
{"parent_id": "eb2edcff-3a1d-4e49-a0c4-253f65bdbac6", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE] Nhiệm vụ quan trọng của HDH trong việc quản lý hệ thống file là cấp phát không gian trên đĩa và các hiết bị nhớ ngoài khác để lƣu trữ file và thƣ mục Đồng thời, ghi lại vị trí các khối nhớ đã cấp phát để có thể tiến hành truy cập về sau. Hard Drive Structure: A = track B = sector C = sector of a track D = cluster", "order_start": 0, "order_end": 314, "word_count": 73}
{"parent_id": "13ada75b-42ab-433a-be1c-a3bcd697c026", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE] Phép ánh xạ file: từ tên file có thể chỉ ra vị trí file trên đĩa Sơ bộ về tổ chức đĩa: Thông tin đƣợc đọc/ghi theo từng khối sector Nhóm các sector thành block hay cluster (khối) Trên đĩa: 1 file gồm 1 tập các khối. HDH chịu trách nhiệm cấp phát các khối cho file: Không gian trên đĩa phải đƣợc cấp phát cho file Cần theo dõi không gian trống sẵn sàng cho việc cấp phát Một số vấn đề: Không gian tối đa yêu cầu cấp phát cho file 1 lần là bao nhiêu? Không gian cấp phát cho file gọi là phần (portion). Kích thƣớc phần ntn?", "order_start": 0, "order_end": 521, "word_count": 112}
{"parent_id": "3d8b1bb2-4c90-4939-a5c4-6a27d6c8776a", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp] Đƣợc cấp phát 1 khoảng không gian gồm các khối liên tiếp trên đĩa (các sector) Vị trí file trên đĩa đƣợc xác định bởi vị trí khối đầu tiên và độ dài (số khối) mà file đó chiếm Khi có yêu cầu cấp phát, HDH sẽ chọn 1 vùng trống có số lƣợng khối đủ cấp cho file đó Bảng cấp phát file chỉ cần 1 khoản mục cho 1 file, chỉ ra khối bắt đầu, và độ dài của file tính = khối Là cấp phát trƣớc, sử dụng kích thƣớc phần thay đổi", "order_start": 0, "order_end": 416, "word_count": 96}
{"parent_id": "1802a641-d77f-4c63-a94f-45f03c8c9898", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp (tt)", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp (tt)", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp (tt)] V. CẤP PHÁT KHÔNG GIAN CHO FILE 1. Cấp phát các khối liên tiếp (tt) Ƣu điểm: Cho phép truy cập trực tiếp và tuần tự Đơn giản, tốc độ cao Nhƣợc điểm: Phải biết trƣớc kích thƣớc file khi tạo Khó tìm chỗ cho file Gây phân mảnh ngoài: đó là hiện tƣợng vùng trống còn lại trên đĩa có kích thƣớc quá nhỏ do vậy không thể cấp phát cho file có kích thƣớc lơn hơn.", "order_start": 0, "order_end": 355, "word_count": 78}
{"parent_id": "621976d3-3cef-43e4-9ca4-be7098107c02", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối] Các khối đƣợc kết nối với nhau thành danh sách kết nối; phần đầu mỗi khối chứa con trỏ trỏ tới khối tiếp theo Các khối thuộc về 1 file có thể nằm ở vị trí bất kì trên đĩa Khoản mục của thƣ mục chứa con trỏ tới khối đầu tiên của file Khi file đƣợc cấp thêm khối mới, khối đó đƣợc thêm vào cuối danh sách HDH đọc lần lƣợt từng khối và sử dụng con trỏ để xác định khối tiếp theo", "order_start": 0, "order_end": 375, "word_count": 86}
{"parent_id": "2c56eccd-ee83-47fa-a0bc-01aeacbf5e33", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt)", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt)", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt)] V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt) Ƣu điểm: Không bị phân mảnh ngoài Không yêu cầu biết trƣớc kích thƣớc file lúc tạo Dễ tìm vị trí cho file, khoản mục đơn giản Nhƣợc điểm: Không hỗ trợ truy cập trực tiếp Tốc độ truy cập không cao Giảm độ tin cậy và tính toàn vẹn của hệ thống file V. CẤP PHÁT KHÔNG GIAN CHO FILE 3. Sử dụng danh sách kết nối trên bảng chỉ số Bảng chỉ số: mỗi ô của bảng ứng với 1 khối (sector) của đĩa Con trỏ tới khối tiếp theo của file đƣợc chứa trong ô tƣơng ứng của bảng Mỗi đĩa logic có 1 bảng chỉ số đƣợc lƣu ở vị trí xác định Kích thƣớc mỗi ô trên bảng phụ thuộc vào số lƣợng khối trên đĩa thu muc V. CẤP PHÁT KHÔNG GIAN CHO FILE 3. Sử dụng danh sách kết nối trên bảng chỉ số (tt) Cho phép tiến hành truy cập file trực tiếp: đi theo chuỗi con trỏ chứa trong bảng chỉ mục Bảng FAT (File Allocation Table): đƣợc lƣu ở đầu mỗi đĩa logic sau sector khởi động FAT12, FAT16, FAT32: mỗi ô của bảng có kích thƣớc 12, 16, 32 bit V. CẤP PHÁT KHÔNG GIAN CHO FILE 4.", "order_start": 0, "order_end": 1010, "word_count": 224}
{"parent_id": "2c56eccd-ee83-47fa-a0bc-01aeacbf5e33", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt)", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt)", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 2. Sử dụng danh sách kết nối (tt)] g FAT (File Allocation Table): đƣợc lƣu ở đầu mỗi đĩa logic sau sector khởi động FAT12, FAT16, FAT32: mỗi ô của bảng có kích thƣớc 12, 16, 32 bit V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node) Tất cả con trỏ tới các khối thuộc về 1 file đƣợc tập trung 1 chỗ Mỗi file có một mảng riêng của mình chứa trong một khối gọi là khối chỉ mục (I-node) Mảng chứa thuộc tính của file và vị trí các khối của file trên đĩa Ô thứ i của mảng chứa con trỏ tới khối thứ i của file Khoản mục của file trong thƣ mục chứa con trỏ tới khối chỉ mục này", "order_start": 1010, "order_end": 1569, "word_count": 124}
{"parent_id": "a53a8a77-e3e7-4549-923f-06d103bdbed7", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node)", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node)", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node)] V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node) Chọn kích thƣớc I-node: Nhỏ: tiết kiệm không gian nhƣng không đủ con trỏ tới các khối nếu file lớn Lớn: với file nhỏ chỉ chiếm 1 vài ô thì lãng phí Giải pháp: Thay đổi kích thƣớc i-node = sử dụng danh sách kết nối Sử dụng I-node có cấu trúc nhiều mức", "order_start": 0, "order_end": 326, "word_count": 70}
{"parent_id": "b9c583a8-d7d4-46c5-a557-fab1173eb5ca", "subject": "hedieuhanh", "section": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node)", "title_path": "V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node)", "content": "[hedieuhanh / V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node)] I-node cấu trúc nhiều mức: không trỏ trực tiếp tới ô chứa dữ liệu mà trỏ tới các ô khối chỉ mục sau đó cái ô này mới chứa địa chỉ. V. CẤP PHÁT KHÔNG GIAN CHO FILE 4. Sử dụng khối chỉ mục (index block/ node) Ƣu điểm: Cho phép truy cập trực tiếp Các khối thuộc 1 file không cần nằm liên tiếp nhau Nhƣợc điểm: Tốc độ truy cập file chậm Kích thƣớc khối (cluster): Kích thƣớc khối lớn: Giảm kích thƣớc bảng chỉ mục, tăng tốc độ đọc file; Bị phân mảnh trong Kích thƣớc khối nhỏ: Mỗi file chiếm nhiều khối nhớ, nằm rải rác trên đĩa Thời gian đọc file lâu Chọn kích thƣớc khối tùy thuộc:  Kích thƣớc đĩa: đĩa lớn, chọn kích thƣớc khối lớn => thời gian truy cập nhanh, đơn giản hóa việc quản lý  Kích thƣớc file: hệ thống sử dụng nhiều file lớn, kích thƣớc tăng và ngƣợc Kích thƣớc khối thƣờng là lũy thừa 2 của sector và nằm trong khoảng từ 512B tới 32 KB", "order_start": 0, "order_end": 849, "word_count": 181}
{"parent_id": "3f92ba6e-2226-4e94-b463-378189458245", "subject": "hedieuhanh", "section": "VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 1. Bảng bit", "title_path": "VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 1. Bảng bit", "content": "[hedieuhanh / VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 1. Bảng bit] Vector bit là mảng 1 chiều Mỗi ô có kích thƣớc 1 bit tƣơng ứng với một khối trên đĩa Khối đƣợc cấp phát có bít tƣơng ứng là 0, khối trống: 1 hoặc ngƣợc lại Dễ tìm 1 hoặc nhóm các khối trống liên tiếp Với đĩa có kích thƣớc lớn, đọc toàn bộ vector bit vào MEM có thể đòi hỏi khá nhiều không gian nhớ", "order_start": 0, "order_end": 297, "word_count": 68}
{"parent_id": "71e282b4-9adc-4347-bef5-ec81537304e3", "subject": "hedieuhanh", "section": "VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 2. Danh sách kết nối", "title_path": "VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 2. Danh sách kết nối", "content": "[hedieuhanh / VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 2. Danh sách kết nối] Các khối trống đƣợc liên kết với nhau thành danh sách Mỗi khối trống chứa con trỏ chỉ tới khối trống tiếp theo Địa chỉ khối trống đầu tiên đƣợc lƣu ở vị trí đặc biệt trên đĩa và đƣợc HDH giữ trong MEM khi cần làm việc với các file Đòi hỏi truy cập lần lƣợt khi cần duyệt danh sách này HDH có thể cấp phát ngay các khối ở đầu danh sách", "order_start": 0, "order_end": 334, "word_count": 75}
{"parent_id": "ca80e83b-bbd3-4402-bdf3-398a04107b8d", "subject": "hedieuhanh", "section": "VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 3. danh sách vùng trống", "title_path": "VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 3. danh sách vùng trống", "content": "[hedieuhanh / VI. QUẢN LÝ KHÔNG GIAN TRỐNG TRÊN ĐĨA 3. danh sách vùng trống] Các khối nằm liền nhau thƣờng đƣợc cấp phát và giải phóng đồng thời Lƣu vị trí khối trống đầu tiên của vùng các khối trống liên tiếp và số lƣợng các khối trống nằm liền sau đó Thông tin trên đƣợc lƣu vào danh sách riêng VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 1. Phát hiện & loại trừ các khối hỏng", "order_start": 0, "order_end": 291, "word_count": 64}
{"parent_id": "62e88fe5-ad29-493c-b8ee-90b07130525c", "subject": "hedieuhanh", "section": "Phát hiện và loại trừ khối hỏng", "title_path": "Phát hiện và loại trừ khối hỏng", "content": "[hedieuhanh / Phát hiện và loại trừ khối hỏng] Phƣơng pháp 1: Một sector trên đĩa đƣợc dành riêng chứa danh sách các khối hỏng Một số khối không hỏng đƣợc dành riêng để dự trữ Các khối hỏng sẽ đƣợc thay thế bởi các khối dự trữ bằng cách thay thế địa chỉ Truy cập tới khối hỏng thành truy cập tới khối dự trữ Phƣơng pháp 2: Tập trung tất cả các khối hỏng thành 1 file => đƣợc coi nhƣ đã cấp phát và không đƣợc sử dụng nữa VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 2. Sao dự phòng Tạo ra một bản sao của đĩa trên một vật mang khác Sao lƣu toàn bộ (full backup): Ghi toàn bộ thông tin trên đĩa ra vật mang tin khác Chắc chắn nhƣng tốn nhiều thời gian Sao lƣu tăng dần (incremental backup): Đƣợc sử dụng sau khi đã tiến hành full backup ít nhất 1 lần Chỉ ghi lại các file đã bị thay đổi sau lần sao lƣu cuối cùng Hệ thống lƣu trữ thông tin về các lần lƣu trữ file DOS: file thay đổi, archive bit =1 Kết hợp: Full backup: hàng tuần/ tháng Incremental backup: hàng ngày VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 3.", "order_start": 0, "order_end": 945, "word_count": 206}
{"parent_id": "62e88fe5-ad29-493c-b8ee-90b07130525c", "subject": "hedieuhanh", "section": "Phát hiện và loại trừ khối hỏng", "title_path": "Phát hiện và loại trừ khối hỏng", "content": "[hedieuhanh / Phát hiện và loại trừ khối hỏng] u trữ thông tin về các lần lƣu trữ file DOS: file thay đổi, archive bit =1 Kết hợp: Full backup: hàng tuần/ tháng Incremental backup: hàng ngày VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 3. Kiểm tra tính toàn vẹn của hệ thống file Hệ thống file chứa nhiều CTDL có mối liên kết => thông tin về liên kết bị hƣ hại, tính toàn vẹn của hệ thống bị phá vỡ Các khối không có mặt trong danh sách các khối trống, đồng thời cũng không có mặt trong một file nào Một khối có thể vừa thuộc về một file nào đó vừa có mặt trong danh sách khối trống HDH có các chƣơng trình kiểm tra tính toàn vẹn của hệ thống file, đƣợc chạy khi hệ thống khởi động, đặc biệt là sau sự cố VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 3. Kiểm tra tính toàn vẹn của hệ thống file Ví dụ trong hệ UNIX: Tạo hai số đếm cho mỗi khối: Số đếm thứ nhất: số lần khối đó xuất hiện trong danh sách khối trống.", "order_start": 945, "order_end": 1789, "word_count": 186}
{"parent_id": "62e88fe5-ad29-493c-b8ee-90b07130525c", "subject": "hedieuhanh", "section": "Phát hiện và loại trừ khối hỏng", "title_path": "Phát hiện và loại trừ khối hỏng", "content": "[hedieuhanh / Phát hiện và loại trừ khối hỏng] ỦA HỆ THỐNG FILE 3. Kiểm tra tính toàn vẹn của hệ thống file Ví dụ trong hệ UNIX: Tạo hai số đếm cho mỗi khối: Số đếm thứ nhất: số lần khối đó xuất hiện trong danh sách khối trống. Số đếm thứ hai: số lần khối xuất hiện trong file Tất cả số đếm đƣợc khởi tạo bằng 0 Duyệt danh sách khối trống và toàn bộ i-node của các file  Một khối xuất hiện trong danh sách khối trống, số đếm tƣơng ứng thứ nhất đƣợc tăng một đơn vị Nếu khối xuất hiện trong i-node của file, số đếm tƣơng ứng thứ hai đƣợc tăng một đơn vị Só thú ty khói Tổng 2 số đếm =1 Só làn xuát hin trong danh sách tróng Só thú ty khói Só làn xuát hin trong file", "order_start": 1789, "order_end": 2407, "word_count": 140}
{"parent_id": "546dd75a-2f05-4cd5-ba0f-025f5bfc198e", "subject": "hedieuhanh", "section": "VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 4. Đảm bảo tính toàn vẹn bằng cách sử dụng giao tác", "title_path": "VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 4. Đảm bảo tính toàn vẹn bằng cách sử dụng giao tác", "content": "[hedieuhanh / VII. ĐỘ TIN CẬY CỦA HỆ THỐNG FILE 4. Đảm bảo tính toàn vẹn bằng cách sử dụng giao tác] Giao tác (transaction) là một tập hợp các thao tác cần phải đƣợc thực hiện trọn vẹn cùng với nhau Với hệ thống file: mỗi giao tác sẽ bao gồm những thao tác thay đổi liên kết cần thực hiện cùng nhau Toàn bộ trạng thái hệ thống file đƣợc ghi lại trong file log Nếu giao tác không đƣợc thực hiện trọn vẹn, HDH sử dụng thông tin từ log để khôi phục hệ thống file về trạng thái không lỗi trƣớc khi thực hiện giao tác", "order_start": 0, "order_end": 411, "word_count": 88}
{"parent_id": "22acd2d8-d0f2-4877-9bd7-092ae949fa86", "subject": "hedieuhanh", "section": "VIII. BẢO MẬT CHO HỆ THỐNG FILE", "title_path": "VIII. BẢO MẬT CHO HỆ THỐNG FILE", "content": "[hedieuhanh / VIII. BẢO MẬT CHO HỆ THỐNG FILE] Ngăn cản việc truy cập trái phép các thông tin lƣu trữ trong file và thƣ mục Hạn chế các thao tác truy cập tới file hoặc thƣ mục Dùng mật khẩu: Ngƣời dùng phải nhớ nhiều mật khẩu Mỗi khi thao tác với tài nguyên lại gõ mật khẩu", "order_start": 0, "order_end": 226, "word_count": 50}
{"parent_id": "2c9471c4-d792-4916-bf14-8d146149b6c1", "subject": "hedieuhanh", "section": "VIII. BẢO MẬT CHO HỆ THỐNG FILE", "title_path": "VIII. BẢO MẬT CHO HỆ THỐNG FILE", "content": "[hedieuhanh / VIII. BẢO MẬT CHO HỆ THỐNG FILE] Sử dụng danh sách quản lý truy cập ACL (Access Control List) Mỗi file đƣợc gán danh sách đi kèm, chứa thông tin định danh ngƣời dùng và các quyền ngƣời đó đƣợc thực hiện với file ACL thƣờng đƣợc lƣu trữ nhƣ thuộc tính của file/ thƣ mục Thƣờng đƣợc sử dụng cùng với cơ chế đăng nhập Các quyền truy cập cơ bản: Quyền đọc (r) Quyền ghi, thay đổi (w) Quyền xóa Quyền thay đổi chủ file (change owner) 3 phiên bản: FAT12, FAT16, FAT32 Chữ số chỉ kích thƣớc ô bảng FAT tƣơng ứng 12, 16 và 32 bit Đơn vị cấp phát không gian trên đĩa (khối logic) là cluster (lũy thừa 2 của số lƣợng sector)", "order_start": 0, "order_end": 581, "word_count": 122}
{"parent_id": "bc41d816-1f91-4c7e-8b10-95ee017333fe", "subject": "hedieuhanh", "section": "Boot sector:", "title_path": "Boot sector:", "content": "[hedieuhanh / Boot sector:] Sector đầu tiên của đĩa logic Chứa thông tin mô tả cấu trúc đĩa logic: kích thƣớc sector, cluster, kích thƣớc bảng FAT Chứa mã chƣơng trình mồi để tải HĐH nếu đĩa logic là đĩa khởi động FAT: bảng chỉ số quản lý cấp phát khối cho file Thƣ mục gốc ROOT Vùng dữ liệu: chứa các file và thƣ mục của đĩa logic", "order_start": 0, "order_end": 303, "word_count": 65}
{"parent_id": "ea83bcc7-7dd7-4722-acd2-7de03cb6eab5", "subject": "hedieuhanh", "section": "Các byte tiếp theo với FAT32", "title_path": "Các byte tiếp theo với FAT32", "content": "[hedieuhanh / Các byte tiếp theo với FAT32] Quản lý các cluster trên đĩa và các file theo nguyên tắc: Các khối thuộc cùng 1 file đƣợc liên kết thành 1 danh sách Con trỏ đƣợc chứa trong ô tƣơng ứng của bảng FAT Mỗi ô trong bảng FAT tƣơng ứng với một cluster trên đĩa, chứa 1 trong các thông tin: STT cluster tiếp theo trong danh sách các khối của file Dấu hiệu kết thúc nếu ô tƣơng ứng với cluster cuối cùng của file Dấu hiệu đánh dấu cluster hỏng, không đƣợc sử dụng Dấu hiệu đánh dấu cluster dự phòng Bằng 0 nếu cluster trống, chƣa cấp phát cho file nào", "order_start": 0, "order_end": 510, "word_count": 107}
{"parent_id": "739fa8e6-2242-44b0-93c9-672823b1c957", "subject": "hedieuhanh", "section": "Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster", "title_path": "Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster", "content": "[hedieuhanh / Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster] Mỗi thƣ mục đƣợc lƣu trong bảng thƣ mục, thực chất là 1 file đặc biệt chứa các khoản mục của thƣ mục Mỗi khoản mục chứa thông tin về một file hoặc thƣ mục con của thƣ mục đang xét Với FAT12/16, thƣ mục trên cùng của đĩa đƣợc chứa trong 1 vùng đặc biệt gọi là thƣ mục gốc Mỗi thƣ mục gồm các khoản mục 32 byte xếp liền nhau int absread(int drive, int nsects, long lsect, void *buffer) drive: ổ đĩa cần đọc, A: 0, B:1, C:2 nsects: số sector cần đọc lsect: vị trí sector bắt đầu đọc buffer: vùng nhớ lƣu nội dung thông tin cần đọc Vị trí sector bắt đầu: reserved sector (byte 14, 15 trong bootsector) Tổng số sector cần đọc: sectors per FAT (byte 22, 23) Vị trí sector bắt đầu: reserved sector + NoOfFATs * sectors per FAT Tổng số sector cần đọc: NoOfRootEntries * 32 /BytesPerSector 1. Viết chƣơng trình để hiển thị thông tin boot sector 2. Viết chƣơng trình đọc FAT và in nội dung 100 ô fat đầu tiên lên màn hình 3. Viết chƣơng trình đọc ROOT và in nội dung giống lệnh DIR 4. Cho 1 tên file thuộc ROOT. Viết chƣơng trình tìm tất cả các cluster của file đó 5.", "order_start": 0, "order_end": 1057, "word_count": 219}
{"parent_id": "739fa8e6-2242-44b0-93c9-672823b1c957", "subject": "hedieuhanh", "section": "Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster", "title_path": "Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster", "content": "[hedieuhanh / Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster] ng 100 ô fat đầu tiên lên màn hình 3. Viết chƣơng trình đọc ROOT và in nội dung giống lệnh DIR 4. Cho 1 tên file thuộc ROOT. Viết chƣơng trình tìm tất cả các cluster của file đó 5. Viết chƣơng trình đếm số cluster trống trong 100 cluster đầu tiên của ổ đĩa Cho 1 tên file thuộc ROOT. Viết chƣơng trình tìm tất cả các cluster của file đó Đọc Boot sector: lƣu vào bs 2. Đọc ROOT: lƣu trong ROOT 3. Đọc bảng FAT: lƣu trong mảng FAT 4 Giả sử tên file đƣa vào lƣu trong chuỗi tenfile; 5. Kiểm tra xem file “tenfile” có nằm trong thƣ mục gốc??? - duyệt lần lƣợt các khoản mục (i từ 0 tới bs->root_entries) xem có khoản mục nào mà ROOT[i]->filename trùng với “tenfile” nhập vào hay không?? 2. Giả sử ROOT[i]->filename ==“tenfile” => khoản mục i trong thƣ mục gốc quản lý “tenfile” đang xét 3. Cluster đầu tiên lƣu trữ data cho file “tenfile” là ROOT[i]- >first_cluster 6.", "order_start": 1057, "order_end": 1921, "word_count": 174}
{"parent_id": "739fa8e6-2242-44b0-93c9-672823b1c957", "subject": "hedieuhanh", "section": "Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster", "title_path": "Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster", "content": "[hedieuhanh / Cluster đầu tiên của vùng dữ liệu đƣợc đánh STT là 2 2 ô đầu tiên của bảng FAT không dùng để quản lý cluster] . Giả sử ROOT[i]->filename ==“tenfile” => khoản mục i trong thƣ mục gốc quản lý “tenfile” đang xét 3. Cluster đầu tiên lƣu trữ data cho file “tenfile” là ROOT[i]- >first_cluster 6. giả sử ROOT[i]->first_cluster = x; While (x<0xfff8) cout<<x; x= FAT[x]; Viết chƣơng trình đếm số cluster trống của ổ đĩa đọc boot sector absread (2, 1, 0, bs); Đoc FAT absread(2, bs->sector_per_FAT, bs- >reserverd_sector, FAT); Int dem=0; For (int I =2; i<(bs->sector_per_FAT * bs->bytes_per_sector)/2; i++) If (FAT[i]==0) dem++;", "order_start": 1921, "order_end": 2431, "word_count": 80}
{"parent_id": "b5f702b6-9778-4b08-b664-5eeda435c5f1", "subject": "hedieuhanh", "section": "KIỂM TRA", "title_path": "KIỂM TRA", "content": "[hedieuhanh / KIỂM TRA] Hệ thống FAT16 Bài 1: Viết đoạn chƣơng trình đếm số cluster trống trong 100 cluster đầu tiên của ổ đĩa D. Bài 2: Viết đoạn chƣơng trình in nội dung của 50 ô FAT đầu tiên của ổ đĩa C ra màn hình Bài 3: Giả sử bảng FAT đã đƣợc đọc vào bộ nhớ tại địa chỉ << int *fat>> . Giả sử một file đƣợc lƣu trữ trên cluster đầu tiên là n. Viết đoạn chƣơng trình liệt kê các cluster thuộc về file đó. Istruct bootsector { char jump_instruction[3]; char OEM_ID[8]; int bytes_per_sector; char sector_per_cluster; int reserved_sectors; char number_of_fats; int root_entries; int smal]_sectors; char media_descriptor; int sectors_per_fat; int sectors_per_track; int number_of_heads; Jong hidden_sectors; Tong Targe_sectors; char phyšical_drivé_number; char reserved; char extended_boot_signature; char volume_serial_number [4]; char volume_1able[11]; char file_system_type[8]; char bootstrap_code[448]; char end_of_sector_marker [2]; }; bootsector *bs= new bootsector(); absread(2,1, 0, bs);", "order_start": 0, "order_end": 972, "word_count": 145}
{"parent_id": "d1e4d52a-493e-4e57-9b86-62d000c8fea5", "subject": "hedieuhanh", "section": "HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG", "title_path": "HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG", "content": "[hedieuhanh / HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG] BÀI GIẢNG MÔN HỆ ĐIỀU HÀNH Bộ môn: Khoa học máy tính- Khoa CNTT1", "order_start": 0, "order_end": 64, "word_count": 14}
{"parent_id": "c2a49d13-e608-4f21-9aba-f69959919cd8", "subject": "hedieuhanh", "section": "CHƢƠNG 3: QUẢN LÝ BỘ NHỚ", "title_path": "CHƢƠNG 3: QUẢN LÝ BỘ NHỚ", "content": "[hedieuhanh / CHƢƠNG 3: QUẢN LÝ BỘ NHỚ] 1. Địa chỉ và các vấn đề liên quan 2. Một số cách tổ chức chƣơng trình 3. Các yêu cầu quản lý bộ nhớ Phân chƣơng bộ nhớ 5. Phân trang bộ nhớ 6. Phân đoạn bộ nhớ 7. Bộ nhớ ảo", "order_start": 0, "order_end": 173, "word_count": 43}
{"parent_id": "18744385-b59f-418e-8eb5-845bba9567c5", "subject": "hedieuhanh", "section": "Vấn đề gán địa chỉ:", "title_path": "Vấn đề gán địa chỉ:", "content": "[hedieuhanh / Vấn đề gán địa chỉ:] Chƣơng trình máy tính thƣờng không đƣợc viết trực tiếp bởi ngôn ngữ máy, trừ thế hệ máy tính đầu tiên, mà viết trên ngôn ngữ bậc cao hoặc hợp ngữ. Các chƣơng trình phải trải qua một quá trình dịch và liên kết trƣớc khi trở thành chƣơng trình có thể tải vào và thực hiện.", "order_start": 0, "order_end": 270, "word_count": 57}
{"parent_id": "47270157-ff62-4e13-84ae-ccf33d3f86a3", "subject": "hedieuhanh", "section": "Vấn đề gán địa chỉ:", "title_path": "Vấn đề gán địa chỉ:", "content": "[hedieuhanh / Vấn đề gán địa chỉ:] Khi viết chƣơng trình, sử dụng địa chỉ dƣới dạng tên (biến, hàm) Khi dịch, chƣơng trình dịch ánh xạ các tên đó theo địa chỉ tƣơng đối tính từ đầu file obj (biến, hàm) Chƣơng trình liên kết ánh xạ tiếp địa chỉ đó thành địa chỉ tƣơng đối tính từ đầu chƣơng trình HDH đọc chƣơng trình vào bộ nhớ để thực hiện; vị trí trong bộ nhớ không biết trƣớc HDH cần có khả năng gán địa chỉ", "order_start": 0, "order_end": 375, "word_count": 81}
{"parent_id": "9b5007f6-a0e6-4d46-8fa5-c3b4227f618f", "subject": "hedieuhanh", "section": "Địa chỉ logic:", "title_path": "Địa chỉ logic:", "content": "[hedieuhanh / Địa chỉ logic:] Phân biệt với địa chỉ vật lý, CTUD chỉ quan tâm tới địa chỉ địa chỉ logic còn địa chỉ vật lý là do HDH. Gán cho các lệnh và dữ liệu không phụ thuộc vào vị trí cụ thể tiến trình trong bộ nhớ Chƣơng trình ứng dụng chỉ nhìn thấy và làm việc với địa chỉ logic này Là địa chỉ tƣơng đối tức là mỗi phần tử của chƣơng trình đƣợc gán một địa chỉ tƣơng đối đối với một vị trí nào đó", "order_start": 0, "order_end": 373, "word_count": 87}
{"parent_id": "9459fbe2-ccf1-48d4-950c-8474f9616715", "subject": "hedieuhanh", "section": "I. ĐỊA CHỈ VÀ CÁC VẤN ĐỀ LIÊN QUAN", "title_path": "I. ĐỊA CHỈ VÀ CÁC VẤN ĐỀ LIÊN QUAN", "content": "[hedieuhanh / I. ĐỊA CHỈ VÀ CÁC VẤN ĐỀ LIÊN QUAN] Địa chỉ vật lý: Là địa chỉ chính xác trong bộ nhớ máy tính Các mạch nhớ sử dụng để truy nhập tới chƣơng trình và dữ liệu Địa chỉ logic đƣợc chuyển thành địa chỉ vật lý nhờ khối ánh xạ địa chỉ. (MMU=Memory Mapping Unit)", "order_start": 0, "order_end": 218, "word_count": 47}
{"parent_id": "c484de0a-cdcb-4819-9ec9-f50aa93e1d2c", "subject": "hedieuhanh", "section": "II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 1. Tải trong quá trình thực hiện", "title_path": "II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 1. Tải trong quá trình thực hiện", "content": "[hedieuhanh / II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 1. Tải trong quá trình thực hiện] Hàm chƣa bị gọi thì chƣa tải vào bộ nhớ Chƣơng trình chính đƣợc load vào bộ nhớ và chạy Khi có lời gọi hàm: Chƣơng trình sẽ kiểm tra hàm đó đƣợc tải vào chƣa.  Nếu chƣa, chƣơng trình sẽ tiến hành tải sau đó ánh xạ địa chỉ hàm vào không gian chung của chƣơng trình và thay đổi bảng địa chỉ để ghi lại các ánh xạ đó Lập trình viên đảm nhiệm, HDH cung cấp các hàm thƣ viện cho tải động", "order_start": 0, "order_end": 383, "word_count": 87}
{"parent_id": "fc8db87c-7f83-4409-8e28-9513e30f1ff7", "subject": "hedieuhanh", "section": "II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 2. Liên kết động và thƣ viện dùng chung", "title_path": "II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 2. Liên kết động và thƣ viện dùng chung", "content": "[hedieuhanh / II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 2. Liên kết động và thƣ viện dùng chung] Liên kết tĩnh: các hàm và thƣ viện đƣợc liên kết luôn vào mã chƣơng trình Kích thƣớc chƣơng trình khi đó sẽ bằng kích thƣớc chƣơng trình vừa đƣợc dịch + kích thƣớc các hàm thƣ viện => các hàm sẽ có mặt lặp đi lặp lại trong các chƣơng trình => lãng phí không gian cả trên đĩa và bộ nhớ trong Giải quyết: sử dụng kỹ thuật liên kết động. Trong giai đoạn liên kết, không kết nối các hàm thƣ viện vào chƣơng trình mà chỉ chèn các thông tin về hàm thƣ viện đó (stub).", "order_start": 0, "order_end": 461, "word_count": 100}
{"parent_id": "e84e6779-49b2-4027-86c9-9dafca05de6d", "subject": "hedieuhanh", "section": "II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 2. Liên kết động và thƣ viện dùng chung", "title_path": "II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 2. Liên kết động và thƣ viện dùng chung", "content": "[hedieuhanh / II. MỘT SỐ CÁCH TỔ CHỨC CHƢƠNG TRÌNH 2. Liên kết động và thƣ viện dùng chung] Các modul thƣ viện đƣợc liên kết trong quá trình thực hiện: Không giữ bản sao các modul thƣ viện mà tiến trình giữ đoạn mã nhỏ chứa thông tin về modul thƣ viện Khi đoạn mã nhỏ đƣợc gọi, nó kiểm tra modul tƣơng ứng đã có trong bộ nhớ chƣa. Nếu chƣa, thì tải phần còn lại và dùng. Lần tiếp theo cần sử dụng, modul thƣ viện sẽ đƣợc chạy trực tiếp Mỗi modul thƣ viện chỉ có 1 bản sao duy nhất chứa trong MEM Cần hỗ trợ từ HDH", "order_start": 0, "order_end": 421, "word_count": 94}
{"parent_id": "488aa680-353c-4080-81f7-abcedf8dcc4e", "subject": "hedieuhanh", "section": "III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 1. Cấp phát lại", "title_path": "III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 1. Cấp phát lại", "content": "[hedieuhanh / III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 1. Cấp phát lại] Cần có khả năng tráo đổi các tiến trình vào và ra ngoài MEM để tối đa sử dụng vi xử lý Không thể yêu cầu tiến trình đƣợc chuyển lại vào MEM thì phải vào đúng chỗ nó đã dùng trƣớc khi bị chuyển ra", "order_start": 0, "order_end": 195, "word_count": 46}
{"parent_id": "72b6aabe-a624-4d2e-a25d-7248d5dd21ca", "subject": "hedieuhanh", "section": "III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 2. Bảo vệ", "title_path": "III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 2. Bảo vệ", "content": "[hedieuhanh / III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 2. Bảo vệ] Mỗi tiến trình phải đƣợc bảo vệ khỏi các tham chiếu không mong muốn từ các tiến trình khác vào vùng nhớ dành cho mình Mọi tham chiếu bộ nhớ của 1 tiến trình phải đƣợc kiểm tra lúc chạy Khi 1 vùng nhớ đã dùng cho tiến trình này thì nó không cho phép tiến trình khác tham chiếu vào vùng nhớ đang dùng đó. HDH không đoán trƣớc đƣợc mọi tham chiếu MEM => phần cứng VXL đảm nhiệm", "order_start": 0, "order_end": 374, "word_count": 81}
{"parent_id": "e676096d-ffac-4ea9-b3e3-676ca57cf7ec", "subject": "hedieuhanh", "section": "III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 3. Chia sẻ", "title_path": "III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 3. Chia sẻ", "content": "[hedieuhanh / III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 3. Chia sẻ] Nhiều tiến trình cần và đƣợc phép truy cập vào cùng 1 vùng nhớ Các tiến trình đang cộng tác cần chia sẻ truy nhập tới 1 cấu trúc dữ liệu => Phải cho phép truy cập tới các vùng chia sẻ III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 4. Cấu trúc logic & cấu trúc vật lý Cấu trúc logic: MEM đƣợc cấu trúc 1 cách tuyến tính gồm các byte, còn chƣơng trình đƣợc tổ chức thành các modul Phải đáp ứng để: Các modul có thể đƣợc viết và thông dịch 1 cách độc lập Mức độ bảo vệ có thể khác nhau Modul có thể đƣợc chia sẻ giữa các tiến trình III. CÁC YÊU CẦU QUẢN LÝ BỘ NHỚ 4. Cấu trúc logic & cấu trúc vật lý Cấu trúc vật lý: 2 mức: Bộ nhớ chính: nhanh; chi phí cao, dung lƣợng ít Bộ nhớ phụ: dung lƣợng lớn, cho phép lƣu chƣơng trình và dữ liệu trong thời gian dài Hệ thống có trách nhiệm chuyển đổi thông tin giữa 2 mức", "order_start": 0, "order_end": 794, "word_count": 180}
{"parent_id": "7026a746-a228-4850-9966-d73d15779356", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ] Để thực hiện tiến trình, HDH cần cấp phát cho tiến trình không gian nhớ cần thiết. Việc cấp phát và quản lý vùng nhớ là chức năng quan trọng của HDH. Một kỹ thuật cấp phát đơn giản nhất => mỗi tiến trình đƣợc cấp một vùng bộ nhớ liên tục HDH tiến hành chia bộ nhớ thành các phần liên tục là chƣơng (partition), mỗi tiến trình sẽ đƣợc cung cấp một chƣơng để chứa lệnh và dữ liệu của mình. Quá trình phân chia bộ nhớ thành chƣơng nhƣ vậy gọi là phân chƣơng bộ nhớ. Tùy thuộc việc lựa chọn vị trí và kích thƣớc của chƣơng, có thể phân biệt phân chƣơng cố định và phân chƣơng động", "order_start": 0, "order_end": 576, "word_count": 123}
{"parent_id": "93222a96-ca0d-4858-a5ac-0a47ffd574f0", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định] Chia MEM thành các chƣơng với kích thƣớc cố định ở những vị trí cố định Mỗi chƣơng chứa đƣợc đúng một tiến trình => số tiến trình tối đa có thể chứa đồng thời bị giới hạn bởi số lƣợng chƣơng. Khi đƣợc tải vào, tiến trình đƣợc cấp phát một chƣơng. Sau khi tiến trình kết thúc, HDH giải phóng chƣơng và chƣơng có thể đƣợc cấp phát cho tiến trình mới. Kích thƣớc các chƣơng bằng nhau: Đơn giản Kích thƣớc chƣơng trình > kích thƣớc chƣơng => không thể cấp phát Gây phân mảnh trong Kích thƣớc các chƣơng khác nhau: Có hai cách lựa chọn chƣơng nhớ để cấp cho tiến trình đang chờ đợi Chọn chƣơng có kích thƣớc nhỏ nhất: cần có hàng đợi lệnh cho mỗi chƣơng.  Mỗi chƣơng có một hàng đợi riêng, tiến trình có kích thƣớc phù hợp với chƣơng nào sẽ nằm trong hàng đợi của chƣơng đó Giảm phân mảnh trong, tối ƣu cho từng chƣơng => tiết kiệm bộ nhớ.", "order_start": 0, "order_end": 835, "word_count": 175}
{"parent_id": "93222a96-ca0d-4858-a5ac-0a47ffd574f0", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định] chƣơng có một hàng đợi riêng, tiến trình có kích thƣớc phù hợp với chƣơng nào sẽ nằm trong hàng đợi của chƣơng đó Giảm phân mảnh trong, tối ƣu cho từng chƣơng => tiết kiệm bộ nhớ.  Do mỗi chƣơng có một hàng đợi riêng nên có thời điểm hàng đợi của chƣơng lớn hơn thì rỗng, trong khi hàng đợi của chƣơng nhỏ hơn thì không chứa tiến trình nào => Hệ thống không tối ƣu", "order_start": 835, "order_end": 1200, "word_count": 79}
{"parent_id": "5b39dffa-9482-4c24-84fb-570ac2751dba", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định] Kích thƣớc các chƣơng khác nhau: Dùng hàng đợi chung cho tất cả các chƣơng: Mỗi khi có một chƣơng trống, tiến trình nằm gần đầu hàng đợi nhất và có kích thƣớc phù hợp với chƣơng nhất sẽ đƣợc tải và thực hiện Khi 1 chƣơng đƣợc 2 • ■ giải phóng: chọn tiến trình gần đầu hàng đợi nhất và có kích thƣớc phù hợp nhất", "order_start": 0, "order_end": 311, "word_count": 68}
{"parent_id": "ae0e7bf0-cfc6-44ba-9589-6b5bc2978c59", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 1. Phân chƣơng cố định] Ƣu điểm: đơn giản, ít xử lý Nhƣợc điểm: Số lƣợng chƣơng xác định tại thời điểm tạo hệ thống hạn chế số lƣợng tiến trình hoạt động Kích thƣớc chƣơng thiết lập trƣớc: không hiệu quả Kích thƣớc, số lƣợng và vị trí chƣơng đều có thể thay đổi Khi có yêu cầu, HDH cấp cho tiến trình 1 chƣơng có kích thƣớc đúng bằng tiến trình đó đang cần. Khi tiến trình kết thúc sẽ tạo vùng trống trong MEM Các vùng trống nằm cạnh nhau đƣợc nhập lại thành vùng lớn hơn. Các vùng trống bộ nhớ cũng có thể đƣợc liên kết thành một danh sách kết nối", "order_start": 0, "order_end": 524, "word_count": 112}
{"parent_id": "91d846eb-1e02-4570-ba36-56bc56acb988", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 2. Phân chƣơng động", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 2. Phân chƣơng động", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 2. Phân chƣơng động] Tránh phân mảnh trong Gây phân mảnh ngoài: dồn những vùng trống nhỏ thành lớn (nén) Sử dụng các chiến lƣợc cấp chƣơng Chọn vùng thích hợp đầu tiên (first – fit) Vùng thích hợp nhất (best fit) Vùng không thích hợp nhất (worst fit) 250k, 180k, 500k IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 3. Phƣơng pháp kề cận (buddy system) Các chƣơng và khối trống có kích thƣớc là lũy thừa của 2k (L≤k≤H): 2L: kích thƣớc nhỏ nhất của chƣơng; 2H : kích thƣớc MEM Đầu tiên, toàn bộ không gian nhớ là 2H , yêu cầu cấp vùng nhớ S 2H-1 <S≤ 2H : cấp cả 2H Chia đôi thành 2 vùng 2H-1 : Nếu 2H-2 <S≤ 2H-1 : cấp 2H-1 Tiếp tục chia đôi tới khi tìm đƣợc vùng thỏa mãn 2k-1<S≤ 2k", "order_start": 0, "order_end": 644, "word_count": 138}
{"parent_id": "79479578-866e-4f4e-bce3-ede0b38d4b28", "subject": "hedieuhanh", "section": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 3. Phƣơng pháp kề cận", "title_path": "IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 3. Phƣơng pháp kề cận", "content": "[hedieuhanh / IV. KỸ THUẬT PHÂN CHƢƠNG BỘ NHỚ 3. Phƣơng pháp kề cận] Sau một thời gian xuất hiện các khối trống có kích thƣớc 2k Tạo danh sách móc nối các vùng có cùng kích thƣớc Nếu có 2 khối trống cùng kích thƣớc và kề nhau thì ghép lại thành 1 Khi cần cấp, sẽ tìm trong danh sách khối phù hợp nhất; nếu không tìm khối lớn hơn và cắt đôi", "order_start": 0, "order_end": 270, "word_count": 61}
{"parent_id": "9366a946-20e3-4659-b560-e86e4395405c", "subject": "hedieuhanh", "section": "1 Hole", "title_path": "1 Hole", "content": "[hedieuhanh / 1 Hole] IV. PHÂN CHƢƠNG BỘ NHỚ 4. Ánh xạ địa chỉ và chống truy cập trái phép Vị trí các chƣơng thƣờng không biết trƣớc và có thể thay đổi => cần có cơ chế biến đổi địa chỉ logic thành vật lý Cấm truy cập trái phép: tiến trình này truy cập tới phần MEM của tiến trình khác Ánh xạ địa chỉ do phần cứng đảm nhiệm", "order_start": 0, "order_end": 301, "word_count": 68}
{"parent_id": "3d6b019d-6726-4cc7-b00f-5215b635503e", "subject": "hedieuhanh", "section": "IV. PHÂN CHƢƠNG BỘ NHỚ 4. Ánh xạ địa chỉ và chống truy cập trái phép", "title_path": "IV. PHÂN CHƢƠNG BỘ NHỚ 4. Ánh xạ địa chỉ và chống truy cập trái phép", "content": "[hedieuhanh / IV. PHÂN CHƢƠNG BỘ NHỚ 4. Ánh xạ địa chỉ và chống truy cập trái phép] Khi tiến trình đƣợc tải vào MEM, CPU dành 2 thanh ghi: Thanh ghi cơ sở: chứa địa chỉ bắt đầu của tiến trình Thanh ghi giới hạn: chứa độ dài chƣơng Địa chỉ logic đƣợc so sánh với nội dung của thanh ghi giới hạn Nếu lớn hơn: lỗi truy cập Nhỏ hơn: đƣợc đƣa tới bộ cộng với thanh ghi cơ sở để thành địa chỉ vật lý Nếu chƣơng bị di chuyển thì nội dung của thanh ghi cơ sở bị thay đổi chứa địa chỉ vị trí mới IV. PHÂN CHƢƠNG BỘ NHỚ 5. Trao đổi giữa bộ nhớ và đĩa (swapping) Các tiến trình đang thực hiện có thể bị tạm thời tải ra đĩa nhƣờng chỗ để tải các tiến trình khác vào Sau đó lại đƣợc tải vào (nếu chƣa kết thúc) để thực hiện tiếp Xảy ra khi: Một tiến trình đã hết khoảng thời gian sử dụng CPU của mình Nhƣờng chỗ cho một tiến trình khác có thứ tự ƣu tiên cao hơn", "order_start": 0, "order_end": 764, "word_count": 173}
{"parent_id": "9f8d31a2-8f65-4b4b-9bac-e616ca9bae69", "subject": "hedieuhanh", "section": "IV. PHÂN CHƢƠNG BỘ NHỚ 5. Trao đổi giữa bộ nhớ và đĩa (swapping)", "title_path": "IV. PHÂN CHƢƠNG BỘ NHỚ 5. Trao đổi giữa bộ nhớ và đĩa (swapping)", "content": "[hedieuhanh / IV. PHÂN CHƢƠNG BỘ NHỚ 5. Trao đổi giữa bộ nhớ và đĩa (swapping)] Thời gian tải phụ thuộc vào tốc độ truy cập đĩa, tốc độ truy cập bộ nhớ và kích thƣớc tiến trình Khi đƣợc tải vào lại, tiến trình có thể đƣợc chứa vào chƣơng ở vị trí cũ hoặc đƣợc cấp cho một chƣơng địa chỉ hoàn toàn mới Các tiến trình bị trao đổi phải ở trạng thái nghỉ, đặc biệt không thực hiện các thao tác vào ra", "order_start": 0, "order_end": 316, "word_count": 71}
{"parent_id": "bad6cbf5-0496-4b0f-8dd8-96f5c43a9f01", "subject": "hedieuhanh", "section": "V. PHÂN TRANG BỘ NHỚ", "title_path": "V. PHÂN TRANG BỘ NHỚ", "content": "[hedieuhanh / V. PHÂN TRANG BỘ NHỚ] 1. Khái niệm phân trang Bộ nhớ vật lý đƣợc chia thành các khối nhỏ, kích thƣớc cố định và bằng nhau gọi là khung trang (page frame) Không gian địa chỉ logic của tiến trình đƣợc chia thành những khối gọi là trang (page), có kích thƣớc bằng khung Không gian nhó lô gic cúa các tién trình A và C: 4 trang B: 3 trang; D: 5 trang", "order_start": 0, "order_end": 324, "word_count": 70}
{"parent_id": "f0f278a3-5f9e-4301-bbbd-7a6f5e4d963b", "subject": "hedieuhanh", "section": "BỘ MÔN: KHOA HỌC MÁY TÍNH – KHOA CNTT1", "title_path": "BỘ MÔN: KHOA HỌC MÁY TÍNH – KHOA CNTT1", "content": "[hedieuhanh / BỘ MÔN: KHOA HỌC MÁY TÍNH – KHOA CNTT1] Tiến trình đƣợc cấp các khung để chứa các trang của mình. Các trang có thể chứa trong các khung nằm rải rác trong bộ nhớ", "order_start": 0, "order_end": 120, "word_count": 26}
{"parent_id": "4e5b83ff-371a-412c-824f-8e7230130a55", "subject": "hedieuhanh", "section": "Untitled", "title_path": "Untitled", "content": "[hedieuhanh / Untitled] HDH quản lý việc cấp phát khung cho mỗi tiến trình bằng bảng trang (bảng phân trang): mỗi ô tƣơng ứng với 1 trang và chứa số khung cấp cho trang đó Mỗi tiến trình có bảng trang riêng Duy trì danh sách các khung trống trong MEM Tƣơng tự nhƣ phân chƣơng cố định: khung tƣơng tự chƣơng, kích thƣớc và vị trí không thay đổi Tuy nhiên kích thƣớc các phần tƣơng đối nhỏ và các phần cho 1 tiến trình không cần liên tục nhau Không có phân mảnh ngoài Có phân mảnh trong V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ Để tính toán địa chỉ hiệu quả, kích thƣớc khung đƣợc chọn là lũy thừa của 2 Địa chỉ logic gồm 2 phần: Số thứ tự trang (p) Độ dịch (địa chỉ lệch) của địa chỉ so với đầu trang (o) Nếu kích thƣớc trang là 2n.", "order_start": 0, "order_end": 705, "word_count": 154}
{"parent_id": "4e5b83ff-371a-412c-824f-8e7230130a55", "subject": "hedieuhanh", "section": "Untitled", "title_path": "Untitled", "content": "[hedieuhanh / Untitled] quả, kích thƣớc khung đƣợc chọn là lũy thừa của 2 Địa chỉ logic gồm 2 phần: Số thứ tự trang (p) Độ dịch (địa chỉ lệch) của địa chỉ so với đầu trang (o) Nếu kích thƣớc trang là 2n. Biểu diễn địa chỉ logic dƣới dạng địa chỉ có độ dài (m + n) bit m bit cao: biểu diễn số thứ tự trang n bit thấp: biểu diễn độ dịch trong trang nhớ Quá trình chuyển địa chỉ logic sang địa chỉ vật lý: Lấy m bit cao của địa chỉ => đƣợc số thứ tự trang Dựa vào bảng trang, tìm đƣợc số thứ tự khung vật lý (k) Địa chỉ vật lý bắt đầu của khung là k*2n Địa chỉ vật lý của byte đƣợc tham chiếu là địa chỉ bắt đầu của khung cộng với địa chỉ lệch (độ dịch) => Chỉ cần thêm số khung vào trƣớc dãy bit biểu diễn độ lệch", "order_start": 705, "order_end": 1392, "word_count": 160}
{"parent_id": "c8052d2b-4500-4941-8bf5-61706fe59afa", "subject": "hedieuhanh", "section": "V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ", "title_path": "V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ", "content": "[hedieuhanh / V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ] Kích thƣớc khung là 1KB => Sử dụng 10 bit để biểu diễn địa chỉ lệch (n=10) Địa chỉ logic 1502 ↔ byte 478 trong trang 1", "order_start": 0, "order_end": 118, "word_count": 27}
{"parent_id": "203d91d0-fe08-49bf-b91b-2d3cc8a1996d", "subject": "hedieuhanh", "section": "V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ", "title_path": "V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ", "content": "[hedieuhanh / V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ] Quá trình biến đổi từ địa chỉ logic sang địa chỉ vật lý đƣợc thực hiện bằng phần cứng Kích thƣớc trang là lũy thừa của 2, nằm trong khoảng từ 512B đến 16MB Việc tách phần p và o trong địa chỉ logic đƣợc thực hiện dễ dàng bằng phép dịch bit Phân mảnh trong khi phân trang có giá trị trung bình bằng nửa trang => giảm kích thƣớc trang cho phép tiết kiệm MEM Kích thƣớc trang nhỏ => số lƣợng trang tăng => bảng trang to, khó quản lý Kích thƣớc trang nhỏ: không tiện cho việc trao đổi với đĩa Windows 32bit: kích thƣớc trang 4KB Cơ chế ánh xạ giữa hai loại địa chỉ hoàn toàn trong suốt đối với chƣơng trình V. PHÂN TRANG BỘ NHỚ 3. Tổ chức bảng trang Mỗi thao tác truy cập bộ nhớ đều đòi hỏi truy cập bảng phân trang => tổ chức bảng phân trang sao cho tốc độ truy cập là cao nhất Sử dụng tập hợp các thanh ghi làm bảng phân trang: Tốc độ truy cập rất cao Số lƣợng thanh ghi hạn chế => không áp dụng đƣợc Giữ các bảng trang trong MEM: Vị trí mỗi bảng đƣợc trỏ bởi thanh ghi cơ sở bảng trang PTBR (Page Table Base Register) Nhiều thời gian để truy cập bảng => sử dụng bộ nhớ cache tốc độ cao V.", "order_start": 0, "order_end": 1087, "word_count": 237}
{"parent_id": "203d91d0-fe08-49bf-b91b-2d3cc8a1996d", "subject": "hedieuhanh", "section": "V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ", "title_path": "V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ", "content": "[hedieuhanh / V. PHÂN TRANG BỘ NHỚ 2. Ánh xạ địa chỉ] bảng trang trong MEM: Vị trí mỗi bảng đƣợc trỏ bởi thanh ghi cơ sở bảng trang PTBR (Page Table Base Register) Nhiều thời gian để truy cập bảng => sử dụng bộ nhớ cache tốc độ cao V. PHÂN TRANG BỘ NHỚ 3. Tổ chức bảng trang- bảng trang nhiều mức", "order_start": 1087, "order_end": 1329, "word_count": 52}
{"parent_id": "61da818e-03e2-4589-a768-ad7ef2abcadd", "subject": "hedieuhanh", "section": "Untitled", "title_path": "Untitled", "content": "[hedieuhanh / Untitled] Không gian địa chỉ logic lớn (232 -> 264) => kích thƣớc bảng trang tăng => cần chia bảng trang thành những phần nhỏ hơn Tổ chức bảng trang nhiều mức: Khoản mục của bảng mức trên chỉ tới bảng trang khác V. PHÂN TRANG BỘ NHỚ 3. Tổ chức bảng trang- bảng trang nhiều mức Ví dụ bảng 2 mức: địa chỉ 32 bit chia thành 3 phần P1: 10 bit cho phép định vị khoản mục trong bảng mức trên => tìm đƣợc bảng mức dƣới tƣơng ứng P2: định vị khoản mục trong bảng mức dƣới (chứa địa chỉ khung tƣơng ứng) O: 12 bit, chứa độ dịch trong trang Chƣơng trình thƣờng đƣợc chia thành nhiều phần: dữ liệu, lệnh, ngăn xếp Chia chƣơng trình thành các đoạn theo cấu trúc logic Mỗi đoạn đƣợc phân vào 1 vùng nhớ, có kích thƣớc không bằng nhau Mỗi đoạn tƣơng ứng với không gian địa chỉ riêng, đƣợc phân biệt bởi tên (STT) và độ dài của mình Các vùng nhớ thuộc các đoạn khác nhau có thể nằm ở vị trí khác nhau Giống phân chƣơng động: bộ nhớ đƣợc cấp phát theo từng vùng kích thƣớc thay đổi Khác phân chƣơng động: chƣơng trình có thể chiếm nhiều hơn 1 đoạn và không cần liên tiếp nhau trong MEM Tránh hiện tƣợng phân mảnh trong Có phân", "order_start": 0, "order_end": 1100, "word_count": 232}
{"parent_id": "61da818e-03e2-4589-a768-ad7ef2abcadd", "subject": "hedieuhanh", "section": "Untitled", "title_path": "Untitled", "content": "[hedieuhanh / Untitled] theo từng vùng kích thƣớc thay đổi Khác phân chƣơng động: chƣơng trình có thể chiếm nhiều hơn 1 đoạn và không cần liên tiếp nhau trong MEM Tránh hiện tƣợng phân mảnh trong Có phân mảnh ngoài Dễ sắp xếp bộ nhớ Dễ chia sẻ các đoạn giữa các tiến trình khác nhau Kích thƣớc mỗi đoạn có thể thay đổi mà không ảnh hƣởng tới các đoạn khác Sử dụng bảng đoạn cho mỗi tiến trình. Mỗi ô tƣơng ứng với 1 đoạn, chứa: Địa chỉ cơ sở: vị trí bắt đầu của đoạn trong bộ nhớ Địa chỉ giới hạn: độ dài đoạn, sử dụng để chống truy cập trái phép ra ngoài đoạn Địa chỉ logic gồm 2 thành phần, (s, o): S: số thứ tự/ tên đoạn O: độ dịch trong đoạn", "order_start": 1100, "order_end": 1721, "word_count": 137}
{"parent_id": "bf519471-518a-48ac-8c8a-f0093e65d271", "subject": "hedieuhanh", "section": "VI. PHÂN ĐOẠN BỘ NHỚ 2. Ánh xạ địa chỉ", "title_path": "VI. PHÂN ĐOẠN BỘ NHỚ 2. Ánh xạ địa chỉ", "content": "[hedieuhanh / VI. PHÂN ĐOẠN BỘ NHỚ 2. Ánh xạ địa chỉ] Từ chỉ số đoạn s, vào bảng đoạn, tìm địa chỉ vật lý bắt đầu của đoạn So sánh độ dịch o với chiều dài đoạn, nếu lớn hơn => địa chỉ sai Địa chỉ vật lý mong muốn là tổng của địa chỉ vật lý bắt đầu đoạn và địa chỉ lệch", "order_start": 0, "order_end": 214, "word_count": 53}
{"parent_id": "57e33c36-8cd3-4d6c-be83-6d4dd8aea373", "subject": "hedieuhanh", "section": "VI. PHÂN ĐOẠN BỘ NHỚ", "title_path": "VI. PHÂN ĐOẠN BỘ NHỚ", "content": "[hedieuhanh / VI. PHÂN ĐOẠN BỘ NHỚ] 3. Kết hợp phân trang và Phân đoạn Phân đoạn chƣơng trình, mỗi đoạn sẽ tiến hành phân trang Địa chỉ gồm: số thứ tự đoạn, số thự tự trang, độ dịch trong trang Tiến trình có 1 bảng phân đoạn, mỗi đoạn có 1 bảng phân trang Tiến trình có thể chia thành các phần nhỏ nằm rải rác trong bộ nhớ Tất cả các phép biến đổi là trong suốt với ngƣời dùng và ngƣời lập trình chỉ làm việc với không gian nhớ logic Không phải tiến trình nào khi chạy cũng sử dụng tất cả các lệnh và dữ liệu của mình với tần số nhƣ nhau => không nhất thiết toàn bộ các trang/ đoạn của một tiến trình phải có mặt đồng thời trong bộ nhớ khi tiến trình chạy => Các trang hoặc đoạn có thể đƣợc trao đổi từ đĩa vào bộ nhớ khi có nhu cầu truy cập tới", "order_start": 0, "order_end": 709, "word_count": 158}
{"parent_id": "39153f98-9e96-4190-851d-528886126ff2", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 1. Khái niệm Việc thực hiện các tiến trình chỉ nằm một phần trong bộ nhớ có một số ƣu điểm: Có thể viết chƣơng trình có kích thƣớc lớn hơn kích thƣớc thực của MEM Cùng 1 lúc nhiều tiến trình cùng đƣợc tải vào MEM hơn => Bộ nhớ ảo là bộ nhớ lôgic theo cách nhìn của ngƣời lập trình và tiến trình và không bị hạn chế bởi bộ nhớ thực. Bộ nhớ ảo có thể lớn hơn bộ nhớ thực rất nhiều và bao gồm cả không gian trên đĩa Bộ nhớ ảo thƣờng đƣợc xây dựng dựa trên phƣơng pháp phân trang trong đó các trang là đơn vị để nạp từ đĩa vào khi cần", "order_start": 0, "order_end": 530, "word_count": 122}
{"parent_id": "9e28f49c-9669-4cd1-b652-1788259e8873", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 2. Nạp trang theo nhu cầu Tiến trình đƣợc phân trang và chứa trên đĩa Khi cần thực hiện, nạp tiến trình vào MEM: chỉ nạp những trang cần dùng Tiến trình gồm các trang trên đĩa và trong MEM: thêm bit P trong khoản mục bảng trang để phân biệt (P=1: đã nạp vào MEM)", "order_start": 0, "order_end": 262, "word_count": 56}
{"parent_id": "b62526e8-efaa-4503-a66e-0a3848855f89", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 2. Nạp trang theo nhu cầu Quá trình kiểm tra và nạp trang: Tiến trình truy cập tới 1 trang, kiểm tra bit P. Nếu P=1, truy cập diễn ra bình thƣờng. Nếu P=0, xảy ra sự kiện thiếu trang Ngắt xử lý thiếu trang: • HDH tìm 1 khung trống trong MEM Đọc trang bị thiếu vào khung trang vừa tìm đƣợc Sửa lại khoản mục tƣơng ứng trong bảng trang: đổi bit P=1 và số khung đã cấp cho trang Khôi phục lại trạng thái tiến trình và thực hiện tiếp lệnh bị ngắt", "order_start": 0, "order_end": 442, "word_count": 96}
{"parent_id": "48759cc0-e0ce-4d31-a57d-cbe9750c1395", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 2. Nạp trang theo nhu cầu Nạp trang hoàn toàn theo nhu cầu: Bắt đầu một tiến trình mà không nạp bất kỳ trang nào vào bộ nhớ Khi con trỏ lệnh đƣợc HDH chuyển tới lệnh đầu tiên của tiến trình để thực hiện, sự kiện thiếu trang sẽ sinh ra và trang tƣơng ứng đƣợc nạp vào Tiến trình sau đó thực hiện bình thƣờng cho tới lần thiếu trang tiếp theo Nạp trang trƣớc: khác với nạp trang theo nhu cầu Các trang chƣa cần đến cũng đƣợc nạp vào bộ nhớ Không hiệu quả Bộ nhớ ảo > bộ nhớ thực và chế độ đa chƣơng trình -> có lúc không còn khung nào trống để nạp trang mới Giải pháp: Kết thúc tiến trình Trao đổi tiến trình ra đĩa và chờ thời điểm thuận lợi hơn Đổi trang", "order_start": 0, "order_end": 654, "word_count": 144}
{"parent_id": "15c188b1-f26f-4e56-b456-12e8b513f887", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 3.1. Thao tác đổi trang Nếu không còn khung nào trống, HDH chọn 1 khung đã cấp phát nhƣng hiện không dùng tới và giải phóng nó Quá trình đổi trang: B1: Xác định trang trên đia cần nạp vào MEM B2: Nếu có khung trống trên MEM thì chuyển sang B4", "order_start": 0, "order_end": 242, "word_count": 52}
{"parent_id": "a52ab7c1-0235-4f72-b601-831682746363", "subject": "hedieuhanh", "section": "B3:", "title_path": "B3:", "content": "[hedieuhanh / B3:] Lựa chọn 1 khung trên MEM để giải phóng, theo 1 thuật toán nào đó Ghi nội dung khung bị đổi ra đĩa (nếu cần), cập nhật bảng trang và bảng khung B4: Đọc trang cần nạp vào khung vừa giải phóng; cập nhật bảng trang và bảng khung B5: Thực hiện tiếp tiến trình từ điểm bị dừng trƣớc khi đổi trang", "order_start": 0, "order_end": 291, "word_count": 63}
{"parent_id": "7eb17812-3cfb-4a17-965a-ca6729ecb39d", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 3.1. Thao tác đổi trang Đổi trang có ghi và đổi trang không ghi: Việc ghi trang bị đổi ra đĩa làm tăng đáng kể thời gian nạp trang => nhận biết các trang không thay đổi từ lúc nạp và không ghi ngƣợc ra đĩa Sử dụng thêm bit sửa đổi M trong khoản mục trang để đánh dấu trang đã bị sửa đổi (1) hay chƣa (0) Các khung bị khóa Một số khung sẽ không bị giải phóng trong quá trình tìm kiếm khung để đổi trang => các khung bị khóa VD: Khung chứa tiến trình nhân của HDH, chứa các cấu trúc thông tin điều khiển quan trọng Nhận biết bởi 1 bit riêng chứa trong khoản mục", "order_start": 0, "order_end": 559, "word_count": 123}
{"parent_id": "fd276920-4076-4602-8951-1114424b0e20", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 3.2 Các chiến lƣợc đổi trang Đổi trang tối ƣu (OPT): Chọn trang sẽ không đƣợc dùng tới trong khoảng thời gian lâu nhất để đổi Cho phép giảm tối thiểu sự kiện thiếu trang và do đó là tối ƣu theo tiêu chuẩn này HDH không đoán trƣớc đƣợc nhu cầu sử dụng các trang trong tƣơng lai => không áp dụng trong thực tế mà chỉ để so sánh với các chiến lƣợc khác Vào trƣớc ra trƣớc (FIFO): Trang nào đƣợc nạp vào trƣớc thì bị đổi ra trƣớc Đơn giản nhất Trang bị trao đổi là trang nằm lâu nhất trong bộ nhớ", "order_start": 0, "order_end": 492, "word_count": 107}
{"parent_id": "ffa9c8ff-d6f8-469d-8bcb-6c61c6e033fd", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 3.2 Các chiến lƣợc đổi trang Đổi trang ít sử dụng nhất trong thời gian cuối (LRU): Trang bị đổi là trang mà thời gian từ lần truy cập cuối cùng đến thời điểm hiện tại là lâu nhất Theo nguyên tắc cục bộ về thời gian, đó chính là trang ít có khả năng sử dụng tới nhất trong tƣơng lai Thực tế LRU cho kết quả tốt gần nhƣ phƣơng pháp đổi trang tối ƣu Đổi trang ít sử dụng nhất trong thời gian cuối (LRU): Xác định đƣợc trang có lần truy cập cuối diễn ra cách thời điểm hiện tại lâu nhất? Sử dụng biến đếm: Mỗi khoản mục của bảng phân trang sẽ có thêm một trƣờng chứa thời gian truy cập trang lần cuối - Là thời gian logic CPU cũng đƣợc thêm một bộ đếm thời gian lôgic này Chỉ số của bộ đếm tăng mỗi khi xảy ra truy cập bộ nhớ Mỗi khi một trang nhớ đƣợc truy cập, chỉ số của bộ đếm sẽ đƣợc ghi vào trƣờng thời gian truy cập trong khoản mục của trang đó > trƣờng thời gian luôn chứa thời gian truy cập trang lần cuối => trang bị đổi là trang có giá trị thời gian nhỏ nhất Đổi trang ít sử dụng nhất trong thời gian cuối (LRU): Sử dụng ngăn xếp: Ngăn xếp đặc biệt đƣợc sử dụng để chứa các số trang Mỗi khi mộ", "order_start": 0, "order_end": 1100, "word_count": 244}
{"parent_id": "ffa9c8ff-d6f8-469d-8bcb-6c61c6e033fd", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] bị đổi là trang có giá trị thời gian nhỏ nhất Đổi trang ít sử dụng nhất trong thời gian cuối (LRU): Sử dụng ngăn xếp: Ngăn xếp đặc biệt đƣợc sử dụng để chứa các số trang Mỗi khi một trang nhớ đƣợc truy cập, số trang sẽ đƣợc chuyển lên đỉnh ngăn xếp Đỉnh ngăn xếp sẽ chứa trang đƣợc truy cập gần đây nhất Đáy ngăn xếp chính là trang LRU, tức là trang cần trao đổi Tránh tìm kiếm trong bảng phân trang Thích hợp thực hiện bằng phần mềm Thuật toán đồng hồ (CLOCK): Cải tiến FIFO nhằm tránh thay những trang mặc dù đã đƣợc nạp vào lâu nhƣng vẫn có khả năng sử dụng Mỗi trang đƣợc gắn thêm 1 bit sử dụng U Khi trang đƣợc truy cập đọc/ ghi: U = 1 => ngay khi trang đƣợc đọc vào bộ nhớ: U =1 Các khung có thể bị đổi (các trang tƣơng ứng) đƣợc liên kết vào 1 danh sách vòng Khi một trang nào đó bị đổi, con trỏ đƣợc dịch chuyển để trỏ vào trang tiếp theo trong danh sách", "order_start": 1100, "order_end": 1962, "word_count": 191}
{"parent_id": "b124eea4-8389-4c12-b022-f9667d5ce859", "subject": "hedieuhanh", "section": "Thuật toán đồng hồ (CLOCK):", "title_path": "Thuật toán đồng hồ (CLOCK):", "content": "[hedieuhanh / Thuật toán đồng hồ (CLOCK):] Khi có nhu cầu đổi trang, HDH kiểm tra trang đang bị trỏ tới Nếu U=0: trang sẽ bị đổi ngay Nếu U=1: đặt U=0 và trỏ sang trang tiếp theo, lặp lại quá trình Nếu U của tất cả các trang trong danh sách =1 thì con trỏ sẽ quay đúng 1 vòng, đặt U của tất cả các trang =0 và trang hiện thời đang bị trỏ sẽ bị đổi", "order_start": 0, "order_end": 304, "word_count": 72}
{"parent_id": "7339a86a-9803-4050-914d-cb28d15c6055", "subject": "hedieuhanh", "section": "Thuật toán đồng hồ (CLOCK):", "title_path": "Thuật toán đồng hồ (CLOCK):", "content": "[hedieuhanh / Thuật toán đồng hồ (CLOCK):] Căn cứ vào 2 thông tin để đƣa ra quyết định đổi trang: Thời gian trang đƣợc tải vào, thể hiện qua vị trí trang trong danh sách giống nhƣ FIFO Gần đây trang có đƣợc sử dụng hay không, thể hiện qua bit U Việc kiểm tra thêm bit U tƣơng tự việc cho trang thêm khả năng đƣợc giữ trong bộ nhớ => thuật toán cơ hội thứ 2", "order_start": 0, "order_end": 313, "word_count": 71}
{"parent_id": "a498aee6-5b2e-4cbf-8d34-2035562e3a65", "subject": "hedieuhanh", "section": "Thuật toán đồng hồ cải tiến:", "title_path": "Thuật toán đồng hồ cải tiến:", "content": "[hedieuhanh / Thuật toán đồng hồ cải tiến:] Sử dụng thêm thông tin về việc nội dung trang có bị thay đổi hay không bằng bit M Kết hợp bit U và M, có 4 khả năng: U=0, M=0: trang gần đây không đƣợc truy cập và nội dung cũng không bị thay đổi, rất thích hợp để bị đổi ra ngoài U=0, M=1: trang có nội dung thay đổi nhƣng gần đây không đƣợc truy cập, cũng là ứng viên để đổi ra ngoài U=1, M=0: trang mới đƣợc truy cập gần đây và do vậy theo nguyên lý cục bộ về thời gian có thể sắp đƣợc truy cập tiếp U=1, M=1: trang có nội dung bị thay đổi và mới đƣợc truy cập gần đây, chƣa thật thích hợp để đổi Thuật toán đồng hồ cải tiến: Các bƣớc thực hiện đổi trang: Bƣớc 1: Bắt đầu từ vị trí hiện tại của con trỏ, kiểm tra các trang Trang đầu tiên có U=0 và M=0 sẽ bị đổi Chỉ kiểm tra mà không thay đổi nội dung bit U, bit M", "order_start": 0, "order_end": 766, "word_count": 177}
{"parent_id": "8fca6d62-8382-4713-bd37-cc2407dcbc2f", "subject": "hedieuhanh", "section": "Bƣớc 2:", "title_path": "Bƣớc 2:", "content": "[hedieuhanh / Bƣớc 2:] Nếu quay hết 1 vòng mà không tìm đƣợc trang có U và M bằng 0 thì quét lại danh sách lần 2 Trang đầu tiên có U=0, M=1 sẽ bị đổi ■ Đặt bit U của những trang đã quét đến nhƣng đƣợc bỏ qua là 0 Nếu chƣa tìm đƣợc thì lặp lại bƣớc 1 và cả bƣớc 2 nếu cần HDH dành ra một số khung trống đƣợc kết nối thành danh sách liên kết gọi là các trang đệm Trang bị đổi nhƣ bình thƣờng nhƣng nội dung trang này không bị xóa ngay khỏi bộ nhớ Khung chứa trang đƣợc đánh dấu là khung trống và thêm vào cuối danh sách trang đệm Trang mới sẽ đƣợc nạp vào khung đứng đầu trong danh sách trang đệm Tới thời điểm thích hợp, hệ thống sẽ ghi nội dung các trang trong danh sách đệm ra đĩa", "order_start": 0, "order_end": 658, "word_count": 151}
{"parent_id": "25b181be-8115-4641-91a2-e411b1a583c8", "subject": "hedieuhanh", "section": "V. BỘ NHỚ ẢO", "title_path": "V. BỘ NHỚ ẢO", "content": "[hedieuhanh / V. BỘ NHỚ ẢO] 3.3 Sử dụng đệm trang Kỹ thuật đệm trang cho phép cải tiến tốc độ: Nếu trang bị đổi có nội dung cần ghi ra đĩa, HDH vẫn có thể nạp trang mới vào ngay Việc ghi ra đĩa sẽ đƣợc lùi lại tới một thời điểm sau Thao tác ghi ra đĩa có thể thực hiện đồng thời với nhiều trang nằm trong danh sách đƣợc đánh dấu trống. Trang bị đổi vẫn đƣợc giữ trong bộ nhớ một thời gian: Nếu có yêu cầu truy cập trong thời gian này, trang sẽ đƣợc lấy ra từ danh sách đệm và sử dụng ngay mà không cần nạp lại từ đĩa => Vùng đệm đóng vai trò giống nhƣ bộ nhớ cache", "order_start": 0, "order_end": 536, "word_count": 123}
{"parent_id": "c9ef3173-cfd0-4356-b47f-969df80b7c1b", "subject": "hedieuhanh", "section": "VI. CẤP PHÁT KHUNG TRANG 1. Giới hạn khung", "title_path": "VI. CẤP PHÁT KHUNG TRANG 1. Giới hạn khung", "content": "[hedieuhanh / VI. CẤP PHÁT KHUNG TRANG 1. Giới hạn khung] HDH cấp phát bao nhiêu khung cho mỗi tiến trình? Khi số lƣợng khung tối đa cấp cho tiến trình giảm tới mức nào đó, lỗi thiếu trang diễn ra thƣờng xuyên => Đặt giới hạn tối thiểu các khung cấp phát cho tiến trình Khi số lƣợng khung cấp cho tiến trình tăng tới mức nào đó thì việc tăng thêm khung cho tiến trình không làm giảm đáng kể tần suất thiếu trang nữa => Cấp phát số lƣợng khung cố định và số lƣợng khung thay đổi VI. CẤP PHÁT KHUNG TRANG 1.1. Cấp phát số lƣợng khung cố định Cấp cho tiến trình một số lƣợng cố định khung để chứa các trang nhớ Số lƣợng đƣợc xác định vào thời điểm tạo mới tiến trình và không thay đổi trong quá trình tiến trình tồn tại Cấp phát bằng nhau: Các tiến trình đƣợc cấp số khung tối đa bằng nhau Số lƣợng đƣợc xác định dựa vào kích thƣớc MEM và mức độ đa chƣơng trình mong muốn Cấp phát không bằng nhau: Các tiến trình đƣợc cấp số khung tối đa khác nhau Cấp số khung tỉ lệ thuận với kích thƣớc tiến trình Có mức ƣu tiên", "order_start": 0, "order_end": 952, "word_count": 205}
{"parent_id": "9cad4940-3cef-4cdf-a2af-55f618d5bd64", "subject": "hedieuhanh", "section": "VI. CẤP PHÁT KHUNG TRANG 1.2. Cấp phát số lƣợng khung thay đổi", "title_path": "VI. CẤP PHÁT KHUNG TRANG 1.2. Cấp phát số lƣợng khung thay đổi", "content": "[hedieuhanh / VI. CẤP PHÁT KHUNG TRANG 1.2. Cấp phát số lƣợng khung thay đổi] Số lƣợng khung tối đa cấp cho mỗi tiến trình có thể thay đổi trong quá trình thực hiện Việc thay đổi phụ thuộc vào tình hình thực hiện của tiến trình Cho phép sử dụng bộ nhớ hiệu quả hơn phƣơng pháp cố định => Cần theo dõi và xử lý thông tin về tình hình sử dụng bộ nhớ của tiến trình", "order_start": 0, "order_end": 284, "word_count": 64}
{"parent_id": "788f30ee-ba7a-401f-a407-dcfc84f633a5", "subject": "hedieuhanh", "section": "VI. CẤP PHÁT KHUNG TRANG PTI 2. Phạm vi cấp phát khung", "title_path": "VI. CẤP PHÁT KHUNG TRANG PTI 2. Phạm vi cấp phát khung", "content": "[hedieuhanh / VI. CẤP PHÁT KHUNG TRANG PTI 2. Phạm vi cấp phát khung] Cấp phát toàn thể: Cho phép tiến trình đổi trang mới vào bất cứ khung nào (không bị khóa), kể cả khung đã đƣợc cấp phát cho tiến trình khác Cấp phát cục bộ: Trang chỉ đƣợc đổi vào khung đang đƣợc cấp cho chính tiến trình đó Phạm vi cấp phát có quan hệ mật thiết với số lƣợng khung tối đa: Số lƣợng khung cố định tƣơng ứng với phạm vi cấp phát cục bộ Số lƣợng khung thay đổi tƣơng ứng với phạm vi cấp phát toàn thể", "order_start": 0, "order_end": 413, "word_count": 91}
{"parent_id": "b4505d43-a744-442e-91f4-d169625ffd81", "subject": "hedieuhanh", "section": "VII. TÌNH TRẠNG TRÌ TRỆ (thrashing)", "title_path": "VII. TÌNH TRẠNG TRÌ TRỆ (thrashing)", "content": "[hedieuhanh / VII. TÌNH TRẠNG TRÌ TRỆ (thrashing)] Là tình trạng đổi trang liên tục do không đủ bộ nhớ Thời gian đổi trang của tiến trình lớn hơn thời gian thực hiện Xảy ra khi: Kích thƣớc bộ nhớ hạn chế Tiến trình đòi hỏi truy cập đồng thời nhiều trang nhớ Hệ thống có mức độ đa chƣơng trình cao VII. TÌNH TRẠNG TRÌ TRỆ (thrashing) Kiểm soát tần suất thiếu trang Khi tiến trình rơi vào tình trạng trì trệ, tần suất thiếu trang tăng đáng kể => sử dụng để phát hiện và giải quyết vấn đề trì trệ Theo dõi và ghi lại tần suất thiếu trang Có thể đặt ra giới hạn trên và giới hạn dƣới cho tần suất thiếu trang của tiến trình Tần suất vƣợt giới hạn trên: Cấp thêm cho tiến trình khung mới  Nếu không thể tìm khung để cấp thêm, tiến trình sẽ bị treo hoặc bị kết thúc Tần suất thiếu trang thấp hơn giới hạn dƣới: thu hồi một số khung của tiến trình", "order_start": 0, "order_end": 790, "word_count": 171}
{"parent_id": "8c4767ea-3e4c-49e2-bf71-5e6ec4f6e7c1", "subject": "hedieuhanh", "section": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM", "title_path": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM", "content": "[hedieuhanh / VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM] Hỗ trợ cơ chế quản lý bộ nhớ: phân đoạn đƣợc kết hợp với phân trang Không gian nhớ của tiến trình bao gồm nhiều đoạn, mỗi đoạn có thể có kích thƣớc khác nhau và đƣợc phân trang trƣớc khi đặt vào bộ nhớ Ánh xạ địa chỉ: 2 giai đoạn Cho phép tiến trình có tối đa 16KB (hơn 16000) đoạn, mỗi đoạn có kích thƣớc tối đa 4GB Không gian nhớ lô gic đƣợc chia thành hai phần: Phần 1: dành riêng cho tiến trình, bao gồm tối đa 8KB đoạn Phần 2: dùng chung cho tất cả tiến trình, bao gồm cả HDH, và cũng gồm tối đa 8KB đoạn LDT(Local Descriptor Table) & GDT (Global Descriptor Table): chứa thông tin quản lý : Mỗi ô có kích thƣớc 8 byte: chứa địa chỉ cơ sở và giới hạn của đoạn tƣơng ứng Có 6 thanh ghi đoạn: cho phép tiến trình truy cập đồng thời 6 đoạn Thông tin về đoạn đƣợc chứa trong 6 thanh ghi 8 byte Địa chỉ logic gồm (selector, offset): Selector: chọn ô tƣơng ứng từ hai bảng mô tả LDT, GDT S: là số thứ tự đoạn G: cho biết đoạn thuộc GDT (g=0) hay LDT(g=1)  P: cho biết chế độ bảo vệ (p=0 là chế độ nhân, p=3 là chế độ ngƣời dùng) Offset: độ dịch trong đoạn, kích thƣớc 32bit", "order_start": 0, "order_end": 1072, "word_count": 234}
{"parent_id": "5829c22e-282a-40a6-9037-e4f0dda92ce6", "subject": "hedieuhanh", "section": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Phân trang", "title_path": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Phân trang", "content": "[hedieuhanh / VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Phân trang] Hỗ trợ kích thƣớc trang 4KB hoặc 4MB, tùy thuộc vào giá trị cờ kích thƣớc trang Trang kích thƣớc 4KB: tổ chức bảng trang thành 2 mức Địa chỉ tuyến tính có kích thƣớc 32 bit P1: cho phép tìm bảng trang mức hai P2: tìm ô tƣơng ứng trong bảng trang mức 2 kết hợp với độ dịch o tạo ra địa chỉ vật lý Trang kích thƣớc 4MB: Bảng trang chỉ có một mức P :10bit O: độ dịch, kích thƣớc 22bit cho phép trỏ tới vị trí cụ thể trong trang nhớ 4MB", "order_start": 0, "order_end": 432, "word_count": 97}
{"parent_id": "8268694e-0480-4fe5-b393-f8304d7a5fa4", "subject": "hedieuhanh", "section": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Phân trang", "title_path": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Phân trang", "content": "[hedieuhanh / VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Phân trang] Biến đổi địa chỉ tuyến tính thành địa chỉ vật lý với kích thƣớc trang 4KB Dia chi tuyén tính", "order_start": 0, "order_end": 92, "word_count": 20}
{"parent_id": "1d2f1848-7078-44f7-b503-6056c1566ce4", "subject": "hedieuhanh", "section": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Ánh xạ địa chỉ", "title_path": "VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Ánh xạ địa chỉ", "content": "[hedieuhanh / VIII. QUẢN LÝ BỘ NHỚ TRONG INTEL PENTIUM Ánh xạ địa chỉ] Cho phép tiến trình sử dụng bộ nhớ ảo tới 4GB 2GB đƣợc dùng riêng cho tiến trình 2GB sau đƣợc dùng chung cho hệ thống Bộ nhớ ảo thực hiện bằng kỹ thuật nạp trang theo nhu cầu và đổi trang Kích thƣớc trang nhớ 4KB Tổ chức bảng trang 2 mức Nạp trang theo cụm: khi xảy ra thiếu trang, nạp cả cụm gồm 1 số trang nằm sau trang bị thiếu", "order_start": 0, "order_end": 330, "word_count": 74}
{"parent_id": "a53a905f-286b-4055-9eea-dbbc51537510", "subject": "hedieuhanh", "section": "IX. QUẢN LÝ BỘ NHỚ TRONG WINDOWS XP", "title_path": "IX. QUẢN LÝ BỘ NHỚ TRONG WINDOWS XP", "content": "[hedieuhanh / IX. QUẢN LÝ BỘ NHỚ TRONG WINDOWS XP] Kiểm soát số lƣợng trang: gán cho mỗi tiến trình số lƣợng trang tối đa và tối thiểu Số lƣợng trang tối đa và tối thiểu cấp cho tiến trình đƣợc thay đổi tùy vào tình trạng bộ nhớ trống HDH lƣu danh sách khung trống, và sử dụng một ngƣỡng an toàn Số khung trống ít hơn ngƣỡng: HDH xem xét các tiến trình đang thực hiện. Tiến trình có số trang lớn hơn số lƣợng tối thiểu sẽ bị giảm số trang cho tới khi đạt tới số lƣợng tối thiểu của mình. Tùy vào vi xử lý, Windows XP sử dụng thuật toán đổi trang khác nhau", "order_start": 0, "order_end": 504, "word_count": 110}
{"parent_id": "c9c1adda-c4db-4c5a-8c51-46ef3eaf0cae", "subject": "hedieuhanh", "section": "KIỂM TRA", "title_path": "KIỂM TRA", "content": "[hedieuhanh / KIỂM TRA] Bài 1: Kích thƣớc khung bộ nhớ là 4096 bytes. Hãy chuyển địa chỉ logic 8207, 4300 sang địa chỉ vật lý biết rằng bảng trang nhƣ sau: Bài 2: Không gian địa chi logic của tiến trình gồm 11 trang, mỗi trang có kích thƣớc 2048B đƣợc ánh xạ vào bộ nhớ vật lý có 20 khung a. Để biểu diễn địa chỉ logic cần tối thiểu bao nhiêu bit b. Để biểu diễn địa chỉ vật lý cần bao nhiêu bit", "order_start": 0, "order_end": 371, "word_count": 83}
{"parent_id": "5ed830e7-d720-47f6-a6d8-6fd80f4a8c42", "subject": "hedieuhanh", "section": "KIỂM TRA", "title_path": "KIỂM TRA", "content": "[hedieuhanh / KIỂM TRA] Bài 3: Bộ nhớ vật lý có 4 khung. Thứ tự truy cập các trang là 1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6. Vẽ sơ đồ cấp phát bộ nhớ và Có bao nhiêu sự kiện thiếu trang xảy ra nếu sử dụng: Thuật toán tối ƣu - FIFO - LRU - Đồng hồ Bài 4: Bộ nhớ có kích thƣớc 1MB. Sử dụng phƣơng pháp kề cận (buddy system) để cấp phát cho các tiến trình lần lƣợt với kích thƣớc nhƣ sau: A: 112KB, B: 200KB, C: 150KB, D: 50KB", "order_start": 0, "order_end": 420, "word_count": 105}
{"parent_id": "86698cd4-66b6-431b-a88a-032c3a7069a4", "subject": "hedieuhanh", "section": "CHƢƠNG 4: QUẢN LÝ TIẾN TRÌNH", "title_path": "CHƢƠNG 4: QUẢN LÝ TIẾN TRÌNH", "content": "[hedieuhanh / CHƢƠNG 4: QUẢN LÝ TIẾN TRÌNH] 1. Các khái niệm liên quan đến tiến trình 2. Luồng (thread) 3 Điều độ tiến trình 4. Đồng bộ hóa các tiến trình đồng thời 5. Tình trạng bế tắc và đói . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 1. Tiến trình là gì? Tiến trình là một chương trình đang trong quá trình thực hiện Tiến trình đƣợc sinh ra khi chƣơng trình đƣợc tải vào bộ nhớ để thực hiện Tiến trình ngƣời dùng Tiến trình hệ thống . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình Phân biệt theo 2 trạng thái: chạy và không chạy => Không phản ánh đầy đủ thông tin về trạng thái tiến trình => Mô hình 5 trạng thái: mới khởi tạo, sẵn sàng, chạy, chờ đợi, kết thúc Mới khởi tạo: tiến trình đang đƣợc tạo ra Sẵn sàng: tiến trình chờ đƣợc cấp CPU để thực hiện lệnh của mình Chạy: lệnh của tiến trình đƣợc CPU thực hiện Chờ đợi: tiến trình chờ đợi một sự kiện gì đó xảy ra (blocked) Kết thúc: tiến trình đã kết thúc việc thực hiện nhƣng vẫn chƣa bị xóa Sơ đồ chuyển đổi trạng thái của tiến trình", "order_start": 0, "order_end": 967, "word_count": 207}
{"parent_id": "3ef53ecc-aa3f-447e-9269-d82e88b88f5e", "subject": "hedieuhanh", "section": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình", "title_path": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình", "content": "[hedieuhanh / . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình] Khởi tạo -> sẵn sàng: tiến trình khởi tạo xong và đã đƣợc tải vào bộ nhớ, chỉ chờ đƣợc cấp Cpu để chạy. Sẵn sàng -> chạy: do kết quả điều độ CPU của hđh, tiến trình đƣợc HDH cấp phát CPU và chuyển sang trạng thái chạy Chạy -> sẵn sàng: HĐH cấp phát CPU cho tiến trình khác, do kết quả điều độ/do ngắt xảy ra, tiến trình hiện thời chuyển sang trạng thái sẵn sàng và chờ đƣợc cấp CPU để chạy tiếp. Chạy -> chờ đợi: Khi tiến trình đó chỉ chạy khi có 1 sự kiện nào đó xảy ra, chuyển sang tt chờ đƣợc phân phối Cpu để chạy tiếp. Chạy -> end: khi TT đã thực hiện Sơ đồ chuyển đổi trạng thái của tiến trình . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Thông tin mô tả tiến trình Để có thể quản lý tiến trình, HĐH cần có các thông tin về tiến trình đó.", "order_start": 0, "order_end": 743, "word_count": 167}
{"parent_id": "3ef53ecc-aa3f-447e-9269-d82e88b88f5e", "subject": "hedieuhanh", "section": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình", "title_path": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình", "content": "[hedieuhanh / . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 2. Trạng thái của tiến trình] chuyển đổi trạng thái của tiến trình . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Thông tin mô tả tiến trình Để có thể quản lý tiến trình, HĐH cần có các thông tin về tiến trình đó. Thông tin của tiến trình đƣợc lƣu trong một cấu trúc dữ liệu gọi là khối quản lý tiến trình - PCB (Process Control Block) Các thông tin chính trong PCB: Số định danh của tiến trình (PID) Trạng thái tiến trình: một trong năm trạng thái Nội dung một số thanh ghi CPU: Thanh ghi con trỏ lệnh: trỏ tới lệnh tiếp theo Thanh ghi con trỏ ngăn xếp: lƣu tham số/tình trạng hàm khi thực hiện lời gọi hàm/thủ tục của chƣơng trình Các thanh ghi điều kiện và trạng thái: chứa trạng thái sau khi thực hiện phép toán logic/số học Các thanh ghi đa năng . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Thông tin mô tả tiến trình Lý do phải lƣu lại các thanh ghi này trong PCB là do tiến trình có thể bị chuyển khỏi trạng thái chạy để nhƣờng chỗ cho tiến trình khác. Khi tiến trình quay trời lại, HĐH sẽ dùng thông tin từ PCB để khôi phục lại nội dung các thanh ghi, cho phép tiến trình thực hiện lại từ trạng tháitrƣớc lúc dừng.", "order_start": 743, "order_end": 1831, "word_count": 229}
{"parent_id": "e2866547-0433-47f3-a82f-d75e719b96a1", "subject": "hedieuhanh", "section": "PCB:", "title_path": "PCB:", "content": "[hedieuhanh / PCB:] Thông tin phục vụ điều độ tiến trình: mức độ ƣu tiên của tiến trình, vị trí trong hàng đợi, … Thông tin về bộ nhớ của tiến trình Danh sách các tài nguyên khác: các file đang mở, thiết bị vào ra mà tiến trình sử dụng Thông tin thống kê phục vụ quản lý: thời gian sử dụng CPU, giới hạn thời gian . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 4. Bảng và danh sách tiến trình Để quản lý, HĐH cần biết vị trí các PCB. HĐH sử dụng bảng tiến trình chứa con trỏ tới PCB của toàn bộ tiến trình có trong hệ thống Ngoài ra, PCB của các tiến trình cùng trạng thái hoặc cùng chờ 1 tài nguyên nào đó đƣợc liên kết thành 1 danh sách, mỗi danh sách gồm một số tiến trình cùng trạng thái. . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình Hoạt động quản lý tiến trình bao gồm một số công việc nhƣ tạo mới, kết thúc tiến trình, chuyển đổi giữa các tiến trình, điều độ, đồng bộ hóa, đảm bảo việc liên lạc giữa các tiến trình.", "order_start": 0, "order_end": 923, "word_count": 202}
{"parent_id": "e2866547-0433-47f3-a82f-d75e719b96a1", "subject": "hedieuhanh", "section": "PCB:", "title_path": "PCB:", "content": "[hedieuhanh / PCB:] động quản lý tiến trình bao gồm một số công việc nhƣ tạo mới, kết thúc tiến trình, chuyển đổi giữa các tiến trình, điều độ, đồng bộ hóa, đảm bảo việc liên lạc giữa các tiến trình. Tạo mới tiến trình: Để tạo ra một tiến trình mới, HDH thực hiện một số bƣớc nhƣ sau: Gán số định danh cho tiến trình đƣợc tạo mới và tạo một ô trong bảng tiến trình Tạo không gian nhớ cho tiến trình và PCB Khởi tạo PCB Liên kết PCB của tiến trình vào các danh sách quản lý", "order_start": 923, "order_end": 1375, "word_count": 99}
{"parent_id": "c9f8e449-c203-4d01-bcae-8feaf3ea772c", "subject": "hedieuhanh", "section": "2. Kết thúc tiến trình:", "title_path": "2. Kết thúc tiến trình:", "content": "[hedieuhanh / 2. Kết thúc tiến trình:] Kết thúc bình thƣờng: yêu cầu HDH kết thúc mình bằng cách gọi lời gọi hệ thống exit() Bị kết thúc: Bị tiến trình cha kết thúc Do các lỗi Yêu cầu nhiều bộ nhớ hơn so với số lƣơng hệ thống có thể cung cấp Thực hiện lâu hơn thời gian giới hạn Do quản trị hệ thống hoặc hệ điều hành kết thúc", "order_start": 0, "order_end": 287, "word_count": 65}
{"parent_id": "e3c278bc-d533-49c5-b2cf-8012211d6f2f", "subject": "hedieuhanh", "section": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình", "title_path": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình", "content": "[hedieuhanh / . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình] 3. Chuyển đổi giữa các tiến trình: Trong quá trình thực hiện, CPU có thể đƣợc chuyển tử tiến trình hiện thời sang thực hiện tiến trình khác. Thông tin về tiến trình hiện thời (chứa trong PCB) đƣợc gọi là ngữ cảnh (context) của tiến trình. Việc chuyển giữa tiến trình còn đƣợc gọi là chuyển đổi ngữ cảnh Việc chuyển đổi tiến trình xảy ra khi: Có ngắt: ngắt do đồng hồ/ngắt vào/ra Tiến trình gọi lời gọi hệ thống Trƣớc khi chuyển sang thực hiện tiến trình khác, ngữ cảnh đƣợc lƣu vào PCB Khi đƣợc cấp phát CPU thực hiện trở lại, ngữ cảnh đƣợc khôi phục từ PCB vào các thanh ghi và bảng tƣơng ứng.", "order_start": 0, "order_end": 594, "word_count": 121}
{"parent_id": "2900156b-a2b3-4f4d-8450-4b8fcdcb2b3e", "subject": "hedieuhanh", "section": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình", "title_path": ". CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình", "content": "[hedieuhanh / . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình] 3. Chuyển đổi giữa các tiến trình: Thông tin nào phải đƣợc cập nhật và lƣu vào PCB khi chuyển tiến trình? => Tùy từng trƣờng hợp: TH đơn giản: Hệ thống chuyển sang thực hiện ngắt vào/ra rồi quay lại thực hiện tiếp tiến trình: Ngữ cảnh gồm thông tin có thể bị hàm xử lý ngắt thay đổi  => nội dung thanh ghi, trạng thái CPU . CÁC KHÁI NIỆM LIÊN QUAN ĐẾN TIẾN TRÌNH 3. Các thao tác với tiến trình TH phức tạp: Sau khi thực hiện ngắt, hệ thống thực hiện tiến trình khác Thay đổi trạng thái tiến trình Cập nhật thông tin thống kê trong PCB Chuyển liên kết PCB của tiến trình vào danh sách ứng với trạng thái mới Cập nhật PCB của tiến trình mới đƣợc chọn Cập nhật nội dung thanh ghi và trạng thái CPU => Chuyển đổi tiến trình đòi hỏi thời gian", "order_start": 0, "order_end": 738, "word_count": 157}
{"parent_id": "beeb0185-68f3-493f-b9a7-af1197d8edca", "subject": "hedieuhanh", "section": "II. LUỒNG THỰC HIỆN (THREAD/ dòng) 1. Khái niệm", "title_path": "II. LUỒNG THỰC HIỆN (THREAD/ dòng) 1. Khái niệm", "content": "[hedieuhanh / II. LUỒNG THỰC HIỆN (THREAD/ dòng) 1. Khái niệm] Tiến trình đƣợc xem xét từ 2 khía cạnh: Tiến trình là 1 đơn vị sở hữu tài nguyên Tiến trình là 1 đơn vị thực hiện công việc tính toán xử lý Các HDH trƣớc đây: mỗi tiến trình chỉ tƣơng ứng với 1 đơn vị xử lý duy nhất => Tiến trình không thể thực hiện nhiều hơn một công việc cùng một lúc", "order_start": 0, "order_end": 286, "word_count": 66}
{"parent_id": "1b4c48dd-e1c0-4754-85c6-78c3a57c5631", "subject": "hedieuhanh", "section": "II. LUỒNG THỰC HIỆN 1. Khái niệm (tt)", "title_path": "II. LUỒNG THỰC HIỆN 1. Khái niệm (tt)", "content": "[hedieuhanh / II. LUỒNG THỰC HIỆN 1. Khái niệm (tt)] HDH hiện đại: cho phép tách riêng vai trò thực hiện lệnh của tiến trình Mỗi đơn vị thực hiện lệnh của tiến trình, tức là 1 chuỗi lệnh được cấp phát CPU để thực hiện độc lập được gọi là một luồng thực hiện HDH hiện nay thƣờng hỗ trợ đa luồng (multithreading) => cho phép nhiều chuỗi lệnh đƣợc thực hiện cùng một lúc II. LUỒNG THỰC HIỆN 2. Tài nguyên của tiến trình và luồng Trong hệ thống cho phép đa luồng, tiến trình vẫn là 1 đơn vị để HDH phân phối tài nguyên Mỗi tiến trình sở hữu chung một số tài nguyên: Không gian nhớ của tiến trình (logic): chứa chƣơng trình (các lệnh), phần dữ liệu cuả tiến trình. Các tài nguyên khác: các file đang mở, thiết bị hoặc cổng vào/ra", "order_start": 0, "order_end": 671, "word_count": 139}
{"parent_id": "e2030d48-d122-4a58-9c40-f39ea404b62c", "subject": "hedieuhanh", "section": "II. LUỒNG THỰC HIỆN 2. Tài nguyên của tiến trình và luồng (tt)", "title_path": "II. LUỒNG THỰC HIỆN 2. Tài nguyên của tiến trình và luồng (tt)", "content": "[hedieuhanh / II. LUỒNG THỰC HIỆN 2. Tài nguyên của tiến trình và luồng (tt)] Đến đây, có sự khác biệt giữa tiến trình đơn luồng và tiến trình đa luồng. Mô hình đơn luồng: Tiến trình có khối quản lý PCB chứa đầy đủ thông tin trạng thái tiến trình, giá trị thanh ghi Ngăn xếp chứa tham số, trạng thái hàm/ thủ tục/ chƣơng trình con Khi tiến trình thực hiện, nó sẽ làm chủ nội dung các thanh ghi và con trỏ lệnh", "order_start": 0, "order_end": 331, "word_count": 71}
{"parent_id": "2c1426ac-5a60-4449-ac82-5d24071883ac", "subject": "hedieuhanh", "section": "Mô hình đa luồng:", "title_path": "Mô hình đa luồng:", "content": "[hedieuhanh / Mô hình đa luồng:] Mỗi luồng cần có khả năng quản lý con trỏ lệnh, nội dung thanh ghi Luồng cũng có trạng thái riêng => chứa trong khối quản lý luồng Luồng cũng cần có ngăn xếp riêng Tất cả các luồng của 1 tiến trình chia sẻ không gian nhớ và tài nguyên Các luồng có cùng không gian địa chỉ và có thể truy cập tới dữ liệu của tiến trình II. LUỒNG THỰC HIỆN 3. Ưu điểm của mô hình đa luồng Tăng hiệu năng và tiết kiệm thời gian Dễ dàng chia sẻ tài nguyên và thông tin Tăng tính đáp ứng Tận dụng đƣợc kiến trúc xử lý với nhiều CPU Thuận lợi cho việc tổ chức chƣơng trình Có thể tạo và quản lý luồng ở 2 mức: Mức ngƣời dùng Mức nhân Luồng mức ngƣời dùng: đƣợc tạo ra và quản lý không có sự hỗ trợ của HDH Luồng mức nhân: đƣợc tạo ra và quản lý bởi HDH", "order_start": 0, "order_end": 729, "word_count": 164}
{"parent_id": "1717f3c2-86e1-4e05-b73c-198238524890", "subject": "hedieuhanh", "section": "II. LUỒNG THỰC HIỆN 4.1. Luồng mức người dùng", "title_path": "II. LUỒNG THỰC HIỆN 4.1. Luồng mức người dùng", "content": "[hedieuhanh / II. LUỒNG THỰC HIỆN 4.1. Luồng mức người dùng] Do trình ứng dụng tự tạo ra và quản lý HĐH không biết về sự tồn tại của những dòng nhƣ vậy Sử dụng thƣ viện do ngôn ngữ lập trình cung cấp HDH vẫn coi tiến trình nhƣ một đơn vị duy nhất với một trạng thái duy nhất Việc phân phối CPU đƣợc thực hiện cho cả tiến trình II. LUỒNG THỰC HIỆN 4.1. luồng mức người dùng (tt)", "order_start": 0, "order_end": 316, "word_count": 71}
{"parent_id": "2943d79e-c601-4939-a776-d889c565e5fa", "subject": "hedieuhanh", "section": "Ƣu điểm:", "title_path": "Ƣu điểm:", "content": "[hedieuhanh / Ƣu điểm:] Việc chuyển đổi luồng không đòi hỏi chuyển sang chế độ nhân => tiết kiệm thời gian Trình ứng dụng có thể điều độ theo đặc điểm riêng của mình, không phụ thuộc vào cách điều độ của HDH ■ Có thể sử dụng trên cả những HDH không hỗ trợ đa luồng", "order_start": 0, "order_end": 240, "word_count": 53}
{"parent_id": "d6da8bac-2ab7-4e5d-850f-5e4da8f07bf8", "subject": "hedieuhanh", "section": "Nhƣợc điểm:", "title_path": "Nhƣợc điểm:", "content": "[hedieuhanh / Nhƣợc điểm:] Khi một luồng gọi lời gọi hệ thống và bị phong tỏa thì toàn bộ tiến trình bị phong tỏa => không cho phép tận dụng ƣu điểm về tính đáp ứng của mô hình đa luồng Không cho phép tận dụng kiến trúc nhiều CPU do HĐH phân phối CPU cho cả tiến trình chứ không phải từng dòng cụ thể Luồng mức nhân đƣợc HĐH tạo ra và quản lý HĐH cung cấp giao diện lập trình: gồm các lời gọi hệ thống mà trình ứng dụng có thể yêu cầu tạo/ xóa luồng và thay đổi tham số liên quan quản lý dòng Tăng tính đáp ứng và khả năng thực hiện đồng thời của các luồng trong cùng tiến trình Tạo và chuyển đổi luồng thực hiện trong chế độ nhân => tốc độ chậm HĐH Windows và Linux hỗ trợ luồng mức nhân Có thể sử dụng dòng mức ngƣời dùng và dòng mức nhân Theo các tổ chức này: Luồng mức ngƣời dùng đƣợc tạo ra trong chế độ ngƣời dùng nhờ thƣ viện cuả trình ứng dụng Luồng mức ngƣời dùng đƣợc ánh xạ lên số lƣợng tƣơng ứng hoặc ít hơn các luồng mức nhân Số lƣợng dòng mức nhân phụ thuộc vào hệ thống cụ thể, chẳng hạn hệ thống nhiều CPU sẽ có nhiều dòng mức nhân hơn.", "order_start": 0, "order_end": 1025, "word_count": 228}
{"parent_id": "202d52a3-0f68-4d34-8287-32ff86c08579", "subject": "hedieuhanh", "section": "II. DÒNG THỰC HIỆN", "title_path": "II. DÒNG THỰC HIỆN", "content": "[hedieuhanh / II. DÒNG THỰC HIỆN] 4.3. kết hợp Dòng mức nhân và mức người dùng a) Mô hình mức người dùng Trong hệ thống cho phép đa chương trình, nhiều tiến trình có thể tồn tại và thực hiện cùng lúc. Kỹ thuật đa chương trình có nhiều ưu điểm do cho cho phép sử dụng CPU hiệu quả, đáp ứng nhu cầu tính toán của người dùng Tuy nhiên, đặt ra nhiều vấn đề phức tạp hơn đối với HĐH Điều độ (scheduling) hay lập lịch là quyết định tiến trình nào đƣợc sử dụng tài nguyên phần cứng khi nào, trong thời gian bao lâu Tập trung vào vấn đề điều độ đối với CPU => Quyết định thứ tự và thời gian sử dụng CPU Điều độ tiến trình và điều độ dòng: Hệ thống trƣớc kia: tiến trình là đơn vị thực hiện chính => điều độ thực hiện với tiến trình Hệ thống hỗ trợ luồng: luồng mức nhân là đơn vị thực hiện đƣợc HDH cấp CPU chứ không phải tiến trình.", "order_start": 0, "order_end": 791, "word_count": 173}
{"parent_id": "202d52a3-0f68-4d34-8287-32ff86c08579", "subject": "hedieuhanh", "section": "II. DÒNG THỰC HIỆN", "title_path": "II. DÒNG THỰC HIỆN", "content": "[hedieuhanh / II. DÒNG THỰC HIỆN] kia: tiến trình là đơn vị thực hiện chính => điều độ thực hiện với tiến trình Hệ thống hỗ trợ luồng: luồng mức nhân là đơn vị thực hiện đƣợc HDH cấp CPU chứ không phải tiến trình. => Sử dụng thuật ngữ điều độ tiến trình rộng rãi  điều độ luồng", "order_start": 791, "order_end": 1035, "word_count": 54}
{"parent_id": "bd22d57c-13d2-49c7-973a-daa61c05c318", "subject": "hedieuhanh", "section": "Điều độ dài hạn và ngắn hạn", "title_path": "Điều độ dài hạn và ngắn hạn", "content": "[hedieuhanh / Điều độ dài hạn và ngắn hạn] Điều độ dài hạn: Thực hiện khi mới tạo ra tiến trình HDH quyết định tiến trình có đƣợc thêm vào danh sách đang hoạt động? Nếu đƣợc chấp nhận, hệ thống sẽ có thêm tiến trình mới. Ngƣợc lại, chờ tới thời điểm khác để tạo và thực hiện Ảnh hƣởng tới mức độ đa chƣơng trình Điều độ trung hạn: Quyết định tiến trình có đƣợc cấp MEM để thực hiện? Điều độ ngắn hạn:  Quyết định tiến trình nào đƣợc cấp CPU để thực hiện Thực hiện với tiến trình ở trạng thái sẵn sàng III. ĐIỀU ĐỘ TIẾN TRÌNH 2. Các dạng điều độ (tt) 2. Điều độ có phân phối lại và không phân phối lại: Điều độ có phân phối lại (preemptive):  HDH có thể sử dụng cơ chế ngắt để thu hồi CPU của một tiến trình đang trong trạng thái chạy Điều độ không phân phối lại (nonpreemptive):  Tiến trình đang ở trạng thái chạy sẽ đƣợc sử dụng CPU cho đến khi xảy ra một trong các tình huống sau: Tiến trình kết thúc Tiến trình phải chuyển sang trạng thái chờ đợi do thực hiện I/O => Điều độ hợp tác: chỉ thực hiện đƣợc khi tiến trình hợp tác và nhƣờng CPU Nếu tiến trình không hợp tác, dùng CPU vô hạn => các tiến trình khác không đƣợc cấp CPU (Windows", "order_start": 0, "order_end": 1099, "word_count": 236}
{"parent_id": "bd22d57c-13d2-49c7-973a-daa61c05c318", "subject": "hedieuhanh", "section": "Điều độ dài hạn và ngắn hạn", "title_path": "Điều độ dài hạn và ngắn hạn", "content": "[hedieuhanh / Điều độ dài hạn và ngắn hạn] ện I/O => Điều độ hợp tác: chỉ thực hiện đƣợc khi tiến trình hợp tác và nhƣờng CPU Nếu tiến trình không hợp tác, dùng CPU vô hạn => các tiến trình khác không đƣợc cấp CPU (Windows 96, NT)", "order_start": 1099, "order_end": 1286, "word_count": 41}
{"parent_id": "03bfb2d2-bf9f-424a-9a0c-56619a0642e3", "subject": "hedieuhanh", "section": "2. Điều độ có phân phối lại:", "title_path": "2. Điều độ có phân phối lại:", "content": "[hedieuhanh / 2. Điều độ có phân phối lại:] So với điều độ không phân phối lại, điều độ có phân phối lại có nhiều ƣu điểm hơn. HDH chủ động hơn, không phụ thuộc vào hoạt động của tiến trình Đảm bảo chia sẻ thời gian thực sự Đòi hỏi phần cứng có bộ định thời gian và một số hỗ trợ khác Vấn đề quản lý tiến trình phức tạp hơn III. ĐIỀU ĐỘ TIẾN TRÌNH 3. Các tiêu chí điều độ Một số tiêu chí thƣờng đƣợc sử dụng: 1. Lƣợng tiến trình đƣợc thực hiện xong: Số lƣợng tiến trình thực hiện xong trong 1 đơn vị thời gian Đo tính hiệu quả của hệ thống Hiệu suất sử dụng CPU Cố gắng để CPU càng ít phải nghỉ càng tốt 3. Thời gian vòng đời trung bình của tiến trình: Từ lúc có yêu cầu tạo tiến trình đến khi kết thúc Thời gian chờ đợi: Tổng thời gian tiến trình nằm trong trạng thái sẵn sàng và chờ cấp CPU Ảnh hƣởng trực tiếp của thuật toán điều độ tiến trình", "order_start": 0, "order_end": 802, "word_count": 178}
{"parent_id": "006ca7e2-9c37-43f5-9782-7d8346eb3a3e", "subject": "hedieuhanh", "section": "Thời gian đáp ứng", "title_path": "Thời gian đáp ứng", "content": "[hedieuhanh / Thời gian đáp ứng] Đây là tiêu chí hƣớng tới ngƣời dùng và thƣờng đƣợc sử dụng trong hệ thống tƣơng tác trực tiếp. 6. Tính dự đoán đƣợc: Vòng đời, thời gian chờ đợi, thời gian đáp ứng phải ổn định, không phụ thuộc vào tải của hệ thống Tính công bằng Các tiến trình cùng độ ƣu tiên phải đƣợc đối xử nhƣ nhau III. ĐIỀU ĐỘ TIẾN TRÌNH 4. Các thuật toán điều độ 1. Thuật toán đến trƣớc phục vụ trƣớc (FCFS): Tiến trình yêu cầu CPU trƣớc sẽ đƣợc cấp trƣớc HDH xếp các tiến trình sẵn sàng vào hàng đợi FIFO Tiến trình mới đƣợc xếp vào cuối hàng đợi Đơn giản, đảm bảo tính công bằng Thời gian chờ đợi trung bình lớn => Ảnh hƣởng lớn tới hiệu suất chung của toàn hệ thống Thƣờng là thuật toán điều độ không phân phối lại, sau khi tiến trình đƣợc cấp CPU, tiến trình đó sẽ sử dụng CPU đến khi kết thúc hoặc phải dừng lại để chờ kết quả vào ra. 1. Thuật toán đến trƣớc phục vụ trƣớc (FCFS): Cho 3 tiến trình với thứ tự xuất hiện và độ dài chu kỳ CPU nhƣ sau: Tién trinh Dô dài chu ky CPU P1 10 P2 4 P3 2 Két quà diěu dô theo thuât toán FCFS thě hin trên hinh sau: Thōi gian chò dgi cūa P1, P2, P3 làn lugt là 0, 10, và 14.", "order_start": 0, "order_end": 1092, "word_count": 243}
{"parent_id": "006ca7e2-9c37-43f5-9782-7d8346eb3a3e", "subject": "hedieuhanh", "section": "Thời gian đáp ứng", "title_path": "Thời gian đáp ứng", "content": "[hedieuhanh / Thời gian đáp ứng] kỳ CPU nhƣ sau: Tién trinh Dô dài chu ky CPU P1 10 P2 4 P3 2 Két quà diěu dô theo thuât toán FCFS thě hin trên hinh sau: Thōi gian chò dgi cūa P1, P2, P3 làn lugt là 0, 10, và 14. Thōi gian chò dgi trung binh = (0 + 10 + 14)/3 = 8. III. ĐIỀU ĐỘ TIẾN TRÌNH 4. Các thuật toán điều độ (tt)", "order_start": 1092, "order_end": 1378, "word_count": 71}
{"parent_id": "4a17877e-b3b1-4d2d-9f58-cf0a1401605e", "subject": "hedieuhanh", "section": "2. Điều độ quay vòng (RR: round robin):", "title_path": "2. Điều độ quay vòng (RR: round robin):", "content": "[hedieuhanh / 2. Điều độ quay vòng (RR: round robin):] Sửa đổi FCFS dùng cho các hệ chia sẻ thời gian Có thêm cơ chế phân phối lại bằng cách sử dụng ngắt của đồng hồ Hệ thống xác định những khoảng thời gian nhỏ gọi là lượng tử/ lát cắt thời gian t Khi CPU đƣợc giải phóng, HDH đặt thời gian của đồng hồ bằng độ dài lƣợng tử, lấy tiến trình ở đầu hàng đợi và cấp CPU cho nó Tiến trình kết thúc trƣớc khi hết thời gian t: trả quyền điều khiển cho HDH", "order_start": 0, "order_end": 393, "word_count": 89}
{"parent_id": "20ccf044-38be-4be4-bfd3-3a520c39712d", "subject": "hedieuhanh", "section": "2. Điều độ quay vòng (tt)", "title_path": "2. Điều độ quay vòng (tt)", "content": "[hedieuhanh / 2. Điều độ quay vòng (tt)] Hết lƣợng tử thời gian mà tiến trình chƣa kết thúc: Đồng hồ sinh ngắt Tiến trình đang thực hiện bị dừng lại Quyền điều khiển chuyển cho hàm xử lý ngắt của HDH HDH chuyển tiến trình về cuối hàng đợi, lấy tiến trình ở đầu và tiếp tục Cải thiện thời gian đáp ứng so với FCFS Thời gian chờ đợi trung bình vẫn dài Lựa chọn độ dài lƣợng tử thời gian?", "order_start": 0, "order_end": 344, "word_count": 75}
{"parent_id": "46d8a3d5-2b54-41fd-9ab4-32b4658ea212", "subject": "hedieuhanh", "section": "2. Điều độ quay vòng (tt)", "title_path": "2. Điều độ quay vòng (tt)", "content": "[hedieuhanh / 2. Điều độ quay vòng (tt)] Thòi gian chò dgi cua P1, P2, P3 làn lugt là 6, 6, và 4. Thòi gian chò dgi trung bình = (6 + 6 + 4)/3=5,33. III. ĐIỀU ĐỘ TIẾN TRÌNH 4. Các thuật toán điều độ (TT) 3. Điều độ ƣu tiên tiến trình ngắn nhất (SPF)  Chọn trong hàng đợi tiến trình có chu kỳ sử dụng CPU tiếp theo ngắn nhất để phân phối CPU Nếu có nhiều tiến trình với chu kỳ CPU tiếp theo bằng nhau, chọn tiến trình đứng trƣớc Thời gian chờ đợi trung bình nhỏ hơn nhiều so với FCFS Khó thực hiện vì phải biết độ dài chu kỳ CPU tiếp:  Trong các hệ thống xử lý theo mẻ: dựa vào thời gian đăng kí tối đa do lập trình viên cung cấp Dự đoán độ dài chu kỳ CPU tiếp theo: dựa trên độ dài TB các chu kỳ CPU trƣớc đó Không có phân phối lại 3. Điều độ ƣu tiên tiến trình ngắn nhất (SPF) Thòi gian chò dgi trung bình = (6 + 2 +0)/3 = 2,67. III. ĐIỀU ĐỘ TIẾN TRÌNH 4.", "order_start": 0, "order_end": 817, "word_count": 189}
{"parent_id": "46d8a3d5-2b54-41fd-9ab4-32b4658ea212", "subject": "hedieuhanh", "section": "2. Điều độ quay vòng (tt)", "title_path": "2. Điều độ quay vòng (tt)", "content": "[hedieuhanh / 2. Điều độ quay vòng (tt)] ộ dài TB các chu kỳ CPU trƣớc đó Không có phân phối lại 3. Điều độ ƣu tiên tiến trình ngắn nhất (SPF) Thòi gian chò dgi trung bình = (6 + 2 +0)/3 = 2,67. III. ĐIỀU ĐỘ TIẾN TRÌNH 4. Các thuật toán điều độ (tt)", "order_start": 817, "order_end": 1025, "word_count": 49}
{"parent_id": "f8144936-ccba-4bc9-af24-ecc355a677a8", "subject": "hedieuhanh", "section": "4. Điều độ ƣu tiên thời gian còn lại ngắn nhất", "title_path": "4. Điều độ ƣu tiên thời gian còn lại ngắn nhất", "content": "[hedieuhanh / 4. Điều độ ƣu tiên thời gian còn lại ngắn nhất] SPF có thêm cơ chế phân phối lại (SRTF) Khi 1 tiến trình mới xuất hiện trong hàng đợi, HDH so sánh thời gian còn lại của tiến trình đang chạy với thời gian còn lại của tiến trình mới xuất hiện Nếu tiến trình mới xuất hiện có thời gian còn lại ngắn hơn, HDH thu hồi CPU của tiến trình đang chạy, phân phối cho tiến trình mới Thời gian chờ đợi trung bình nhỏ HDH phải dự đoán độ dài chu kỳ CPU của tiến trình Việc chuyển đổi tiến trình ít hơn so với RR III. ĐIỀU ĐỘ TIẾN TRÌNH 4. Các thuật toán điều độ (tt)", "order_start": 0, "order_end": 505, "word_count": 111}
{"parent_id": "19ba812f-7ba0-4d94-a10f-c5640f212696", "subject": "hedieuhanh", "section": "4. Điều độ ƣu tiên thời gian còn lại ngắn nhất (SRTF)", "title_path": "4. Điều độ ƣu tiên thời gian còn lại ngắn nhất (SRTF)", "content": "[hedieuhanh / 4. Điều độ ƣu tiên thời gian còn lại ngắn nhất (SRTF)] Tién trinh Thōi dim xuåt hin Dô dài chu ky CPU P1 0 8 P2 0 7 P3 2 2 Két quà diu dô sù dung SRTF dugc thé hin trên biu dò sau:", "order_start": 0, "order_end": 125, "word_count": 34}
{"parent_id": "a1411127-2b16-4a66-aaa7-c6a231d2e147", "subject": "hedieuhanh", "section": "5. Điều độ có mức ƣu tiên", "title_path": "5. Điều độ có mức ƣu tiên", "content": "[hedieuhanh / 5. Điều độ có mức ƣu tiên] Mỗi tiến trình có 1 mức ƣu tiên Tiến trình có mức ƣu tiên cao hơn sẽ đƣợc cấp CPU trƣớc Các tiến trình có mức ƣu tiên bằng nhau đƣợc điều độ theo FCFS Mức ƣu tiên đƣợc xác định theo nhiều tiêu chí khác nhau", "order_start": 0, "order_end": 206, "word_count": 47}
{"parent_id": "ae841531-6830-431d-ba22-dbba5cade21c", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI] Những tiến trình cùng tồn tại đƣợc gọi là tiến trình đồng thời /tiến trình tương tranh Quản lý tiến trình đồng thời là vấn đề quan trọng:  Liên lạc giữa các tiến trình  Cạnh tranh và chia sẻ tài nguyên Phối hợp và đồng bộ hóa các tiến trình  Vấn đề bế tắc  Đói tài nguyên (starvation) V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời 1. Tiến trình cạnh tranh tài nguyên với nhau: Đảm bảo loại trừ tương hỗ (mutual exclusion):  Khi các tiến trình cùng truy nhập tài nguyên mà khả năng chia sẻ của tài nguyên đó là có hạn => phải đảm bảo tiến trình này đang truy cập tài nguyên thì tiến trình khác không đƣợc truy cập Tài nguyên đó gọi là tài nguyên nguy hiểm. Đoạn chƣơng trìn có yêu cầu sử dụng tài nguyên nguy hiểm gọi là đoạn nguy hiểm (critical section) Mỗi thời điểm chỉ có 1 tiến trình nằm trong đoạn nguy hiểm => loại trừ lẫn nhau V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời (tt) 1.", "order_start": 0, "order_end": 966, "word_count": 207}
{"parent_id": "ae841531-6830-431d-ba22-dbba5cade21c", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI] section) Mỗi thời điểm chỉ có 1 tiến trình nằm trong đoạn nguy hiểm => loại trừ lẫn nhau V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời (tt) 1. Tiến trình cạnh tranh tài nguyên với nhau (tt): Không để xảy ra bế tắc (deadlock):  Bế tắc: tình trạng hai hoặc nhiều tiến trình không thể thực hiện tiếp do chờ đợi lẫn nhau Không để đói tài nguyên (starvation): Tình trạng chờ đợi quá lâu mà không đến lƣợt sử dụng tài nguyên V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời (tt) 2. Tiến trình hợp tác với nhau qua tài nguyên chung: Có thể trao đổi thông tin bằng cách chia sẻ vùng nhớ dùng chung (biến toàn thể) ■ Đòi hỏi đảm bảo loại trừ tƣơng hỗ Xuất hiện tình trạng bế tắc và đói Yêu cầu đảm bảo tính nhất quán dữ liệu Điều kiện chạy đua (race condition): tình huống mà một số dòng /tiến trình đọc, ghi dữ liệu sử dụng chung và kết quả phụ thuộc vào thứ tự các thao tác đọc, ghi => Đặt thao tác truy cập và cập nhật dữ liệu dùng chung vào đoạn nguy hiểm", "order_start": 966, "order_end": 1988, "word_count": 221}
{"parent_id": "9cd986db-58eb-4399-b940-e672417fc8ec", "subject": "hedieuhanh", "section": "IV. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời (tt)", "title_path": "IV. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời (tt)", "content": "[hedieuhanh / IV. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 1. Các vấn đề đối với tiến trình đồng thời (tt)] 3. Tiến trình có liên lạc nhờ gửi thông điệp:  Có thể trao đổi thông tin trực tiếp với nhau bằng cách gửi thông điệp (message passing)  Không có yêu cầu loại trừ tƣơng hỗ Có thể xuất hiện bế tắc và đói V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 2. Yêu cầu với giải pháp cho đoạn nguy hiểm Loại trừ tƣơng hỗ Tiến triển Chờ đợi có giới hạn Các giả thiết: Giải pháp không phụ thuộc vào tốc độ của các tiến trình Không tiến trình nào đƣợc phép nằm quá lâu trong đoạn nguy hiểm Thao tác đọc và ghi bộ nhớ là thao tác nguyên tử (atomic) và không thể bị xen ngang giữa chừng V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 2. Yêu cầu với giải pháp cho đoạn nguy hiểm Các giải pháp đƣợc chia thành 3 nhóm chính: Nhóm giải pháp phần mềm Nhóm giải pháp phần cứng Nhóm sử dụng hỗ trợ của HDH hoặc thƣ viện ngôn ngữ lập trình", "order_start": 0, "order_end": 804, "word_count": 176}
{"parent_id": "50143670-1577-45ec-a63d-7c5db5a1a339", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson] Giải pháp thuộc nhóm phần mềm Đề xuất ban đầu cho đồng bộ 2 tiến trình P0 và P1 thực hiện đồng thời với một tài nguyên chung và một đoạn nguy hiểm chung Mỗi tiến trình thực hiện vô hạn và xen kẽ giữa đoạn nguy hiểm với phần còn lại của tiến trình Yêu cầu 2 tiến trình trao đổi thông tin qua 2 biến chung: Turn: xác định đến lƣợt tiến trình nào đƣợc vào đoạn nguy hiểm Cờ cho mỗi tiến trình: flag[i]=true nếu tiến trình thứ i yêu cầu đƣợc vào đoạn nguy hiểm", "order_start": 0, "order_end": 456, "word_count": 99}
{"parent_id": "272ec331-e1c5-423d-8c7b-17e49b3d8aa3", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson (tt)] bool flag[2]; int turn; Void P0() { for(;;) { //lặp vô hạn flag[0] = true; turn = 1; while(flag[1] && turn ==1) ; //lặp đến khi điều kiện không thỏa <đoạn nguy hiểm> flag[0] = false; <phần còn lại của tiến trình> } Void P1() { for(;;) { //lặp vô hạn flag[1] = true; turn = 0; while(flag[0] && turn ==0) ; //lặp đến khi điều kiện không thỏa <đoạn nguy hiểm> flag[1] = false; <phần còn lại của tiến trình> } } Void main() { flag[0] = flag[1] = false; turn =0; //tắt tiến trình chính, chạy đồng thời 2 tiến trình P0 và P1 startProcess (P0); startProcess(P1); BỘ MÔN: KHOA HỌC MÁY TÍNH – KHOA CNTT1", "order_start": 0, "order_end": 594, "word_count": 118}
{"parent_id": "6c0d8d12-2bd5-4c6c-92e5-a54286a8c40a", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI] 3. Giải thuật peterson (tt) Thỏa mãn các yêu cầu: Điều kiện loại trừ tƣơng hỗ Điều kiện tiến triển: P0 chỉ có thể bị P1 ngăn cản vào đoạn nguy hiểm nếu flag[1] = true và turn =1 luôn đúng Có 2 khả năng với P1 ở ngoài đoạn nguy hiểm: P1 chƣa sẵn sàng vào đoạn nguy hiểm => flag[1] = false, P0 có thể vào ngay đoạn nguy hiểm P1 đã đặt flag[1]=true và đang trong vòng lặp while => turn = 1 hoặc 0 Turn = 0: P0 vào đoạn nguy hiểm ngay Turn = 1: P1 vào đoạn nguy hiểm, sau đó đặt flag[1] = false => quay lại khả năng 1 Chờ đợi có giới hạn", "order_start": 0, "order_end": 533, "word_count": 122}
{"parent_id": "42b693d7-c113-4daf-bb0a-79470cbc1193", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 3. Giải thuật peterson (tt)] Sử dụng trên thực tế tƣơng đối phức tạp Đòi hỏi tiến trình đang yêu cầu vào đoạn nguy hiểm phải nằm trong trạng thái chờ đợi tích cực Chờ đợi tích cực: tiến trình vẫn phải sử dụng CPU để kiểm tra xem có thể vào đoạn nguy hiểm? => Lãng phí CPU", "order_start": 0, "order_end": 242, "word_count": 54}
{"parent_id": "2e55a542-6292-4fe0-ac66-1614aea40d83", "subject": "hedieuhanh", "section": "Cấm các ngắt:", "title_path": "Cấm các ngắt:", "content": "[hedieuhanh / Cấm các ngắt:] Tiến trình đang có CPU: thực hiện cho đến khi tiến trình đó gọi dịch vụ hệ điều hành hoặc bị ngắt => cấm không để xẩy ra ngắt trong thời gian tiến trình đang ở trong đoạn nguy hiểm để truy cập tài nguyên Đảm bảo tiến trình đƣợc thực hiện trọn vẹn đoạn nguy hiểm và không bị tiến trình khác chen vào Đơn giản Giảm tính mềm dẻo của HDH Không áp dụng với máy tính nhiều CPU", "order_start": 0, "order_end": 370, "word_count": 81}
{"parent_id": "6b9219a4-ea5f-4c67-b6f1-d916c72baa5e", "subject": "hedieuhanh", "section": "2. Sử dụng lệnh máy đặc biệt:", "title_path": "2. Sử dụng lệnh máy đặc biệt:", "content": "[hedieuhanh / 2. Sử dụng lệnh máy đặc biệt:] Phần cứng đƣợc thiết kế có một số lệnh máy đặc biệt 2 thao tác kiểm tra và thay đổi giá trị cho một biến, hoặc các thao tác so sánh và hoán đổi giá trị hai biến, đƣợc thực hiện trong cùng một lệnh máy => Đảm bảo đƣợc thực hiện cùng nhau mà không bị xen vào giữa – thao tác nguyên tử (atomic) Gọi là lệnh “kiểm tra và xác lập” – Test_and_Set", "order_start": 0, "order_end": 340, "word_count": 76}
{"parent_id": "138b114b-527f-4ab2-940b-c086bf7bc53b", "subject": "hedieuhanh", "section": "IV. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 4. Giải pháp phần cứng (tt)", "title_path": "IV. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 4. Giải pháp phần cứng (tt)", "content": "[hedieuhanh / IV. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 4. Giải pháp phần cứng (tt)] 2. Sử dụng lệnh máy đặc biệt (tt): Logic của lệnh Test_and_Set: Bool Test_and_Set(bool & val) { bool temp = val; val = true; return temp;", "order_start": 0, "order_end": 137, "word_count": 26}
{"parent_id": "de51a392-f3aa-4159-a570-d557e61b552f", "subject": "hedieuhanh", "section": "2. Sử dụng lệnh máy đặc biệt (tt):", "title_path": "2. Sử dụng lệnh máy đặc biệt (tt):", "content": "[hedieuhanh / 2. Sử dụng lệnh máy đặc biệt (tt):] const int n; //n là số lượng tiến trình bool lock; void P(int i){ //tiến trình P(i) for(;;){ //lặp vô hạn while(Test_and_Set(lock));//lặp đến khi điều kiện không thỏa <Đoạn nguy hiểm> lock = false; <Phần còn lại của tiến trình> } void main(){ lock = false; //tắt tiến trình chính, chạy đồng thời n tiến trình StartProcess(P(1)); …. StartProcess(P(n)); }", "order_start": 0, "order_end": 353, "word_count": 60}
{"parent_id": "b4be32a6-da46-4260-9153-4db4bf4f6811", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 4. Giải pháp phần cứng (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 4. Giải pháp phần cứng (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 4. Giải pháp phần cứng (tt)] 2. Sử dụng lệnh máy đặc biệt (tt): Ƣu điểm: Việc sử dụng tƣơng đối đơn giản và trực quan Có thể dùng để đồng bộ nhiều tiến trình Có thể sử dụng cho trƣờng hợp đa xử lý với nhiều CPU nhƣng có bộ nhớ chung Nhƣợc điểm: Chờ đợi tích cực Có thể gây đói", "order_start": 0, "order_end": 247, "word_count": 57}
{"parent_id": "d30f9750-4a17-4eb5-a615-fc6e26d84f38", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu] Cờ hiệu S là 1biến nguyên đƣợc khởi tạo bằng khả năng phục vụ đồng thời của tài nguyên Giá trị của S chỉ có thể thay đổi nhờ gọi 2 thao tác là Wait và Signal Wait(S): Giảm S đi 1 đơn vị Nếu giá trị của S<0 thì tiến trình gọi wait(S) sẽ bị phong tỏa Signal(S): Tăng S lên 1 đơn vị Nếu giá trị của S≤0: 1 trong các tiến trình đang bị phong tỏa đƣợc giải phóng và có thể thực hiện tiếp", "order_start": 0, "order_end": 382, "word_count": 88}
{"parent_id": "5e612435-5ee8-484d-b9cb-6e206d065e7b", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu (tt)] Wait và Signal là những thao tác nguyên tử Để tránh tình trạng chờ đợi tích cực, sử dụng 2 thao tác phong tỏa và đánh thức: Nếu tiến trình thực hiện thao tác wait, giá trị cờ hiệu âm thì thay vì chờ đợi tích cực nó sẽ bị phong tỏa ( bởi thao tác block) và thêm vào hàng đợi của cờ hiệu Khi có 1 tiến trình thực hiện thao tác signal thì 1 trong các tiến trình bị khóa sẽ đƣợc chuyển sang trạng thái sẵn sàng nhờ thao tác đánh thức (wakeup) chứa trong signal", "order_start": 0, "order_end": 456, "word_count": 100}
{"parent_id": "42bc7ff5-5aa5-4c27-a0e6-66a4ce9a0052", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 5. Cờ hiệu (tt)] Cờ hiệu đƣợc tiến trình sử dụng để gửi tín hiệu trƣớc khi vào và sau khi ra khỏi đoạn nguy hiểm Khi tiến trình cần truy cập tài nguyên, thực hiện thao tác Wait của cờ hiệu tƣơng ứng Giá trị cờ hiệu âm sau khi giảm: Tài nguyên đƣợc sử dụng hết khả năng Tiến trình thực hiện Wait sẽ bị phong tỏa đến khi tài nguyên đƣợc giải phóng Nếu tiến trình khác thực hiện Wait trên cờ hiệu, giá trị cờ hiệu sẽ giảm tiếp Giá trị tuyệt đối của cờ hiệu âm tƣơng ứng với số tiến trình bị phong tỏa Sau khi dùng xong tài nguyên, tiến trình thực hiện thao tác Signal trên cùng cờ hiệu: tăng giá trị cờ hiệu và cho phép một tiến trình đang phong tỏa đƣợc thực hiện tiếp", "order_start": 0, "order_end": 649, "word_count": 141}
{"parent_id": "a77398d2-60e3-4f89-9c6f-4e30cb86cb21", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ] Bài toán triết gia ăn cơm: 5 triết gia ngồi trên ghế quanh 1 bàn tròn Trên bàn có 5 cái đũa: bên phải và bên trái mỗi ngƣời có 1 cái Triết gia có thể nhặt 2 chiếc đũa theo thứ tự bất kì: phải nhặt từng chiếc một và đũa không nằm trong tay ngƣời khác Khi cầm đƣợc cả 2 đũa: triết gia bắt đầu ăn và không đặt đũa trong thời gian ăn Sau khi ăn xong, triết gia đặt 2 đũa xuống bàn => 5 triết gia nhƣ 5 tiến trình đồng thời với tài nguyên nguy hiểm là đũa và đoạn nguy hiểm là đoạn dùng đũa để ăn => Mỗi đũa đƣợc biểu diễn bằng 1 cờ hiệu Nhặt đũa: wait(); đặt đũa xuống: signal()", "order_start": 0, "order_end": 574, "word_count": 132}
{"parent_id": "45157ce8-828f-4438-bf56-e5f6361d2910", "subject": "hedieuhanh", "section": "1. Bài toán triết gia ăn cơm:", "title_path": "1. Bài toán triết gia ăn cơm:", "content": "[hedieuhanh / 1. Bài toán triết gia ăn cơm:] V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt) 2. Bài toán ngƣời sản xuất, ngƣời tiêu dùng với bộ đệm hạn chế: Ngƣời sản xuất: tạo ra sản phẩm, xếp nó vào 1 chỗ gọi là bộ đệm, mỗi lần 1 sản phẩm Ngƣời tiêu dùng: lấy sản phẩm từ bộ đệm, mỗi lần 1 sản phẩm, để sử dụng Dung lƣợng bộ đệm hạn chế, chứa tối đa N sản phẩm", "order_start": 0, "order_end": 341, "word_count": 81}
{"parent_id": "61788e67-4f67-4ba0-8941-bed4982863dd", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt)] 2. Bài toán ngƣời sản xuất, ngƣời tiêu dùng với bộ đệm hạn chế: 3 yêu cầu đồng bộ: Ngƣời sản xuất và tiêu dùng không đƣợc sử dụng bộ đệm cùng lúc 2. Khi bộ đệm rỗng, ngƣời tiêu dùng không nên cố lấy sản phẩm 3. Khi bộ đệm đầy, ngƣời sản xuất không đƣợc thêm sản phẩm Giải quyết bằng cờ hiệu: 1. Yêu cầu 1: sử dụng cờ hiệu lock khởi tạo bằng 1 2. Yêu cầu 2: cờ hiệu empty, khởi tạo bằng 0 3. Yêu cầu 3: cờ hiệu full, khởi tạo bằng N", "order_start": 0, "order_end": 431, "word_count": 100}
{"parent_id": "1e09ad1c-47ef-458b-9d5c-889d4b344da2", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 6. Một số bài toán đồng bộ (tt)] 2. Bài toán ngƣời sản xuất, ngƣời tiêu dùng: V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG TH 7. Monitor Đƣợc định nghĩa dƣới dạng một kiểu dữ liệu trừu tƣợng của ngôn ngữ lập trình bậc cao Gồm một dữ liệu riêng, hàm khởi tạo, và một số hàm hoặc phƣơng thức để truy cập dữ liệu: Tiến trình/dòng chỉ có thể truy cập dữ liệu của monitor thông qua các hàm hoặc phƣơng thức của monitor Tại mỗi thời điểm: Chỉ một tiến trình đƣợc thực hiện trong monitor Tiến trình khác gọi hàm của monitor sẽ bị phong tỏa, xếp vào hàng đợi của monitor để chờ cho đến khi monitor đƣợc giải phóng => Đảm bảo loại trừ tƣơng hỗ đối với đoạn nguy hiểm Đặt tài nguyên nguy hiểm vào trong monitor", "order_start": 0, "order_end": 657, "word_count": 137}
{"parent_id": "ae6236df-f71b-42a9-a7ff-e0fdb75e6b99", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)] Tiến trình đang thực hiện trong monitor và bị dừng lại để đợi sự kiện => trả lại monitor để tiến trình khác dùng Tiến trình chờ đợi sẽ đƣợc khôi phục lại từ điểm dừng sau khi điều kiện đang chờ đợi đƣợc thỏa mãn => Sử dụng các biến điều kiện Đƣợc khai báo và sử dụng trong monitor với 2 thao tác: cwait() và csignal()", "order_start": 0, "order_end": 317, "word_count": 68}
{"parent_id": "9203e5a0-6e9c-49e8-8789-89612c936700", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)] x.cwait(): Tiến trình đang ở trong monitor và gọi cwait bị phong tỏa cho tới khi điều kiện x xẩy ra Tiến trình bị xếp vào hàng đợi của biến điều kiện x Monitor đƣợc giải phóng và một tiến trình khác sẽ đƣợc vào x.csignal(): Tiến trình gọi csignal để thông báo điều kiện x đã thỏa mãn Nếu có tiến trình đang bị phong tỏa và nằm trong hàng đợi của x do gọi x.cwait() trƣớc đó sẽ đƣợc giải phóng Nếu không có tiến trình bị phong tỏa thì thao tác csignal sẽ không có tác dụng gì cả", "order_start": 0, "order_end": 477, "word_count": 102}
{"parent_id": "b66f6cdc-95b9-4b82-afcd-e22755b2935b", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)] monitor BoundedBuffer product buffer[N]; //bộ đệm chứa N sản phẩm kiểu product int count; //số lƣợng sản phẩm hiện thời trong bộ đệm condition notFull, notEmpty; //các biến điều kiện public: boundedbuffer( ) { //khởi tạo count = 0; } void append (product x) { if (count == N) notFull.cwait ( ); //dừng và chờ đến khi buffer có chỗ <Thêm một sản phẩm vào buffer> count++; notEmpty.csignal ();", "order_start": 0, "order_end": 391, "word_count": 69}
{"parent_id": "60cbfe7a-f12b-485c-8ec3-6373faaa92b6", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)] product take ( ) { if (count == 0) notEmptry.cwait (); //chờ đến khi buffer không rỗng <Lấy một sản phẩm x từ buffer> count --; notFull.csignal ( ); } } void producer ( ) { //tiến trình ngƣời sản xuất for (;;){ <Sản xuất sản phẩm x> BoundedBuffer.append (x); }", "order_start": 0, "order_end": 260, "word_count": 51}
{"parent_id": "f978e7b9-89e6-4f42-9d5d-b77c3c7a28bf", "subject": "hedieuhanh", "section": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "title_path": "V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)", "content": "[hedieuhanh / V. ĐỒNG BỘ HÓA CÁC TIẾN TRÌNH ĐỒNG THỜI 7. Monitor (tt)] void consumer ( ) { //tiến trình ngƣời tiêu dùng for (;;){ product x = BoundedBuffer.take (); <Tiêu dùng x> } void main() { Thực hiện song song producer và consumer. } Tình trạng một nhóm tiến trình có cạnh tranh về tài nguyên hay có hợp tác phải dừng vô hạn Do tiến trình phải chờ đợi một sự kiện chỉ có thể sinh ra bởi tiến trình khác cũng đang trong trạng thái chờ đợi Đồng thời xảy ra 4 điều kiện: . Loại trừ tƣơng hỗ: có tài nguyên nguy hiểm, tại 1 thời điểm duy nhất 1 tiến trình sử dụng 2. Giữ và chờ: tiến trình giữ tài nguyên trong khi chờ đợi 3 Không có phân phối lại (no preemption): tài nguyên do tiến trình giữ không thể phân phối lại cho tiến trình khác trừ khi tiến trình đang giữ tự nguyện giải phóng tài nguyên Chờ đợi vòng tròn: tồn tại nhóm tiến trình P1, P2, …, Pn sao cho P1 chờ đợi tài nguyên do P2 đang giữ, P2 chờ tài nguyên do P3 đang giữ, …, Pn chờ tài nguyên do P1 đang giữ", "order_start": 0, "order_end": 900, "word_count": 194}
{"parent_id": "38393793-16e1-4bed-9d2e-72ee8be661cf", "subject": "hedieuhanh", "section": "Giải quyết vấn đề bế tắc theo cách:", "title_path": "Giải quyết vấn đề bế tắc theo cách:", "content": "[hedieuhanh / Giải quyết vấn đề bế tắc theo cách:] Ngăn ngừa (deadlock prevention): đảm bảo để một trong bốn điều kiện xẩy ra bế tắc không bao giờ thỏa mãn Phòng tránh (deadlock avoidance): cho phép một số điều kiện bế tắc đƣợc thỏa mãn nhƣng đảm bảo để không đạt tới điểm bế tắc Phát hiện và giải quyết (deadlock detection): cho phép bế tắc xẩy ra, phát hiện bế tắc và khôi phục hệ thống về tình trạng không bế tắc", "order_start": 0, "order_end": 364, "word_count": 74}
{"parent_id": "9492a0f1-d5ab-4751-8c08-f9e4690b25bb", "subject": "hedieuhanh", "section": "V. BẾ TẮC", "title_path": "V. BẾ TẮC", "content": "[hedieuhanh / V. BẾ TẮC] 3. Ngăn ngừa bế tắc Đảm bảo ít nhất 1 trong 4 điều kiện không xảy ra Loại trừ tƣơng hỗ: không thể ngăn ngừa", "order_start": 0, "order_end": 107, "word_count": 25}
{"parent_id": "b95bc4da-24c2-4665-9b7e-5d4522b14314", "subject": "hedieuhanh", "section": "Giữ và chờ:", "title_path": "Giữ và chờ:", "content": "[hedieuhanh / Giữ và chờ:] Cách 1: Yêu cầu tiến trình phải nhận đủ toàn bộ tài nguyên cần thiết trƣớc khi thực hiện tiếp Nếu không nhận đủ, tiến trình bị phong tỏa để chờ cho đến khi có thể nhận đủ tài nguyên", "order_start": 0, "order_end": 181, "word_count": 40}
{"parent_id": "0ce8cff2-7c60-46dc-aef1-5a97f5cc413b", "subject": "hedieuhanh", "section": "Cách 2:", "title_path": "Cách 2:", "content": "[hedieuhanh / Cách 2:] Tiến trình chỉ đƣợc yêu cầu tài nguyên nếu không giữ tài nguyên khác Trƣớc khi yêu cầu thêm tài nguyên, tiến trình phải giải phóng tài nguyên đã đƣợc cấp và yêu cầu lại (nếu cần) cùng với tài nguyên mới", "order_start": 0, "order_end": 202, "word_count": 42}
{"parent_id": "4642bf8d-c473-434e-88ca-e4e6faf6ec04", "subject": "hedieuhanh", "section": "Cách 1:", "title_path": "Cách 1:", "content": "[hedieuhanh / Cách 1:] Khi một tiến trình yêu cầu tài nguyên nhƣng không đƣợc do đã bị cấp phát, HDH sẽ thu hồi lại toàn bộ tài nguyên nó đang giữ Tiến trình chỉ có thể thực hiện tiếp sau khi lấy đƣợc tài nguyên cũ cùng với tài nguyên mới yêu cầu", "order_start": 0, "order_end": 223, "word_count": 50}
{"parent_id": "28926750-962c-413c-af32-aad560d0a670", "subject": "hedieuhanh", "section": "Cách 2:", "title_path": "Cách 2:", "content": "[hedieuhanh / Cách 2:] Khi tiến trình yêu cầu tài nguyên, nếu còn trống, sẽ đƣợc cấp phát ngay Nếu tài nguyên do tiến trình khác giữ mà tiến trình này đang chờ cấp thêm tài nguyên thì thu hồi lại để cấp cho tiến trình yêu cầu Nếu hai điều kiện trên đều không thỏa thì tiến trình yêu cầu tài nguyên phải chờ", "order_start": 0, "order_end": 283, "word_count": 61}
{"parent_id": "0abb283b-90c2-4bb9-888f-531c92732647", "subject": "hedieuhanh", "section": "Chờ đợi vòng tròn:", "title_path": "Chờ đợi vòng tròn:", "content": "[hedieuhanh / Chờ đợi vòng tròn:] Xác định thứ tự cho các dạng tài nguyên và chỉ cho phép tiến trình yêu cầu tài nguyên sao cho tài nguyên mà tiến trình yêu cầu sau có thứ tự lớn hơn tài nguyên mà nó yêu cầu trƣớc Giả sử trong hệ thống có n dạng tài nguyên ký hiệu R1, R2, …, Rn Giả sử những dạng tài nguyên này đƣợc sắp xếp theo thứ tự tăng dần của chỉ số Nếu tiến trình đã yêu cầu một số tài nguyên dạng Ri thì sau đó tiến trình chỉ đƣợc phép yêu cầu tài nguyên dạng Rj nếu j > i Nếu tiến trình cần nhiều tài nguyên cùng dạng thì tiến trình phải yêu cầu tất cả tài nguyên dạng đó cùng một lúc Ngăn ngừa bế tắc: Sử dụng quy tắc hay ràng buộc khi cấp phát tài nguyên để ngăn ngừa điều kiện xẩy ra bế tắc Sử dụng tài nguyên kém hiệu quả, giảm hiệu năng của tiến trình Phòng tránh bế tắc: Cho phép 3 điều kiện đầu xẩy ra và chỉ đảm bảo sao cho trạng thái bế tắc không bao giờ đạt tới Mỗi yêu cầu cấp tài nguyên của tiến trình sẽ đƣợc xem xét và quyết định tùy theo tình hình cụ thể HDH yêu cầu tiến trình cung cấp thông tin về việc sử dụng tài nguyên (số lƣợng tối đa tài nguyên tiến trình cần sử dụng) Khi tiến trình muốn khởi tạo, thô", "order_start": 0, "order_end": 1100, "word_count": 249}
{"parent_id": "0abb283b-90c2-4bb9-888f-531c92732647", "subject": "hedieuhanh", "section": "Chờ đợi vòng tròn:", "title_path": "Chờ đợi vòng tròn:", "content": "[hedieuhanh / Chờ đợi vòng tròn:] tùy theo tình hình cụ thể HDH yêu cầu tiến trình cung cấp thông tin về việc sử dụng tài nguyên (số lƣợng tối đa tài nguyên tiến trình cần sử dụng) Khi tiến trình muốn khởi tạo, thông báo dạng tài nguyên và số lƣợng tài nguyên tối đa cho mỗi dạng sẽ yêu cầu Nếu số lƣợng yêu cầu không vƣợt quá khả năng hệ thống, tiến trình sẽ đƣợc khởi tạo Trạng thái đƣợc xác định bởi tình trạng sử dụng tài nguyên hiện thời trong hệ thống: Số lƣợng tối đa tài nguyên mà tiến trình yêu cầu: Dƣới dạng ma trận M[n][m]: n là số lƣợng tiến trình, m: số tài nguyên M[i][j]: số lƣợng tài nguyên tối đa dạng j mà tiến trình i yêu cầu Số lƣợng tài nguyên còn lại: Dƣới dạng vectơ A[m] A[j] là số lƣợng tài nguyên dạng j còn lại và có thể cấp phát Lƣợng tài nguyên đã cấp cho mỗi tiến trình: Dƣới dạng ma trận D[n][m] D[i][j] là lƣợng tài nguyên dạng j đã cấp cho tiến trình i Lƣợng tài nguyên còn cần cấp Dƣới dạng ma trận C[n][m] C[i][j]=M[i][j]-D[i][j] là lƣợng tài nguyên dạng j mà tiến trình i còn cần cấp Trạng thái an toàn: trạng thái mà từ đó có ít nhất một phƣơng án cấp phát sao cho bế tắc không xẩy ra Cách phòng", "order_start": 1100, "order_end": 2199, "word_count": 235}
{"parent_id": "0abb283b-90c2-4bb9-888f-531c92732647", "subject": "hedieuhanh", "section": "Chờ đợi vòng tròn:", "title_path": "Chờ đợi vòng tròn:", "content": "[hedieuhanh / Chờ đợi vòng tròn:] [j]-D[i][j] là lƣợng tài nguyên dạng j mà tiến trình i còn cần cấp Trạng thái an toàn: trạng thái mà từ đó có ít nhất một phƣơng án cấp phát sao cho bế tắc không xẩy ra Cách phòng tránh bế tắc: Khi tiến trình có yêu cầu cấp tài nguyên, hệ thống giả sử tài nguyên đƣợc cấp Cập nhật lại trạng thái & xác định xem trạng thái đó có an toàn? Nếu an toàn, tài nguyên sẽ đƣợc cấp thật Ngƣợc lại, tiến trình bị phong tỏa &chờ tới khi có thể cấp phát an toàn", "order_start": 2199, "order_end": 2648, "word_count": 100}
{"parent_id": "47915208-2895-4e0e-bd5f-033593fedf06", "subject": "hedieuhanh", "section": "V. BẾ TẮC", "title_path": "V. BẾ TẮC", "content": "[hedieuhanh / V. BẾ TẮC] 4. Phòng tránh bế tắc – thuật toán người cho vay Hệ thống có 3 dạng tài nguyên X, Y, Z với số lƣợng ban đầu X=10, Y=5, Z=7 4 tiến trình P1, P2, P3, P4 có yêu cầu tài nguyên tối đa cho trong bảng Xét trạng thái sau của hệ thống: Yêu cầu tối đa Là trạng thái an toàn Có thể tìm ra cách cấp phát không P1 dẫn đến bế tắc, VD: P2, P4, P3, P1 P2 P1 yêu cầu cấp phát 3 tài nguyên dạng Y, tức là yêu cầu = (0,3,0). Nếu yêu cầu thỏa mãn, hệ thống chuyển sang trạng thái: Trạng thái không an toàn => yêu cầu (0,3,0) bị từ chối", "order_start": 0, "order_end": 516, "word_count": 120}
{"parent_id": "10d947b3-b492-4940-810f-3d3152d6bb00", "subject": "hedieuhanh", "section": "Thuật toán xác định trạng thái an toàn:", "title_path": "Thuật toán xác định trạng thái an toàn:", "content": "[hedieuhanh / Thuật toán xác định trạng thái an toàn:] 1. Khai báo mảng W kích thước m và mảng F kích thước n. (F[i] chứa tình trạng tiến trình thứ i đã kết thúc hay chưa, W chứa lượng tài nguyên còn lại) Khởi tạo W=A và F[i]=false (i=0,…,n-1) 2. Tìm i sao cho: F[i] = false và C[i][j]  W[j] với mọi j=0,…,m-1 Nếu không có i như vậy thì chuyển sang bước 4 3. a) W = W + D[i] b) F[i] = true c) Quay lại bước 2 4. If F[i] = true với mọi i =0,…,n-1 thì trạng thái an toàn Else trạng thái không an toàn Hệ thống không thực hiện biện pháp ngăn ngừa/phòng tránh => bế tắc có thể xảy ra Hệ thống định kỳ kiểm tra để phát hiện có tình trạng bế tắc hay không? Nếu có, hệ thống sẽ xử lý để khôi phục lại trạng thái không có bế tắc", "order_start": 0, "order_end": 666, "word_count": 152}
{"parent_id": "a7c6c5af-2969-470d-a416-93321ae6f9cb", "subject": "hedieuhanh", "section": "Phát hiện bế tắc:", "title_path": "Phát hiện bế tắc:", "content": "[hedieuhanh / Phát hiện bế tắc:] Trƣờng hợp mỗi dạng tài nguyên chỉ có một tài nguyên duy nhất =>sử dụng đồ thị biểu diễn quan hệ chờ đợi lần nhau giữa tiến trình Xây dựng đồ thị cấp phát tài nguyên: Các nút là tiến trình và tài nguyên Tài nguyên đƣợc nối với tiến trình bằng cung có hƣớng nếu tài nguyên đƣợc cấp cho tiến `trình đó Tiến trình đƣợc nối với tài nguyên bằng cung có hƣớng nếu tiến trình đang đƣợc cấp tài nguyên đó Phát hiện bế tắc: Đồ thị chờ đợi: Đƣợc xây dựng từ đồ thị cấp phát tài nguyên bằng cách bỏ đi các nút tƣơng ứng với tài nguyên và nhập các cung đi qua nút bị bỏ Cho phép phát hiện tình trạng tiến trình chờ đợi vòng tròn là điều kiện đủ để sinh ra bế tắc Sử dụng thuật toán phát hiện chu trình trên đồ thị có hƣớng để phát hiện bế tắc trên đồ thị chờ đợi Thời điểm phát hiện bế tắc: Bế tắc chỉ có thể xuất hiện sau khi một tiến trình nào đó yêu cầu tài nguyên và không đƣợc thỏa mãn => Chạy thuật toán phát hiện bế tắc mỗi khi có yêu cầu cấp phát tài nguyên không đƣợc thỏa mãn => Cho phép phát hiện bế tắc ngay khi vừa xẩy ra Chạy thƣờng xuyên làm giảm hiệu năng hệ thống Giảm tần suất chạy thuật toán p", "order_start": 0, "order_end": 1100, "word_count": 244}
{"parent_id": "a7c6c5af-2969-470d-a416-93321ae6f9cb", "subject": "hedieuhanh", "section": "Phát hiện bế tắc:", "title_path": "Phát hiện bế tắc:", "content": "[hedieuhanh / Phát hiện bế tắc:] hi có yêu cầu cấp phát tài nguyên không đƣợc thỏa mãn => Cho phép phát hiện bế tắc ngay khi vừa xẩy ra Chạy thƣờng xuyên làm giảm hiệu năng hệ thống Giảm tần suất chạy thuật toán phát hiện bế tắc: Sau từng chu kỳ từ vài chục phút tới vài giờ Khi có một số dấu hiệu nhƣ hiệu suất sử dụng CPU giảm xuống dƣới một ngƣỡng nào đó", "order_start": 1100, "order_end": 1424, "word_count": 73}
{"parent_id": "5a8729b0-1cd3-4eb4-9ebb-09442701a566", "subject": "hedieuhanh", "section": "Xử lý khi bị bế tắc:", "title_path": "Xử lý khi bị bế tắc:", "content": "[hedieuhanh / Xử lý khi bị bế tắc:] Kết thúc tất cả tiến trình đang bị bế tắc Kết thúc lần lƣợt từng tiến trình đang bị bế tắc đến khi hết bế tắc: HDH phải chạy lại thuật toán phát hiện bế tắc sau khi kết thúc 1 tiến trình HDH có thể chọn thứ tự kết thúc tiến trình dựa trên tiêu chí nào đó Khôi phục tiến trình về thời điểm trƣớc khi bị bế tắc sau đó cho các tiến trình thực hiện lại từ điểm này: Đòi hỏi HDH lƣu trữ trạng thái để có thể thực hiện quay lui và khôi phục về các điểm kiểm tra trƣớc đó Khi chạy lại, các tiến trình có thể lại rơi vào bế tắc tiếp Lần lƣợt thu hồi lại tài nguyên từ các tiến trình bế tắc cho tới khi hết bế tắc", "order_start": 0, "order_end": 604, "word_count": 140}
{"parent_id": "b35dd0b3-a8e0-423b-995a-8e90c0419da7", "subject": "hedieuhanh", "section": "V. BẾ TẮC", "title_path": "V. BẾ TẮC", "content": "[hedieuhanh / V. BẾ TẮC] 6. Ngăn ngừa bế tắc cho bài toán triết gia ăn cơm Đặt hai thao tác lấy đũa của mỗi triết gia vào đoạn nguy hiểm để đảm bảo triết gia lấy đƣợc hai đũa cùng một lúc Quy ƣớc bất đối xứng về thứ tự lấy đũa: ví dụ ngƣời có số thứ tự chẵn lấy đũa trái trƣớc đũa phải, ngƣời có số thứ tự lẻ lấy đũa phải trƣớc đũa trái Tại mỗi thời điểm chỉ cho tối đa bốn ngƣời ngồi vào bàn: Sử dụng thêm một cờ hiệu table có giá trị khởi tạo bằng 4 Triết gia phải gọi thao tác wait(table) trƣớc khi ngồi vào bàn và lấy đũa", "order_start": 0, "order_end": 500, "word_count": 116}
{"parent_id": "52b969f5-7ce9-4eff-b0eb-7181707e3215", "subject": "hedieuhanh", "section": "V. BẾ TẮC", "title_path": "V. BẾ TẮC", "content": "[hedieuhanh / V. BẾ TẮC] 6. Ngăn ngừa bế tắc cho bài toán triết gia ăn cơm Bài 1: Cho các tiến trình với thời điểm xuất hiện, thời gian (chu kỳ) CPU tiếp theo và số ƣu tiên nhƣ trong bảng sau (số ƣu tiên nhỏ ứng với độ ƣu tiên cao). Vẽ biểu đồ thể hiện thứ tự và thời gian cấp phát CPU cho các tiến trình sử dụng thuật toán a. Điều độ theo mức ƣu tiên không có phân phối lại b. Điều độ ƣu tiên tiến trình ngắn nhất c. Điều độ ƣu tiên thời gian còn lại ngắn nhất Tính thời gian chờ đợi trung bình cho từng trƣờng hợp. Bài 2: Bộ nhớ vật lý có 5 khung. Thứ tự truy cập các trang là 1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6. Vẽ sơ đồ cấp phát bộ nhớ và Có bao nhiêu sự kiện thiếu trang xảy ra nếu sử dụng: - LRU - Đồng hồ Bài 3: Kích thƣớc khung bộ nhớ là 2048 bytes.", "order_start": 0, "order_end": 756, "word_count": 183}
{"parent_id": "52b969f5-7ce9-4eff-b0eb-7181707e3215", "subject": "hedieuhanh", "section": "V. BẾ TẮC", "title_path": "V. BẾ TẮC", "content": "[hedieuhanh / V. BẾ TẮC] , 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6. Vẽ sơ đồ cấp phát bộ nhớ và Có bao nhiêu sự kiện thiếu trang xảy ra nếu sử dụng: - LRU - Đồng hồ Bài 3: Kích thƣớc khung bộ nhớ là 2048 bytes. Hãy chuyển địa chỉ logic 3500, 5060 sang địa chỉ vật lý biết rằng bảng trang nhƣ sau:", "order_start": 756, "order_end": 1022, "word_count": 66}
{"parent_id": "a9186be0-3d33-40a0-b9a0-2de0594c28bd", "subject": "hedieuhanh", "section": "Bài 2:", "title_path": "Bài 2:", "content": "[hedieuhanh / Bài 2:] a. Sử dụng lệnh Test_and_Set để thực hiện loại trừ tƣơng hỗ cho bài toán triết gia ăn cơm b. Phân tích rõ ràng giải pháp sử dụng lệnh Test_and_Set ở trên có thể gây bế tắc hoặc đói không Bài 3: Xét trạng thái cấp phát tài nguyên của hệ thống nhƣ sau: P1 P2 P3 P4 P2 yêu cầu cấp phát 1 tài nguyên Y, 2 tài nguyên Z. Sử dụng thuật toán ngƣời cho vay để xác định xem yêu cầu của P2 có đƣợc đáp ứng hay không?", "order_start": 0, "order_end": 405, "word_count": 92}
{"parent_id": "e4d11f75-2b0e-46fb-b723-c28810526846", "subject": "Phantichthietkehttt", "section": "Untitled", "title_path": "Untitled", "content": "[Phantichthietkehttt / Untitled] HỌC PHẦN THAY THẾ TỐT NGHIỆP 2 CHUYÊN NGÀNH CÔNG NGHỆ PHẦN MỀM", "order_start": 0, "order_end": 62, "word_count": 13}
{"parent_id": "e6ef091a-6011-4140-9419-772326e3650e", "subject": "Phantichthietkehttt", "section": "TÀI LIỆU THAM KHẢO", "title_path": "TÀI LIỆU THAM KHẢO", "content": "[Phantichthietkehttt / TÀI LIỆU THAM KHẢO] [1] Object-Oriented and Classical Software Engineering, Stephen R. Schach, Eigtth Edition, Mc Graw Hill, 2010. [2] . Mastering Software Quality Assurance: Best Practices, Tools and Techniques for Software Developers, Murali Chemuturi, J. Ross Publication Inc., 2011.", "order_start": 0, "order_end": 266, "word_count": 36}
{"parent_id": "1ff285eb-f285-495f-adbc-232ac34c5d13", "subject": "Phantichthietkehttt", "section": "CHƯƠNG 1: QUY TRÌNH VÀ VÒNG ĐỜI PHÁT TRIỂN PHẦN MỀM...... ......4", "title_path": "CHƯƠNG 1: QUY TRÌNH VÀ VÒNG ĐỜI PHÁT TRIỂN PHẦN MỀM...... ......4", "content": "[Phantichthietkehttt / CHƯƠNG 1: QUY TRÌNH VÀ VÒNG ĐỜI PHÁT TRIỂN PHẦN MỀM...... ......4] 1.1 PHẦN MỀM VÀ PHÁT TRIỂN PHẦN MỀM.. 1.1.1. Phần mềm. .4 1.1.2. Phát triển phần mềm. ..4 1.2 VÒNG ĐỜI PHÁT TRIỂN PHẦN MỀM. ..6 1.2.1 Quy trình phát triển phần mềm hướng đối tượng. ...6 1.2.2 Một số mô hình vòng đời phát triển phần mềm.. ..10 1.3 UML - CÔNG CỤ HỖ TRỢ PHÂN TÍCH THIẾT KẾ HƯỚNG ĐỐI TƯỢNG. ..18 1.3.1 Lịch sử ra đời của UML. ..18 1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng.. ..19 1.3.3 Các khái niệm cơ bản trong UML. ..19 1.3.4 Các biểu đồ UML. ..21 1.4 CÂU HỎI ÔN TẬP.. ..34", "order_start": 0, "order_end": 496, "word_count": 105}
{"parent_id": "f457bc26-c6b5-4836-8e8c-5bf4d6c480bf", "subject": "Phantichthietkehttt", "section": "CHƯƠNG 2: ĐẢM BẢO CHẤT LƯỢNG PHẦN MỀM.. .35", "title_path": "CHƯƠNG 2: ĐẢM BẢO CHẤT LƯỢNG PHẦN MỀM.. .35", "content": "[Phantichthietkehttt / CHƯƠNG 2: ĐẢM BẢO CHẤT LƯỢNG PHẦN MỀM.. .35] 2.1 TỔNG QUAN VỀ ĐẢM BẢO CHẤT LƯỢNG PHẦN MỀM .35 2.1.1 Một số khái niệm .35 2.1.2 Các tiêu chí chất lượng . .36 2.2 CÁC HOẠT ĐỘNG ĐẢM BẢO CHẤT LƯỢNG PHẦN MỀM . ...41 2.2.1. Đảm bảo chất lượng đặc tả ..41 2.2.2. Đảm bảo chất lượng phân tích thiết kế ...42 2.2.3. Đảm bảo chất lượng phát triển phần mềm (lâp trình) . ..43 2.2.4. Kiểm thử phần mềm .... ...44 2.3. CÁC KỸ THUẬT RÀ SOÁT ..46 2.3.1. Mục tiêu của rà soát ..46 2.3.2. Các hình thức rà soát ..46 2.4. CÁC KỸ THUẬT KIỂM THỬ . ..52 2.4.1 Kỹ thuật kiểm thử hộp đen . .52 2.4.2 Kỹ thuật kiểm thử hộp trắng ..54 2.5 CÂU HỎI ÔN TẬP.. .55", "order_start": 0, "order_end": 589, "word_count": 127}
{"parent_id": "42d0f2d0-11bf-4a59-bec5-0309cc007cb7", "subject": "Phantichthietkehttt", "section": "3.1 THU THẬP YÊU CẦU.. ..56", "title_path": "3.1 THU THẬP YÊU CẦU.. ..56", "content": "[Phantichthietkehttt / 3.1 THU THẬP YÊU CẦU.. ..56] 3.1.1 Tìm hiểu lĩnh vực chuyên môn. .56 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên.. ..58 3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case.. ..62 3.2 PHÂN TÍCH YÊU CẦU.. ......68 3.2.1 Viết kịch bản.. .68 3.2.2 Trích lớp thực thể.. ..72 3.2.3 Trích các lớp biên và điều khiển. ..76 3.2.4 Phân tích hoạt động.. ..83 3.3 BÀI TẬP.... ..91", "order_start": 0, "order_end": 337, "word_count": 68}
{"parent_id": "5e7b3e9c-5eeb-411e-94c8-71ed71dfdd73", "subject": "Phantichthietkehttt", "section": "CHƯƠNG 4: THIẾT KẾ. .92", "title_path": "CHƯƠNG 4: THIẾT KẾ. .92", "content": "[Phantichthietkehttt / CHƯƠNG 4: THIẾT KẾ. .92] 4.1 THIẾT KẾ LỚP THỰC THỂ. ..92 4.1.1 Quy trình thực hiện..... ..92", "order_start": 0, "order_end": 67, "word_count": 13}
{"parent_id": "d85f89c7-c7d9-42cf-bfb7-4a247b6cf54f", "subject": "Phantichthietkehttt", "section": "4.1.2 Áp dụng... ..92", "title_path": "4.1.2 Áp dụng... ..92", "content": "[Phantichthietkehttt / 4.1.2 Áp dụng... ..92] 4.2 THIẾT KẾ CSDL. ..94 4.2.1 Quy trình thực hiện. ..94 4.2.2 Áp dụng.. ..95 4.3 THIẾT KẾ CHI TIẾT CHO MODUL. ..96 4.3.1 Thiết kế tĩnh.. ..96 4.3.2 Thiết kế hoạt động.. ..103 4.3.3 Thiết kế triển khai. .113 4.4 CÂU HỎI ÔN TẬP.. .114", "order_start": 0, "order_end": 232, "word_count": 46}
{"parent_id": "15469c80-a22e-45ef-b173-1ce63a9d6cf6", "subject": "Phantichthietkehttt", "section": "CHƯƠNG 5: CÀI ĐẶT HỆ THỐNG.. ..115", "title_path": "CHƯƠNG 5: CÀI ĐẶT HỆ THỐNG.. ..115", "content": "[Phantichthietkehttt / CHƯƠNG 5: CÀI ĐẶT HỆ THỐNG.. ..115] 5.1 TỔ CHỨC DỰ ÁN... 115 5.2.1 Chức năng đăng kí học.. .116 5.2.2 Chức năng nhập điểm.. .142 5.2.3 Chức năng xem thống kê.. .149 5.3 KIỂM THỬ ĐƠN VỊ . .157 5.3.Xây dựng bộ test case cho kiểm thử đơn vị.. .158 5.3.2 Cài đặt kiểm thử đơn vị.. .159 5.4 CÂU HỎI ÔN TẬP.. ..169", "order_start": 0, "order_end": 272, "word_count": 58}
{"parent_id": "cf2fa650-fb1a-4fd8-a698-506bf3cc8eab", "subject": "Phantichthietkehttt", "section": "6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT . ..170", "title_path": "6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT . ..170", "content": "[Phantichthietkehttt / 6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT . ..170] 6.1.1 Rà soát đặc tả... .170 6.1.2 Rà soát phân tích. ..172 6.1.3 Rà soát thiết kế.. ..177 6.1.4 Rà soát code. ..182 6.2. THỰC HIỆN TEST CHỨC NĂNG ..184 6.3 CÂU HỎI ÔN TẬP.. ..233", "order_start": 0, "order_end": 179, "word_count": 36}
{"parent_id": "3f70d37c-2d72-4e33-86e0-dc90c5e14c7c", "subject": "Phantichthietkehttt", "section": "Đặc trưng của phần mềm", "title_path": "Đặc trưng của phần mềm", "content": "[Phantichthietkehttt / Đặc trưng của phần mềm] • Phần mềm không mòn Phần mềm được phát triển mà không được sản xuất theo nghĩa thông thường Mặc dù công nghiệp phần mềm đang hướng đến phát triển dựa trên thành phần nhưng phần lớn phần mềm phát triển dựa theo yêu cầu của khách hàng. Cho đến nay những đặc trưng của phần mềm vẫn còn là vấn đề tranh cãi. Chính điều này thể hiện sự chưa trưởng thành của ngành học CÔNG NGHỆ PHẦN MỀM.", "order_start": 0, "order_end": 383, "word_count": 80}
{"parent_id": "812c9584-2f9c-4f86-9bff-1037742845c3", "subject": "Phantichthietkehttt", "section": "Các kiểu phần mềm", "title_path": "Các kiểu phần mềm", "content": "[Phantichthietkehttt / Các kiểu phần mềm] Phần mềm hệ thống: Tập hợn các Chương trình được viết để phục vụ các chương trình khác, tương tác với phần cứng (ví dụ, biên dịch, trình soạn thảo, HĐH…) Phần mềm thời gian thực: Phần mềm điều phối/phân tích kiểm soát, đáp ứng thời gian Phần mềm nghiệp vụ: Các phần mềm tính lương, kế toán, quản lý kho… Phần mềm khoa học và công nghệ: Các ứng dụng trong thiên văn, sinh học phân tử, điều khiển tàu con thoi,… Phần mềm nhúng: Nằm trong bộ nhớ chỉ đọc điều khiển các sản phẩm và hệ thống • Phần mềm máy tính cá nhân: Xử lý văn bản, đồ họa máy tính… Phần mềm trên Web Phần mềm trí tuệ nhân tạo: Dựa trên những kỹ thuật của Trí tuệ nhân tạo như hệ chuyên gia. Nhận xét: Hiện nay web được xem là môi trường phổ biến để xây dựng giao diện với người sử dụng cho nhiều hệ thống phần mềm trên mạng.", "order_start": 0, "order_end": 790, "word_count": 168}
{"parent_id": "d6d3b33a-ce3a-42ae-9c84-0a1bf1df31dd", "subject": "Phantichthietkehttt", "section": "Khía cạnh lịch sử", "title_path": "Khía cạnh lịch sử", "content": "[Phantichthietkehttt / Khía cạnh lịch sử] • Năm 1967 nhóm NATO đưa ra thuật ngữ Công nghệ phần mềm (Software Engineering). • Năm 1968 Hội nghị Software Engineering ở Garmisch, Đức đưa ra mục đích là giải quyết “Cuộc khủng hoảng phần mềm”: Phần mềm hoàn thành không đúng thời hạn Chi phí vượt dự toán ban đầu Phần mềm còn nhiều lỗi Tại sao không thể sử dụng kỹ nghệ xây cất như xây dựng cầu để xây dựng các hệ điều hành? • Thái độ đối với việc sập cầu/hệ điều hành • Thông tin về CNPM thường không đầy đủ, không chắc chắn • Độ phức tạp • Bảo trì Công nghệ phần mềm không thể xem giống như các kỹ nghệ thông thường khác.", "order_start": 0, "order_end": 576, "word_count": 122}
{"parent_id": "13b923ad-684f-4db2-9207-0eaa6de39c6a", "subject": "Phantichthietkehttt", "section": "Khía cạnh kinh tế", "title_path": "Khía cạnh kinh tế", "content": "[Phantichthietkehttt / Khía cạnh kinh tế] • CNPM và khoa học máy tính (tương tự như hóa học và kỹ nghệ hóa) • Khoa học có phần thực nghiệm và lý thuyết: Phần thực nghiệm của Hóa học là thí nghiệm còn của khoa học máy tính là lập trình. • Khoa học máy tính nghiên cứu những sách khác nhau để tạo ra phần mềm. Nhưng kỹ sư phần mềm chỉ quan tâm kỹ thuật có ý nghĩa kinh tế. • Ví dụ: Phương pháp mã hóa mới KTmới (lập trình hướng thành phần) nhanh hơn phương pháp đang sử dụng hiện thời KTcũ (lập trình hướng đối tượng) là 10%. Chúng ta nên sử dụng phương pháp mới hay không? • Câu trả lời thông thường là: Tất nhiên! Câu trả lời Công nghệ phần mềm: xét hiệu quả của KTmới.", "order_start": 0, "order_end": 627, "word_count": 137}
{"parent_id": "fe956384-2418-4ef9-bf38-9b13d5c675bc", "subject": "Phantichthietkehttt", "section": "Khía cạnh bảo trì", "title_path": "Khía cạnh bảo trì", "content": "[Phantichthietkehttt / Khía cạnh bảo trì] • Vòng đời phần mềm: Một loạt các pha mà phần mềm phải trải qua từ khám phá các khái niệm đến loại bỏ hoàn toàn. • Mô hình vòng đời • Pha yêu cầu • Pha đặc tả • Pha thiết kế • Pha cài đặt • Pha tích hợp • Pha bảo trì Loại bỏ • Bảo trì: Mọi thay đổi đối với sản phẩm một khách hàng đã đồng ý sản phẩm thỏa mãn tài liệu đặc tả. • Phần mềm tốt được bảo trì khác với phần mềm tồi bị loại bỏ • Các dạng bảo trì” Bảo trì sửa lỗi [17,5%]: sửa chữa lỗi nhưng đặc tả không đổi Bảo trì nâng cao: sửa chữa theo thay đổi của đặc tả. Bảo trì hoàn thiện [60,5%]: thêm chức năng để cải tiến sản phẩm. Bảo trì thích nghi [18%]: thay đổi phần mềm để đáp ứng thay đổi của môi trường như quy định chính phủ, CPU, công nghệ mới… Kết luận: Bảo trì là pha tốn kém nhiều thời gian và chi phí", "order_start": 0, "order_end": 768, "word_count": 179}
{"parent_id": "abf64945-c271-4a8f-9de4-818048dc85e1", "subject": "Phantichthietkehttt", "section": "Khía cạnh phân tích và thiết kế", "title_path": "Khía cạnh phân tích và thiết kế", "content": "[Phantichthietkehttt / Khía cạnh phân tích và thiết kế] • 60 đến 70% lỗi của phần mềm là những lỗi do đặc tả và thiết kế Dữ liệu của Kelly, Sherif and Hops [1992] về chương trình không gian liên hành tinh của Nasa • 1,9 lỗi trên một trang đặc tả • 0,9 lỗi trên một trang thiết kế • 0,3 lỗi trên một trang chương trình nguồn • Dữ liệu của Bhandari et al. [1994]: Lỗi trong cuối pha thiết kế của phiên bản mới của sản phẩm • 13% lỗi từ phiên bản trước 16% lỗi trong pha đặc tả mới 71% lỗi trong pha thiết kế mới Kết luận: Xây dựng những kỹ thuật sinh ra thiết kế và đặc tả tốt hơn là một vấn đề quan trọng trong công nghệ phần mềm.", "order_start": 0, "order_end": 573, "word_count": 129}
{"parent_id": "38010da2-61c5-42c4-ba1c-c37875cebef2", "subject": "Phantichthietkehttt", "section": "Khía cạnh nhóm phát triển", "title_path": "Khía cạnh nhóm phát triển", "content": "[Phantichthietkehttt / Khía cạnh nhóm phát triển] • Phần cứng rẻ, khả năng tăng, kích thước giảm • Phần mềm lớn, đắt. Nhiều phần mềm quá lớn nên một người không thể phát triển được trong thời gian có hạn.", "order_start": 0, "order_end": 154, "word_count": 33}
{"parent_id": "c56bbbe8-9a3e-4d62-86c3-a7002c879216", "subject": "Phantichthietkehttt", "section": "1.2.1 Quy trình phát triển phần mềm hướng đối tượng", "title_path": "1.2.1 Quy trình phát triển phần mềm hướng đối tượng", "content": "[Phantichthietkehttt / 1.2.1 Quy trình phát triển phần mềm hướng đối tượng] • Tiến trình phần mềm là “phương cách” sản xuất ra phần mềm. Tiến trình phần mềm nghiên cứu các cách kết hợp: Mô hình vòng đời Các công cụ CASE Các cá nhân xây dựng phần mềm Các công nghệ", "order_start": 0, "order_end": 187, "word_count": 41}
{"parent_id": "a3a7215b-330b-40bc-aaf4-473d12f47409", "subject": "Phantichthietkehttt", "section": "Tiến trình phần mềm = Khía cạnh kỹ thuật + Khía cạnh quản lý", "title_path": "Tiến trình phần mềm = Khía cạnh kỹ thuật + Khía cạnh quản lý", "content": "[Phantichthietkehttt / Tiến trình phần mềm = Khía cạnh kỹ thuật + Khía cạnh quản lý] Các tổ chức khác nhau có những tiến trình phần mềm khác nhau. • Khâu viết tài liệu (quan trọng/không quan trọng) • Chi phí dành cho kiểm thử (1/2 chi phí/không quan trọng) • Tập trung khaua nghiên cứu, phát triển phần mềm. Khâu bảo trì dành cho người khác. • Vì sao như vậy? Thiếu kỹ năng về kỹ nghệ phần mềm Nhiều người quản lý phần mềm thiếu kiến thức về bảo trì và phát triển phần mềm (do đó trễ hạn!) • Quan điểm về quản lý (giao đúng hạn hay kiểm tra kỹ trước khi giao) • Phụ thuộc vào cá nhân", "order_start": 0, "order_end": 498, "word_count": 107}
{"parent_id": "5f2032f3-5183-4982-b301-9d20ae40d4bb", "subject": "Phantichthietkehttt", "section": "Có pha kiểm thử không?", "title_path": "Có pha kiểm thử không?", "content": "[Phantichthietkehttt / Có pha kiểm thử không?] • KHÔNG có pha kiểm thử. Vì sao? Kiểm thử là hoạt động thực hiện trong mọi pha của sản xuất phần mềm. Check = test Testing: Thương được hiểu sau khi coding Kiểm tra (Varification): Thực hiện vào cuối mỗi pha • Kiểm chứng (Validation): Thực hiện trước khi giao sản phẩm cho khách hàng", "order_start": 0, "order_end": 283, "word_count": 56}
{"parent_id": "dd5a1937-58a6-46cc-bedd-4318376a7311", "subject": "Phantichthietkehttt", "section": "Có pha viết tài liệu không?", "title_path": "Có pha viết tài liệu không?", "content": "[Phantichthietkehttt / Có pha viết tài liệu không?] KHÔNG có pha viết tài liệu Mọi pha phải được viết tài liệu trước khi khởi đầu một pha mới. • Một số lý do: Tài liệu bị hoãn lại thì sẽ không bao giờ hoàn thành Cá nhân chịu trách nhiệm trong pha trước có thể đã chuyển sang bộ phận khác. Sản phẩm thường xuyên thay đổi trong khi phát triển vì thế ta cần tài liệu để ghi lại điều này. Ví dụ, thiết kế thường phải sửa đổi trong khi cài đặt. Việc sửa đổi như vậy chỉ có thể thực hiện được khi có tài liệu của nhóm thiết kế. Kiểm thử và viết tài liệu được tiến hành trong mọi pha của tiến trình phần mềm. • Nhóm đảm bảo chất lượng phần mềm (SQA: Software quality assurance): ◦ Có trách nhiệm đảm bảo sản phẩm được xây dựng đúng (theo đặc tả) và theo đơn đặt hàng. ◦ Nhóm SQA phải đóng đúng vai trò ngay từ đầu của tiến trình và hoạt động trong mọi pha của tiến trình phần mềm. ◦ SQA kiểm tra với khách hàng xem phiên bản cuối cùng thỏa mãn hoàn toàn chưa.", "order_start": 0, "order_end": 900, "word_count": 196}
{"parent_id": "38ea0182-3a69-431d-98af-a2272379cebd", "subject": "Phantichthietkehttt", "section": "Pha yêu cầu", "title_path": "Pha yêu cầu", "content": "[Phantichthietkehttt / Pha yêu cầu] • Tiến trình phát triển phần mềm bắt đầu khi khách hàng tiếp xúc với công ty phần mềm và cho rằng: Phần mềm có khả năng thích hợp với khách hàng và giá thành hợp lý. Khám phá khái niệm: 1. Trong lần gặp đầu tiên, khách hàng phát họa sản phẩm mà họ hình dung. Theo quan điểm của người phát triển, mô tả này không rõ ràng, không hợp lý, mâu thuẫn hay không thể xây dựng phần mềm như thế được. 2. Người phát triển xác định nhu cầu và ràng buộc của khách hàng Kiểm thử pha yêu cầu: • Làm bản mẫu nhanh: là mẫu phần mềm kết hợp nhiều chức năng của sản phẩm cuối cùng nhưng bỏ qua những khía cạnh mà khách hàng không thấy được như cập nhật file hay xử lý lỗi. Bản mẫu nhanh phải được kiểm tra bởi khách hàng và người sử dụng. Bản mẫu nhanh có thể thay đổi cho đến khi khách hàng và người sử dụng cho rằng nó có những chức năng mà họ mong muốn. Viết tài liệu pha yêu cầu: • Tài liệu pha yêu cầu: • Có bản mẫu: Bản mẫu nhanh. Bản ghi thỏa thuận với khách hàng và người sử dụng về cơ sở xây dựng và sửa đổi bản mẫu. • Không có bản mẫu (nhóm quyết định không xây dựng bản mẫu): Mô tả nhu cầu khách hàng.", "order_start": 0, "order_end": 1093, "word_count": 243}
{"parent_id": "38ea0182-3a69-431d-98af-a2272379cebd", "subject": "Phantichthietkehttt", "section": "Pha yêu cầu", "title_path": "Pha yêu cầu", "content": "[Phantichthietkehttt / Pha yêu cầu] anh. Bản ghi thỏa thuận với khách hàng và người sử dụng về cơ sở xây dựng và sửa đổi bản mẫu. • Không có bản mẫu (nhóm quyết định không xây dựng bản mẫu): Mô tả nhu cầu khách hàng. Tài liệu này phải được khách hàng, người sử dụng và nhóm phát triển kiểm tra trước khi nhóm SQA xem xét.", "order_start": 1093, "order_end": 1378, "word_count": 63}
{"parent_id": "5395d6ba-4bef-4d2a-8b05-6578bde1f9c0", "subject": "Phantichthietkehttt", "section": "Pha đặc tả/phân tích", "title_path": "Pha đặc tả/phân tích", "content": "[Phantichthietkehttt / Pha đặc tả/phân tích] Khi khách hàng cho rằng nhóm phát triển hiểu được yêu cầu, nhóm đặc tả viết tài liệu đặc tả để mô tả chức năng của sản phẩm (những gì sản phẩm cần có + ràng buộc). Đặc tả bao gồm những input của sản phẩm và output được yêu cầu Ví dụ: Khách hàng cần tính bảng lương thì input bao gồm mức trả cho mỗi nhân viên, thông tin từ hồ sơ cá nhân để tính thuế… và output là số lương thuế, chi bảo hiểm,… • Yêu cầu của đặc tả Không nhập nhằng: không sử dụng thuật ngữ như tiện lợi, đầy đủ chức năng, nhanh, 98%... Đầy đủ: Thể hiện mọi yêu cầu của khách hàng Phi mâu thuẫn: không chứa mâu thuẫn • Theo dõi được (Traceability): có thể lần theo phán đoán trong đặc tả trở lại phán đoán đưa ra bởi khách hàng trong pha yêu cầu. Nếu đặc tả được trình bày đúng phương pháp, có đánh chỉ số,… thì nhóm SQA sẽ ít gặp khó khăn. Nếu có bản mẫu thì phán đoán liên quan của đặc tả phải theo dõi được đến bản mẫu. Môt khi đặc tả được hoàn thành và đã thông qua thì hình thành kế hoạch quản lý quá trình sản xuất phần mềm (SPMP : The software product management plan).", "order_start": 0, "order_end": 1042, "word_count": 226}
{"parent_id": "5395d6ba-4bef-4d2a-8b05-6578bde1f9c0", "subject": "Phantichthietkehttt", "section": "Pha đặc tả/phân tích", "title_path": "Pha đặc tả/phân tích", "content": "[Phantichthietkehttt / Pha đặc tả/phân tích] theo dõi được đến bản mẫu. Môt khi đặc tả được hoàn thành và đã thông qua thì hình thành kế hoạch quản lý quá trình sản xuất phần mềm (SPMP : The software product management plan). • Yêu cầu kế hoạch: SPMP cần nêu lên thời gian thực hiện, chi phí cho từng pha, gán trách nhiệm cá nhân cho từng pha, thời hạn hoàn thành cho mỗi pha. Mô hình vòng đời nào sẽ sử dụng, cấu trúc tổ chức, kỹ thuật và CASE sử dụng, lịch tình, chi phí… Kiểm thử pha đặc tả: • Nguồn gốc chính của lỗi trong các phần mềm đã phân phối đến nay là những lỗi trong tài liệu đặc tả và những lỗi này chỉ được phát hiện khi tổ chức khách hàng sử dụng nó. Duyệt xét lại (Review): là cách tốt nhất để kiểm tra đặc tả. Mục đích là xác định đặc tả có đùng không. Nhóm SQA chủ trì cuộc họp với đại diện nhóm đặc tả và khách hàng.", "order_start": 1042, "order_end": 1833, "word_count": 174}
{"parent_id": "2f560de3-8c7f-47db-b112-4648ffc3fbb3", "subject": "Phantichthietkehttt", "section": "Pha thiết kế", "title_path": "Pha thiết kế", "content": "[Phantichthietkehttt / Pha thiết kế] • Đặc tả - What • Thiết kế - How Giữ lại quyết định thiết kế • Thời điểm kết thúc • Cho nhóm bảo trì Thiết kế nên mở (open-ended) • Thiết kế kiến trúc : Phân rã sản phẩm thành mô đun Thiết kế chi tiết: Thiết kế các mô đun: cấu trúc dữ liệu, thuật toán Kiểm thử pha thiết kế: • Tài liệu viết sao cho dễ theo dõi Duyệt tài liệu", "order_start": 0, "order_end": 325, "word_count": 76}
{"parent_id": "ab170e2c-4ba8-487f-94fd-d53a04a10f40", "subject": "Phantichthietkehttt", "section": "Pha cài đặt", "title_path": "Pha cài đặt", "content": "[Phantichthietkehttt / Pha cài đặt] • Cài đặt thiết kế chi tiết thành chương trình Kiểm thử pha cài đặt: • Rà soát • Các test case • Test không hình thức (desk checking) Test hình thức (Formal testing) do nhóm SQA", "order_start": 0, "order_end": 177, "word_count": 37}
{"parent_id": "117e0cc9-1cec-40b9-ac63-5097b372d0af", "subject": "Phantichthietkehttt", "section": "Tích hợp", "title_path": "Tích hợp", "content": "[Phantichthietkehttt / Tích hợp] • Kết hợp các mô đun và kiểm thử toàn bộ sản phẩm Tài liệu pha tích hợp: Mã nguồn có chú thích • Các test cases", "order_start": 0, "order_end": 111, "word_count": 27}
{"parent_id": "29de6829-7e22-4249-aa9e-2ce0d0e3cc97", "subject": "Phantichthietkehttt", "section": "a. Mô hình xây sửa (code and fixe)", "title_path": "a. Mô hình xây sửa (code and fixe)", "content": "[Phantichthietkehttt / a. Mô hình xây sửa (code and fixe)] Không thiết kế Không đặc tả  Bảo trì là ác mộng • Là cách dễ dàng nhất để phát triển phần mềm • Là cách đắt nhất", "order_start": 0, "order_end": 113, "word_count": 28}
{"parent_id": "5ae2922f-20df-4bb4-bbb6-e95c2ca6948c", "subject": "Phantichthietkehttt", "section": "b. Mô hình thác nước (waterfall)", "title_path": "b. Mô hình thác nước (waterfall)", "content": "[Phantichthietkehttt / b. Mô hình thác nước (waterfall)] • Đặc trưng bởi  Các vòng lặp phản hồi  Hướng tài liệu  Mô hình thác nước không biểu hiện thứ tự các sự kiện Thuận lợi  Tài liệu  Bảo trì dễ dàng • Bất lợi Tài liệu đặc tả o Joe và Jane Johnson o Mark Marberry", "order_start": 0, "order_end": 214, "word_count": 52}
{"parent_id": "d58859d8-069a-489b-95b9-247e98b76f42", "subject": "Phantichthietkehttt", "section": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "title_path": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "content": "[Phantichthietkehttt / d. Mô hình lặp và tăng trưởng (Iteration and Increasement)] • Trong thực tế, chúng ta không thể nói về “pha phân tích”  Mặc dù, các thao tác của pha phân tích trải rộng xuyên suốt vòng đời phần mềm. • Tiến trình phát triển phần mềm là lặp  Mỗi phiên bản kế tiếp tiến gần với hệ thống đích hơn phiên bản trước đó. Luật Miller: • Ở bất cứ thời điểm nào, chúng ta chỉ có thể tập trung vào khoảng 7 chunks ( tương ứng 7đơn vị thông tin) • Để xử lý lượng thông tin lớn hơn yêu cầu sử dụng bước làm mịn theo kiểu bậc thang Tập trung vào các khía cạnh quan trọng nhất hiện thời Các khía cạnh trì hoãn thường ít quan trọng hơn Cuối cùng mọi khía cạnh đều được xử lý nhưng theo thứ tự mức độ quan trọng hiện thời Đây là tiến trình tăng • Lặp và tăng được sử dụng chung với các mô hình khác.  Không có Episode nào mà chỉ có pha “xác định yêu cầu” hoặc “pha thiết kế” Có nhiều thể hiện ở mỗi pha • Số lượng của sự gia tăng sẽ thay đổi – không phải là 4 • Và số lượng vòng lặp cũng thay đồi không phải luôn bằng ba.", "order_start": 0, "order_end": 946, "word_count": 215}
{"parent_id": "d58859d8-069a-489b-95b9-247e98b76f42", "subject": "Phantichthietkehttt", "section": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "title_path": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "content": "[Phantichthietkehttt / d. Mô hình lặp và tăng trưởng (Iteration and Increasement)] định yêu cầu” hoặc “pha thiết kế” Có nhiều thể hiện ở mỗi pha • Số lượng của sự gia tăng sẽ thay đổi – không phải là 4 • Và số lượng vòng lặp cũng thay đồi không phải luôn bằng ba. Các pha cổ điển với các workflow • Các pha tuần tự không có trong thế giới thực • Mặc dù có 5 workflow (luồng công việc) chính được thực hiện ở trên toàn vòng đời phát triển phần mềm Luồng công việc xác định yêu cầu - Requirements workflow  Luồng công việc phân tích - Analysis workflow  Luồng công việc thiết kế - Design workflow  Luồng công việc cài đặt - Implementation workflow  Luồng công việc kiểm thử - Test workflow Các luồng công việc • Cả năm luồng công việc chính được thực hiện trên toàn bộ vòng đời phần mềm Tuy nhiên, ở mỗi một thời điểm có một luồng công việc chiếm ưu thế.", "order_start": 946, "order_end": 1719, "word_count": 165}
{"parent_id": "d58859d8-069a-489b-95b9-247e98b76f42", "subject": "Phantichthietkehttt", "section": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "title_path": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "content": "[Phantichthietkehttt / d. Mô hình lặp và tăng trưởng (Iteration and Increasement)] - Test workflow Các luồng công việc • Cả năm luồng công việc chính được thực hiện trên toàn bộ vòng đời phần mềm Tuy nhiên, ở mỗi một thời điểm có một luồng công việc chiếm ưu thế. • Chẳng hạn:  Ở đầu mỗi vòng đời phát triển phần mềm o Luồng công việc đặc tả yêu cầu chiếm ưu thế  Ở cuối mỗi vòng đời phát triển phần mềm o Luồng công việc cài đặt và kiểm thử chiếm ưu thế • Các hoạt động lập kế hoạch và viết tài liệu được thực hiện xuyết suốt vòng đời phát triển phần mềm Xem xét lại bài toán Winburg Mini • Mô hình cây tiến hóa đã được thêm vào mô hình vòng đời lặp và tăng • Luồng kiểm thử đã bị bỏ quên – mô hình cây tiến hóa giả sử rằng kiểm thử liên tục • Đối với quá trình tăng: Mỗi Episode tương ứng với một sự gia tăng Không phải mỗi sự gia tăng đều bao gồm mọi luông công việc Sự gia tăng B không được hoàn thiện Những đường nét đứt biểu diễn sự bảo trì o Episodes 2, 3: Bảo trì sửa lỗi o Episode 4: Bảo trì hoàn thiện chức năng Rủi ro và những khía cạnh khác của mô hình lặp và tăng • Chúng ta có thể xem xét toàn bộ dự án như là một tập các dự án nhỏ (quá trình tăng) • Mỗi dự án nhỏ gồ", "order_start": 1719, "order_end": 2819, "word_count": 255}
{"parent_id": "d58859d8-069a-489b-95b9-247e98b76f42", "subject": "Phantichthietkehttt", "section": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "title_path": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "content": "[Phantichthietkehttt / d. Mô hình lặp và tăng trưởng (Iteration and Increasement)] hoàn thiện chức năng Rủi ro và những khía cạnh khác của mô hình lặp và tăng • Chúng ta có thể xem xét toàn bộ dự án như là một tập các dự án nhỏ (quá trình tăng) • Mỗi dự án nhỏ gồm ■ Tài liệu yêu cầu  Tài liệu phân tích  Tài liệu thiết kế  Tài liệu cài đặt Tài liệu kiểm thử • Tập tài liệu cuối cùng là sản phẩm phần mềm hoàn thiện • Trong suốt dự án nhỏ:During each mini project we Mở rộng các tài liệu (Sự gia tăng); (ci:) Kiểm tra tài liệu (luồng công việc kiểm thử); và Nếu cần, thay đổi các tài liệu liên quan (vòng lặp) • Mỗi vòng lặp có thể được xem xét như là một mô hình vòng đời thác nước nhỏ nhưng hoàn thiện • Trong suốt mỗi vòng lặp chúng ta lựa chọn một phần của hệ thống phần mềm • Trong mỗi phần đó cần thực hiện:  Pha xác định yêu cầu cổ điển  Pha phân tích cổ điển  Pha thiết kế cổ điển (c:) Pha cài đặt cổ điển Điểm mạnh của mô hình vòng đời lặp và tăng • Có nhiều sự tối ưu cho việc kiểm tra tính đúng đắn của sản phẩm  Mỗi vòng lặp có tích hợp luồng công việc kiểm thử  Các lỗi có thể được phát hiện và sửa chữa sớm Sự mạnh mẽ của kiến trúc có thể được xác định sớm tron", "order_start": 2819, "order_end": 3919, "word_count": 258}
{"parent_id": "d58859d8-069a-489b-95b9-247e98b76f42", "subject": "Phantichthietkehttt", "section": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "title_path": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "content": "[Phantichthietkehttt / d. Mô hình lặp và tăng trưởng (Iteration and Increasement)] ính đúng đắn của sản phẩm  Mỗi vòng lặp có tích hợp luồng công việc kiểm thử  Các lỗi có thể được phát hiện và sửa chữa sớm Sự mạnh mẽ của kiến trúc có thể được xác định sớm trong vòng đời  Kiến trúc – các mô đun thành phần khác nhau và cách chúng kết hợp với nhau Sự mạnh mẽ - có khả năng xử lý việc mở rộng và thay đổi mà hệ thống không bị tách thành từng mảnh • Chúng ta có thể giảm bớt rủi ro sớm hơn  Lúc nào cũng vậy rủi ro luôn liên quan tới quá trình phát triển phần mềm và bảo trì • Chúng ta có một phiên bản hệ thống phần mềm đang làm việc  Khách hàng và người dùng có thể thử nghiệm với phiên bản này để xác định cái họ cần thay đổi Mức độ thay đổi: các phiên bản từng phần đưa ra để làm cho sự giới thiệu sản phẩm mới tới tổ chức khách hàng dễ dàng hơn.", "order_start": 3919, "order_end": 4689, "word_count": 182}
{"parent_id": "d58859d8-069a-489b-95b9-247e98b76f42", "subject": "Phantichthietkehttt", "section": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "title_path": "d. Mô hình lặp và tăng trưởng (Iteration and Increasement)", "content": "[Phantichthietkehttt / d. Mô hình lặp và tăng trưởng (Iteration and Increasement)] ử nghiệm với phiên bản này để xác định cái họ cần thay đổi Mức độ thay đổi: các phiên bản từng phần đưa ra để làm cho sự giới thiệu sản phẩm mới tới tổ chức khách hàng dễ dàng hơn. • Có bằng chứng thực nghiệm chứng tỏ mô hình vòng đời làm việc • Các bản tường trình CHAOS của nhóm Standish đã chỉ ra phần trăm phần mềm thành công tăng • Lý do của sự suy giảm của các dự án thành công năm 2004 bao gồm: Nhiều dự án lớn trong năm 2004 hơn năm 2002 (:) Sử dụng mô hình thác nước Thiếu sự quan tâm của người dùng Thiếu sự hỗ trợ từ những người điều hành lâu năm Việc quản lý lặp và tăng • Mô hình vòng đời lặp và tăng là tập hợp các mô hình thách nước… • … bởi vì mô hình vòng đời lặp và tăng là mô hình thác nước, được áp dụng liên tiếp • Mỗi sự gia tăng là mộ dự án nhỏ theo mô hình vòng đời thác nước", "order_start": 4689, "order_end": 5488, "word_count": 187}
{"parent_id": "49c4950a-3613-4c18-b52a-d02e436bc945", "subject": "Phantichthietkehttt", "section": "e. Mô hình xoắn ốc (Spiral)", "title_path": "e. Mô hình xoắn ốc (Spiral)", "content": "[Phantichthietkehttt / e. Mô hình xoắn ốc (Spiral)] Là mô hình bản mẫu nhanh kết hợp với phân tích rủi ro đi kèm ở mỗi pha Đặc điểm chính của mô hình xoán ốc: Nếu các rủi ro không được làm giảm bớt, thì dự án bị kết thúc ngay lập tức. Mô hình xoắn ốc đầy đủ: • Ở trước mỗi pha là các giải pháp và phân tích rủi ro • Theo sau mỗi pha là: Đánh giá và lập kế hoạch cho pha tiếp theo • Chiều bán kính: Chi phí tích lũy cho đến hiện tại • Chiều góc: sự đi lên theo vòng ốc • Điểm mạnh của mô hình xoắn ốc: • Dễ dàng thay đổi mức độ kiểm thử • Không phân biệt giữa phát triển và bảo trì • Điểm yếu của mô hình xoắn ốc: • Chỉ phù hợp với những phần mềm lớn Chỉ phù hợp với những phần mềm nội bộ", "order_start": 0, "order_end": 635, "word_count": 154}
{"parent_id": "3a36dc87-4732-486f-9f71-689d17e6aed1", "subject": "Phantichthietkehttt", "section": "f. Mô hình mã nguồn mở (Open source)", "title_path": "f. Mô hình mã nguồn mở (Open source)", "content": "[Phantichthietkehttt / f. Mô hình mã nguồn mở (Open source)] Hai pha không hình thức • Đầu tiên, một các nhân xây dựng một phiên bản đầu tiên Đưa phiên bản này lên Internet (ví dụ: SourceForge.net) • Sau đó, nếu có sự quan tâm về dự án này Phiên bản đầu tiên sẽ được tải về một cách rộng rãi  Người dùng trở thành người đồng phát triển Sản phẩm được mở rộng • Điểm chính: Các cá nhân nhìn chung làm việc tình nguyện đối với dự án mã nguồn mở trong thời gian rảnh rỗi của họ • Các hoạt động trong pha phi hình thức thứ hai Báo cáo và sửa lỗi o Bảo trì sửa lỗi  Thêm các chức năng mới o Bảo trì hoàn thiện chức năng o Điều chỉnh phần mềm ở môi trường mới o Bảo trì thích hợp o Pha phi hình thức thứ hai chỉ bao gồm bảo trì sau khi đã chuyển giao sản phẩm o Từ “người đồng phát triển” trong slide trước có thể thay thế bằng từ “đồng bảo trì” • Mô hình vòng đời bảo trì sau khi chuyển giao sản phẩm • Sản phẩm mã nguồn đóng được bảo trì và kiểm thử bởi nhân viên Người dùng có thể đưa ra bản tường trình sự thất bại của phần mềm (failure) nhưng không bao giờ đưa ra được lỗi mã nguồn (fault) (vì mã nguồn không sẵn có) • Phần mềm mã nguồn mở nhìn chung được bảo t", "order_start": 0, "order_end": 1100, "word_count": 248}
{"parent_id": "3a36dc87-4732-486f-9f71-689d17e6aed1", "subject": "Phantichthietkehttt", "section": "f. Mô hình mã nguồn mở (Open source)", "title_path": "f. Mô hình mã nguồn mở (Open source)", "content": "[Phantichthietkehttt / f. Mô hình mã nguồn mở (Open source)] a ra bản tường trình sự thất bại của phần mềm (failure) nhưng không bao giờ đưa ra được lỗi mã nguồn (fault) (vì mã nguồn không sẵn có) • Phần mềm mã nguồn mở nhìn chung được bảo trì bởi người tình nguyện viên không lương  Người dùng được khuyến khích đưa ra bản tường trình về sự thất bại của phần mềm (failure) cũng như lỗi mã nguồn (fault) Nhóm chính Số lượng nhỏ những người bảo trì tận tụy với sở thích, thời gian và những kỹ năng cần thiết để đưa ra những báo cáo lỗi mã nguồn đã được cố định(“fixes”)  Họ chịu trách nhiệm quản lý dữ án  Họ có quyền cài đặt lại những lỗi đã cố định • Nhóm ngoại vi  Users who choose to submit defect reports from time to time Các phiên bản mới của phần mềm mã nguồn đóng được phát hành thường xuyên một năm một lần  Sau khi đã được kiểm thử cẩn thận bởi nhóm quản lý chất lượng phần mềm • Các phát hành của nhóm chính của một phiên bản mới của sản phẩm mã nguồn mở được đưa ra ngay khi sẵn sàng  Có thể là một tháng hoặc thậm chí là một ngày so với với phiên bản trước đó  Nhóm chính thực hiện kiểm thử tối thiểu Kiểm thử mở rộng được thực hiện bởi các", "order_start": 1100, "order_end": 2199, "word_count": 242}
{"parent_id": "3a36dc87-4732-486f-9f71-689d17e6aed1", "subject": "Phantichthietkehttt", "section": "f. Mô hình mã nguồn mở (Open source)", "title_path": "f. Mô hình mã nguồn mở (Open source)", "content": "[Phantichthietkehttt / f. Mô hình mã nguồn mở (Open source)] a ngay khi sẵn sàng  Có thể là một tháng hoặc thậm chí là một ngày so với với phiên bản trước đó  Nhóm chính thực hiện kiểm thử tối thiểu Kiểm thử mở rộng được thực hiện bởi các thành viên của nhóm ngoại vi trong suốt thời gian sử dụng phần mềm □: “Phát hành sớm và thường xuyên” • Phiên bản làm việc đầu tiên được đưa ra khi sử dụng: Mô hình bản mẫu nhanh;  Mô hình xây và sửa; và  Mô hình mã nguồn mở • Sau đó: Mô hình bản mẫu nhanh o Phiên bản đầu tiên bị bỏ qua Mô hình xây và sửa và mô hình vòng đời mã nguồn mở o Phiên bản ban đầu trở thành phiên bản đích • Do đó, trong dự án mã nguồn mở, nhình chung không có đặc tả và không có thiết kế • Một số dự án mã nguồn mở đã thành công như thế nào khi không có đặc tả hoặc thiết kế? • Sản phẩm mã nguồn mở đã thu hút được một số chuyên gia phần mềm tốt nhất trên thế giới  Họ có thể xây dựng các chức năng hiệu quả mà không cần đặc tả hoặc thiết kế • Tuy nhiên, cuối cùng thì sự phát triển sản phẩm mã nguồn mở cũng dừng lại khi mà nó không có sự bảo trì nữa • Nó có thể thành công cực độ đối với những dự án cơ sở hạ tầng như Hệ điều hành (Linu", "order_start": 2199, "order_end": 3299, "word_count": 263}
{"parent_id": "3a36dc87-4732-486f-9f71-689d17e6aed1", "subject": "Phantichthietkehttt", "section": "f. Mô hình mã nguồn mở (Open source)", "title_path": "f. Mô hình mã nguồn mở (Open source)", "content": "[Phantichthietkehttt / f. Mô hình mã nguồn mở (Open source)] i cùng thì sự phát triển sản phẩm mã nguồn mở cũng dừng lại khi mà nó không có sự bảo trì nữa • Nó có thể thành công cực độ đối với những dự án cơ sở hạ tầng như Hệ điều hành (Linux, OpenBSD, Mach, Darwin)  Trình duyệt Web (Firefox, Netscape)  Trình biên dịch (gcc) Máy chủ Web (Apache) Hệ thống quản lý dữ liệu (MySQL) Không thể phát triển mã nguồn mở một sản phẩm phần mềm mà chỉ được sử dụng trong tổ chức thương mại  Các thành viên của cả nhóm chính và nhóm ngoại vi đều luôn luôn là những người dùng của phần mềm đang được phát triển • Mô hình vòng đời mã nguồn mở không không thể áp dụng được trừ khi sản phẩm đích được xem xét bởi một số lượng lớn người dùng vì sản phẩm đó có ích cho họ.", "order_start": 3299, "order_end": 3997, "word_count": 155}
{"parent_id": "3a36dc87-4732-486f-9f71-689d17e6aed1", "subject": "Phantichthietkehttt", "section": "f. Mô hình mã nguồn mở (Open source)", "title_path": "f. Mô hình mã nguồn mở (Open source)", "content": "[Phantichthietkehttt / f. Mô hình mã nguồn mở (Open source)] ềm đang được phát triển • Mô hình vòng đời mã nguồn mở không không thể áp dụng được trừ khi sản phẩm đích được xem xét bởi một số lượng lớn người dùng vì sản phẩm đó có ích cho họ. Khoảng một nửa dự án mã nguồn mở trên Web không thu hút được các nhóm phát triển vào làm việc cho dự án • Even where work has started, the overwhelming preponderance will never be completed • Nhưng khi mô hình mã nguồn mở đã làm việc thì đối khi nó cũng đem lại thành công đáng kinh ngạc  Những sản phẩm mã nguồn mở được kể ở slide trước đã đước sử dụng bởi hàng triệu người dùng", "order_start": 3997, "order_end": 4558, "word_count": 123}
{"parent_id": "07306065-5d38-468e-8d61-5cacfa82486a", "subject": "Phantichthietkehttt", "section": "1.3.1 Lịch sử ra đời của UML", "title_path": "1.3.1 Lịch sử ra đời của UML", "content": "[Phantichthietkehttt / 1.3.1 Lịch sử ra đời của UML] Việc áp dụng rộng rãi phương pháp hướng đối tượng đã đặt ra yêu cầu cần phải xây dựng một phương pháp mô hình hóa để có thể sử dụng như một chuẩn chung cho những người phát triển phần mềm hướng đối tượng trên khắp thế giới. Trong khi các ngôn ngữ hướng đối tượng ra đời khá sớm, ví dụ như Simula-67 (năm 1967), Smalltalk (đầu những năm 1980), C++, CLOS (giữa những năm 1980)…thì những phương pháp luận cho phát triển hướng đối tượng lại ra đời khá muộn. Cuối những năm 80, đầu những năm 1990, một loạt các phương pháp luận và ngôn ngữ mô hình hóa hướng đối tượng mới ra đời, như Booch của Grady Booch, OMT của James Rambaugh, OOSE của Ivar Jacobson, hay OOA and OOD của Coad và Yordon. Mỗi phương pháp luận và ngôn ngữ trên đều có hệ thống ký hiệu riêng, phương pháp xử lý riêng và công cụ hỗ trợ riêng. Chính điều này đã thúc đẩy những người tiên phong trong lĩnh vực mô hình hoá hướng đối tượng ngồi lại cùng nhau để tích hợp những điểm mạnh của mỗi phương pháp và đưa ra một mô hình thống nhất chung.", "order_start": 0, "order_end": 1003, "word_count": 207}
{"parent_id": "07306065-5d38-468e-8d61-5cacfa82486a", "subject": "Phantichthietkehttt", "section": "1.3.1 Lịch sử ra đời của UML", "title_path": "1.3.1 Lịch sử ra đời của UML", "content": "[Phantichthietkehttt / 1.3.1 Lịch sử ra đời của UML] húc đẩy những người tiên phong trong lĩnh vực mô hình hoá hướng đối tượng ngồi lại cùng nhau để tích hợp những điểm mạnh của mỗi phương pháp và đưa ra một mô hình thống nhất chung. Nỗ lực thống nhất đầu tiên bắt đầu khi Rumbaugh gia nhập nhóm nghiên cứu của Booch tại tập đoàn Rational năm 1994 và sau đó Jacobson cũng gia nhập nhóm này vào năm 1995. James Rumbaugh, Grady Booch và Ivar Jacobson đã cùng cố gắng xây dựng được một Ngôn Ngữ Mô Hình Hoá Thống Nhất và đặt tên là UML (Unifield Modeling Language). UML đầu tiên được đưa ra năm 1997 và sau đó được chuẩn hoá để trở thành phiên bản 1.0. Chương này trình bày ngôn ngữ UML phiên bản 2.0.", "order_start": 1003, "order_end": 1648, "word_count": 133}
{"parent_id": "412e8830-42c3-4852-b51f-4b34fe99b904", "subject": "Phantichthietkehttt", "section": "1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng", "title_path": "1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng", "content": "[Phantichthietkehttt / 1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng] UML (Unified Modelling Language) là ngôn ngữ mô hình hoá tổng quát được xây dựng để đặc tả, phát triển và viết tài liệu cho các khía cạnh trong phát triển phần mềm hướng đối tượng. UML giúp người phát triển hiểu rõ và ra quyết định liên quan đến phần mềm cần xây dựng. UML bao gồm một tập các khái niệm, các ký hiệu, các biểu đồ và hướng dẫn. UML hỗ trợ xây dựng hệ thống hướng đối tượng dựa trên việc nắm bắt khía cạnh cấu trúc tĩnh và các hành vi động của hệ thống. • Các cấu trúc tĩnh định nghĩa các kiểu đối tượng quan trọng của hệ thống, nhằm cài đặt và chỉ ra mối quan hệ giữa các đối tượng đó. • Các hành vi động (dynamic behavior) định nghĩa các hoạt động của các đối tượng theo thời gian và tương tác giữa các đối tượng hướng tới đích. Các mục đích của ngôn ngữ mô hình hoá thống nhất UML: • Mô hình hoá các hệ thống sử dụng các khái niệm hướng đối tượng. • Thiết lập sự liên hệ từ nhận thức của con người đến các sự kiện cần mô hình hoá. • Giải quyết vấn đề về mức độ thừa kế trong các hệ thống phức tạp với nhiều ràng buộc khác nhau.", "order_start": 0, "order_end": 1044, "word_count": 228}
{"parent_id": "412e8830-42c3-4852-b51f-4b34fe99b904", "subject": "Phantichthietkehttt", "section": "1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng", "title_path": "1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng", "content": "[Phantichthietkehttt / 1.3.2 UML – Ngôn ngữ mô hình hoá hướng đối tượng] • Thiết lập sự liên hệ từ nhận thức của con người đến các sự kiện cần mô hình hoá. • Giải quyết vấn đề về mức độ thừa kế trong các hệ thống phức tạp với nhiều ràng buộc khác nhau. • Tạo một ngôn ngữ mô hình hoá có thể sử dụng được bởi người và máy. UML quy định một loạt các ký hiệu và quy tắc để mô hình hoá các pha trong quá trình phát triển phần mềm hướng đối tượng dưới dạng các biểu đồ.", "order_start": 1044, "order_end": 1435, "word_count": 91}
{"parent_id": "24f16ece-9e7d-4eeb-95e1-a4c1f509b32c", "subject": "Phantichthietkehttt", "section": "Khái niệm mô hình", "title_path": "Khái niệm mô hình", "content": "[Phantichthietkehttt / Khái niệm mô hình] Mô hình là một biểu diễn của sự vật hay một tập các sự vật trong một lĩnh vực áp dụng nào đó theo một cách khác. Mô hình nhằm nắm bắt các khía cạnh quan trọng của sự vật, bỏ qua các khía cạnh không quan trọng và biểu diễn theo một tập ký hiệu và quy tắc nào đó. Các mô hình thường được xây dựng sao cho có thể vẽ được thành các biểu đồ dựa trên tập ký hiệu và quy tắc đã cho. Khi xây dựng các hệ thống, mô hình được sử dụng nhằm thoả mãn các mục đích sau: • Nắm bắt chính xác yêu cầu và tri thức miền mà hệ thống cần phát triển • Thể hịên tư duy về thiết kế hệ thống • Trợ giúp ra quyết định thiết kế dựa trên việc phân tích yêu cầu • Tổ chức, tìm kiếm, lọc, kiểm tra và sửa đổi thông tin về các hệ thống lớn. • Làm chủ được các hệ thống phức tạp Các thành phần trong một mô hình bao gồm: Ngữ nghĩa và biểu diễn: Ngữ nghĩa là nhằm đưa ra ý nghĩa, bản chất và các tính chất của tập các ký hiệu. Biểu diễn là phương pháp thể hiện mô hình theo cách sao cho có thể nhìn thấy được.", "order_start": 0, "order_end": 976, "word_count": 226}
{"parent_id": "24f16ece-9e7d-4eeb-95e1-a4c1f509b32c", "subject": "Phantichthietkehttt", "section": "Khái niệm mô hình", "title_path": "Khái niệm mô hình", "content": "[Phantichthietkehttt / Khái niệm mô hình] ĩa và biểu diễn: Ngữ nghĩa là nhằm đưa ra ý nghĩa, bản chất và các tính chất của tập các ký hiệu. Biểu diễn là phương pháp thể hiện mô hình theo cách sao cho có thể nhìn thấy được. • Ngữ cảnh: mô tả tổ chức bên trong, cách sử dụng mô hình trong tiến trình phần mềm", "order_start": 976, "order_end": 1240, "word_count": 60}
{"parent_id": "21452563-4b96-466d-8804-49d0bc480bd2", "subject": "Phantichthietkehttt", "section": "• Các hướng nhìn (View) trong UML", "title_path": "• Các hướng nhìn (View) trong UML", "content": "[Phantichthietkehttt / • Các hướng nhìn (View) trong UML] Các mô hình trong UML nhằm mục đích hỗ trợ phát triển các hệ thống phần mềm hướng đối tượng. Trong phương pháp luận hướng đối tượng không có sự phân biệt rạch ròi giữa các pha hay các bước. Tuy nhiên, thông thường UML vẫn được chia thành một số hướng nhìn và nhiều loại biểu đồ. Một hướng nhìn trong UML là một tập con các biểu đồ UML được xây dựng để biểu diễn một khía cạnh nào đó của hệ thống. Sự phân biệt giữa các hướng nhìn là rất linh hoạt. Có thể có những biểu đồ UML có mặt trong cả hai hướng nhìn. Các hướng nhìn cùng các biểu đồ tương ứng được mô tả trong bảng sau: Khía cạnh Hướng nhìn Các biểu Các khái niệm chính chính đồ Khía cạnh cấu Hướng nhìn tĩnh (static Biểu đồ lớp, liên hệ, kế thừa, phụ trúc hệ thống view) lớp thuộc, giao diện Hướng nhìn use case Biểu đồ Use case, tác nhân, liên (Use case view) use case hệ, extend, include … Hướng nhìn cài đặt Biểu đồ Thành phần, giao diện, (implementation view) thành phần quan hệ phụ thuộc … Hướng nhìn triển khai Biểu đồ Node, thành phần, quan hệ (deployment view) triển khai phụ thuộc, vị trí (location) Khía cạnh động Hướng nhìn máy trạ", "order_start": 0, "order_end": 1100, "word_count": 226}
{"parent_id": "21452563-4b96-466d-8804-49d0bc480bd2", "subject": "Phantichthietkehttt", "section": "• Các hướng nhìn (View) trong UML", "title_path": "• Các hướng nhìn (View) trong UML", "content": "[Phantichthietkehttt / • Các hướng nhìn (View) trong UML] ) thành phần quan hệ phụ thuộc … Hướng nhìn triển khai Biểu đồ Node, thành phần, quan hệ (deployment view) triển khai phụ thuộc, vị trí (location) Khía cạnh động Hướng nhìn máy trạng Biểu đồ Trạng thái, sự kiện, thái (state machine view) trạng thái chuyển tiếp, hành động Hướng nhìn hoạt động Biểu đồ Trạng thái, sự kiện, (activity view) động chuyển tiếp, kết hợp, đồng bộ … Hướng nhìn tương tác Biểu đồ Tương tác, đối tượng, (interaction view) tuần tự thông điệp, kích hoạt … Biểu đồ Cộng tác, vai trò cộng tác, cộng tác thông điệp … Khía cạnh quản Hướng nhìn quản lý mô Biểu đồ Gói, hệ thống con, mô lý mô hình hình lớp hình Khía cạnh khả Tất cả Tất cả Các ràng buộc, stereotype, năng mở rộng …", "order_start": 1100, "order_end": 1796, "word_count": 139}
{"parent_id": "71cda85b-6c07-409a-933a-2d7596070557", "subject": "Phantichthietkehttt", "section": "1.3.4 Các biểu đồ UML", "title_path": "1.3.4 Các biểu đồ UML", "content": "[Phantichthietkehttt / 1.3.4 Các biểu đồ UML] Thành phần mô hình chính trong UML là các biểu đồ: Biểu đồ use case biểu diễn sơ đồ chức năng của hệ thống. Từ tập yêu cầu của hệ thống, biểu đồ use case sẽ phải chỉ ra hệ thống cần thực hiện điều gì để thoả mãn các yêu cầu của người dùng hệ thống đó. Đi kèm với biểu đồ use case là các kịch bản. • Biểu đồ lớp chỉ ra các lớp đối tượng trong hệ thống, các thuộc tính và phương thức của từng lớp và các mối quan hệ giữa những lớp đó. • Biểu đồ trạng thái tương ứng với mỗi lớp sẽ chỉ ra các trạng thái mà đối tượng của lớp đó có thể có và sự chuyển tiếp giữa những trạng thái đó. Các biểu đồ tương tác biểu diễn mối liên hệ giữa các đối tượng trong hệ thống và giữa các đối tượng với các tác nhân bên ngoài. Có hai loại biểu đồ tương tác:  Biểu đồ tuần tự: Biểu diễn mối quan hệ giữa các đối tượng và giữa các đối tượng và tác nhân theo thứ tự thời gian.  Biểu đồ cộng tác: Biểu diễn mối quan hệ giữa các đối tượng và giữa các đối tượng và tác nhân nhưng nhấn mạnh đến vai trò của các đối tượng trong tương tác.", "order_start": 0, "order_end": 1012, "word_count": 231}
{"parent_id": "71cda85b-6c07-409a-933a-2d7596070557", "subject": "Phantichthietkehttt", "section": "1.3.4 Các biểu đồ UML", "title_path": "1.3.4 Các biểu đồ UML", "content": "[Phantichthietkehttt / 1.3.4 Các biểu đồ UML] theo thứ tự thời gian.  Biểu đồ cộng tác: Biểu diễn mối quan hệ giữa các đối tượng và giữa các đối tượng và tác nhân nhưng nhấn mạnh đến vai trò của các đối tượng trong tương tác. • Biểu đồ hoạt động biểu diễn các hoạt động và sự đồng bộ, chuyển tiếp các hoạt động, thường được sử dụng để biểu diễn các phương thức phức tạp của các lớp. • Biểu đồ thành phần định nghĩa các thành phần của hệ thống và mối liên hệ giữa các thành phần đó. • Biểu đồ triển khai hệ thống mô tả hệ thống sẽ được triển khai như thế nào, thành phần nào được cài đặt ở đâu, các liên kết vật lý hoặc giao thức truyền thông nào được sử dụng. Dựa trên tính chất của các biểu đồ, UML chia các biểu đồ thành hai lớp mô hình1: Biểu đồ mô hình cấu trúc (Structural Modeling Diagrams): biểu diễn các cấu trúc tĩnh của hệ thống phần mềm được mô hình hoá. Các biểu đồ trong mô hình tĩnh tập trung biểu diễn khía cạnh tĩnh của hệ thống, liên quan đến cấu trúc cơ bản cũng như các phần tử chính trong miền quan tâm của bài toán. Các biểu đồ trong mô hình tĩnh bao gồm: 1. 2. 3.", "order_start": 1012, "order_end": 2052, "word_count": 227}
{"parent_id": "71cda85b-6c07-409a-933a-2d7596070557", "subject": "Phantichthietkehttt", "section": "1.3.4 Các biểu đồ UML", "title_path": "1.3.4 Các biểu đồ UML", "content": "[Phantichthietkehttt / 1.3.4 Các biểu đồ UML] g biểu diễn khía cạnh tĩnh của hệ thống, liên quan đến cấu trúc cơ bản cũng như các phần tử chính trong miền quan tâm của bài toán. Các biểu đồ trong mô hình tĩnh bao gồm: 1. 2. 3. Biểu đồ gói Biểu đồ đối tượng và lớp Biểu đồ thành phần Biểu đồ triển khai 4. Biểu đồ mô hình hành vi (Behavioral Modeling Diagrams): Nắm bắt đến các hoạt động và hành vi của hệ thống, cũng như tương tác giữa các phần tử bên trong và bên ngoài hệ thống. Các dạng biểu đồ trong mô hình động bao gồm: Biểu đồ use case Biểu đồ tương tác dạng tuần tự Biểu đồ tương tác dạng cộng tác Biểu đồ trạng thái Biểu đồ động Chúng ta sẽ lần lượt xem xét chi tiết các biểu đồ UML, mỗi biểu đồ sẽ được trình bày ý nghĩa của nó, tập kí hiệu UML cho biểu đồ đó và một ví dụ.", "order_start": 2052, "order_end": 2789, "word_count": 166}
{"parent_id": "fe0452c2-d139-4a1b-afbe-578b826f3044", "subject": "Phantichthietkehttt", "section": "a. Biểu đồ use case Ý nghĩa", "title_path": "a. Biểu đồ use case Ý nghĩa", "content": "[Phantichthietkehttt / a. Biểu đồ use case Ý nghĩa] Biểu đồ use case biểu diễn sơ đồ chức năng của hệ thống. Từ tập yêu cầu của hệ thống, biểu đồ use case sẽ phải chỉ ra hệ thống cần thực hiện điều gì để thoả mãn các yêu cầu của người dùng hệ thống đó. Đi kèm với biểu đồ use case là các kịch bản (scenario). Có thể nói, biểu đồ use case chỉ ra sự tương tác giữa các tác nhân và hệ thống thông qua các use case. Mỗi use case mô tả một chức năng mà hệ thống cần phải có xét từ quan điểm người sử dụng. Tác nhân là con người hay hệ thống thực khác cung cấp thông tin hay tác động tới hệ thống. Một biểu đồ use case là một tập hợp các tác nhân, các use case và các mối quan hệ giữa chúng. Các use case trong biểu đồ use case có thể được phân rã theo nhiều mức khác nhau.", "order_start": 0, "order_end": 715, "word_count": 164}
{"parent_id": "a77705da-0155-4016-92b0-c60bc55efc9c", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ use case", "title_path": "Tập ký hiệu UML cho biểu đồ use case", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ use case] Một biểu đồ Use Case chứa các phần tử mô hình biểu thị hệ thống, tác nhân cũng như các trường hợp sử dụng và các mối quan hệ giữa các Use Case. Chúng ta sẽ lần lượt xem xét các phần tử mô hình này: • Hệ thống: Với vai trò là thành phần của biểu đồ use case, hệ thống biểu diễn ranh giới giữa bên trong và bên ngoài của một chủ thể trong phần mềm chúng ta đang xây dựng. Chú ý rằng một hệ thống ở trong biểu đồ use case không phải bao giờ cũng nhất thiết là một hệ thống phần mềm; nó có thể là một chiếc máy, hoặc là một hệ thống thực (như một doanh nghiệp, một trường đại học, …). Tác nhân (actor): là người dùng của hệ thống, một tác nhân có thể là một người dùng thực hoặc các hệ thống máy tính khác có vai trò nào đó trong hoạt động của hệ thống. Như vậy, tác nhân thực hiện các use case. Một tác nhân có thể thực hiện nhiều use case và ngược lại một use case cũng có thể được thực hiện bởi nhiều tác nhân. Các use case: Đây là thành phần cơ bản của biểu đồ use case. Các use case được biểu diễn bởi các hình elip. Tên các use case thể hiện một chức năng xác định của hệ thống.", "order_start": 0, "order_end": 1080, "word_count": 241}
{"parent_id": "a77705da-0155-4016-92b0-c60bc55efc9c", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ use case", "title_path": "Tập ký hiệu UML cho biểu đồ use case", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ use case] tác nhân. Các use case: Đây là thành phần cơ bản của biểu đồ use case. Các use case được biểu diễn bởi các hình elip. Tên các use case thể hiện một chức năng xác định của hệ thống. • Mối quan hệ giữa các use case: giữa các use case có thể có các mối quan hệ như sau: • Include: use case này sử dụng lại chức năng của use case kia. • Extend: use case này mở rộng từ use case kia bằng cách thêm vào một chức năng cụ thể. • Generalization: use case này được kế thừa các chức năng từ use case kia. Các phần tử mô hình use case cùng với ý nghĩa và cách biểu diễn của nó được tổng kết trong Bảng 1.2.", "order_start": 1080, "order_end": 1674, "word_count": 133}
{"parent_id": "13ce4db0-5716-40cf-b56a-8c9e94a895a2", "subject": "Phantichthietkehttt", "section": "b. Biểu đồ lớp Ý nghĩa", "title_path": "b. Biểu đồ lớp Ý nghĩa", "content": "[Phantichthietkehttt / b. Biểu đồ lớp Ý nghĩa] Trong phương pháp hướng đối tượng, một nhóm đối tượng có chung một số thuộc tính và phương thức tạo thành một lớp. Mối tương tác giữa các đối tượng trong hệ thống sẽ được biểu diễn thông qua mối quan hệ giữa các lớp. Các lớp (bao gồm cả các thuộc tính và phương thức) cùng với các mối quan hệ sẽ tạo thành biểu đồ lớp. Biểu đồ lớp là một biểu đồ dạng mô hình tĩnh nhằm mô tả hướng nhìn tĩnh về một hệ thống bằng các khái niệm lớp, các thuộc tính, phương thức của lớp và mối quan hệ giữa chúng với nhau.", "order_start": 0, "order_end": 502, "word_count": 109}
{"parent_id": "e0e83aaf-858c-45d4-9f6e-ec0d01df021a", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ lớp", "title_path": "Tập ký hiệu UML cho biểu đồ lớp", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ lớp] Trong phần này, tài liệu sẽ xem xét các vấn đề liên quan đến biểu diễn sơ đồ lớp trong UML. Cuối phần này sẽ là một bảng tổng kết các ký hiệu UML sử dụng trong sơ đồ lớp. • Kí hiệu lớp: trong UML, mỗi lớp được biểu diễn bởi hình chữ nhật gồm 3 phần: tên lớp, các thuộc tính và các phương thức. • Thuộc tính: các thuộc tính trong biểu đồ lớp được biểu diễn theo cấu trúc chung như sau: phạm_vi tên : kiểu số_đối_tượng = mặc_định (Giá_ trị_giới_hạn ) Trong đó: phạm_vi cho biết phạm vi truy nhập của thuộc tính. Có ba kiểu xác định thuộc tính phổ biến là: +: thuộc tính kiểu public #: thuộc tính kiểu protected -: thuộc tính kiểu private. ~: thuộc tính được phép truy nhập tới từ các lớp trong cùng package Các phạm vi của thuộc tính có thể được biểu diễn dưới dạng ký hiệu (+, #, -, ~) hoặc biểu diễn dưới dạng các từ khoá (public, protected, private). Tên: là xâu ký tự biểu diễn tên thuộc tính. kiểu: là kiểu dữ liệu của thuộc tính. số_đối_tượng: chỉ ra số đối tượng khai báo cho thuộc tính ứng với một mặc_định: là giá trị khởi đầu mặc định (nếu có) của thuộc tính.", "order_start": 0, "order_end": 1067, "word_count": 222}
{"parent_id": "e0e83aaf-858c-45d4-9f6e-ec0d01df021a", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ lớp", "title_path": "Tập ký hiệu UML cho biểu đồ lớp", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ lớp] ộc tính. kiểu: là kiểu dữ liệu của thuộc tính. số_đối_tượng: chỉ ra số đối tượng khai báo cho thuộc tính ứng với một mặc_định: là giá trị khởi đầu mặc định (nếu có) của thuộc tính. Giá_ trị_giới_hạn: là giới hạn các giá trị cho thuộc tính (thông tin này không bắt buộc). purchaseDate:Date[1] =”01-01-2000” (Saturday) • Phương thức (method): các phương thức trong UML được biểu diễn theo cấu trúc chung như sau [UNG]: phạm_vi tên(danh_s ách_tham_số): kiểu_trả_lại { ki ểu_ph ương_thức} Trong đó: visibility biểu diễn phạm vi cho phương thức. Giống như đối với thuộc tính, có ba dạng kiểu xác định cơ bản cho phương thức là: • +: phương thức kiểu public • #: phương thức kiểu protected • -: phương thức kiểu private • ~: phương thức được phép truy nhập tới từ các lớp trong cùng package tên là xâu ký tự xác định tên của phương thức. kiểu_trả_lại: chỉ ra kiểu giá trị trả về của phương thức. danh_sách_tham_số: biểu diễn danh sách các tham số trong khai báo của phương thức. Mỗi tham số được biểu diễn dưới dạng chung: tên tham số: kiểu giá trị = giá trị mặc định.", "order_start": 1067, "order_end": 2129, "word_count": 201}
{"parent_id": "e0e83aaf-858c-45d4-9f6e-ec0d01df021a", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ lớp", "title_path": "Tập ký hiệu UML cho biểu đồ lớp", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ lớp] g thức. danh_sách_tham_số: biểu diễn danh sách các tham số trong khai báo của phương thức. Mỗi tham số được biểu diễn dưới dạng chung: tên tham số: kiểu giá trị = giá trị mặc định. ki ểu_ph ương_thức: không bắt buộc, cho biết kiểu phương thức. Phương thức có thể nhận một trong các kiểu đặc biệt sau: abstract: phương thức kiểu trừu tượng query: phương thức kiểu truy vấn. Ví dụ một khai báo phương thức cho một lớp: generatePurchaseList(prodID:int): String", "order_start": 2129, "order_end": 2586, "word_count": 83}
{"parent_id": "fbea7065-a545-4ab6-835b-4b76ef76d13f", "subject": "Phantichthietkehttt", "section": "• Các kiểu lớp trong UML", "title_path": "• Các kiểu lớp trong UML", "content": "[Phantichthietkehttt / • Các kiểu lớp trong UML] UML định nghĩa một số kiểu lớp đăc biệt dựa trên vai trò của nó trong biểu đồ lớp. Ngoài kiểu lớp thông thường đã trình bày ở trên, UML còn định nghĩa một số kiểu lớp bổ sung gồm: Lớp thực thể: là lớp đại diện cho các thực thể chứa thông tin về các đối tượng xác định nào đó. Lớp biên (lớp giao diện): là lớp nằm ở ranh giới giữa hệ thống với môi trường bên ngoài, thực hiện vai trò nhận yêu cầu trực tiếp từ các tác nhân và chuyển các yêu cầu đó cho các lớp bên trong hệ thống. Lớp điều khiển: thực hiện các chức năng điều khiển hoạt động của hệ thống ứng với các chức năng cụ thể nào đó với một nhóm các lớp biên hoặc lớp thực thể xác định. Lớp thực thể Lớp biên (lớp giao diện) 3 Lớp điều khiển", "order_start": 0, "order_end": 697, "word_count": 155}
{"parent_id": "dfaec1ea-5704-4792-9450-9b824e0c5d50", "subject": "Phantichthietkehttt", "section": "• Các mối quan hệ trong biểu đồ lớp", "title_path": "• Các mối quan hệ trong biểu đồ lớp", "content": "[Phantichthietkehttt / • Các mối quan hệ trong biểu đồ lớp] Giữa các lớp có các dạng quan hệ cơ bản như sau: Quan hệ kết hợp (Association): Một kết hợp (association) là một sự nối kết giữa các lớp, cũng có nghĩa là sự nối kết giữa các đối tượng của các lớp này. Trong UML, một quan hệ đượcấnc định nhằm mô tả một tập hợp các liên kết (links), tức là một sự liên quan về ngữ nghĩa (semantic connection) giữa một nhóm các đối tượng được biểu diễn bởi các lớp tương ứng. Mặc định, quan hệ kết hợp được biểu diễn bởi đoạn thẳng 2 chiều nối 2 đối tượng và có thể kèm theo ngữ nghĩa của quan hệ tại hai đầu của đoạn thẳng. Khái quát hóa (Generalization): Khái quát hóa là mối quan hệ giữa một lớp có các đặc trưng mang tính khái quát cao hơn và một lớp có tính chất đặc biệt hơn. Trong sơ đồ lớp, mối quan hệ khái quát hóa chính là sự kế thừa của một lớp từ lớp khác. Quan hệ khái quát hoá được biểu diễn bằng một mũi tên có tam giác rỗng gắn ở đầu. Quan hệ cộng hợp (Aggregation): là dạng quan hệ mô tả một lớp A là một phần của lớp B và lớp A có thể tồn tại độc lập. Quan hệ cộng hợp được biểu diễn bằng một mũi tên gắn hình thoi rỗng ở đầu hướng về lớp bao hàm.", "order_start": 0, "order_end": 1098, "word_count": 244}
{"parent_id": "dfaec1ea-5704-4792-9450-9b824e0c5d50", "subject": "Phantichthietkehttt", "section": "• Các mối quan hệ trong biểu đồ lớp", "title_path": "• Các mối quan hệ trong biểu đồ lớp", "content": "[Phantichthietkehttt / • Các mối quan hệ trong biểu đồ lớp] dạng quan hệ mô tả một lớp A là một phần của lớp B và lớp A có thể tồn tại độc lập. Quan hệ cộng hợp được biểu diễn bằng một mũi tên gắn hình thoi rỗng ở đầu hướng về lớp bao hàm. Quan hệ gộp (Composition): Một quan hệ gộp biểu diễn một quan hệ kiểu tổng thể-bộ phận. Lớp A có quan hệ gộp với lớp B nếu lớp A là một phần của lớp B và sự tồn tại của đối tượng lớp B điều khiển sự tồn tại của đối tượng lớp A. Quan hệ này được biểu diễn bởi một mũi tên gắn hình thoi đặc ở đầu. Quan hệ phụ thuộc (Dependency): Phụ thuộc là mối quan hệ giữa hai lớp đối tượng: một lớp đối tượng A có tính độc lập và một lớp đối tượng B phụ thuộc vào A; một sự thay đổi của A sẽ ảnh hưởng đến lớp phụ thuộc B. Quan hệ thực thi (Realization): biểu diễn mối quan hệ ngữ nghĩa giữa các thành phần của biểu đồ lớp, trong đó một thành phần mô tả một công việc dạng hợp đồng và thành phần còn lại thực hiện hợp đồng đó. Thông thường lớp thực hiện hợp đồng có thể là các giao diện. Bảng 1.4 tổng kết các phần tử mô hình UML được sử dụng trong mô hình lớp, ý nghĩa và ký hiệu tương ứng trong các biểu đồ.", "order_start": 1098, "order_end": 2173, "word_count": 248}
{"parent_id": "bdd563ed-4cc6-431f-8154-7ebf22ad3f62", "subject": "Phantichthietkehttt", "section": "c. Biểu đồ trạng thái Ý nghĩa", "title_path": "c. Biểu đồ trạng thái Ý nghĩa", "content": "[Phantichthietkehttt / c. Biểu đồ trạng thái Ý nghĩa] Biểu đồ trạng thái được sử dụng để biểu diễn các trạng thái và sự chuyển tiếp giữa các trạng thái của các đối tượng trong một lớp xác định. Thông thường, mỗi lớp sẽ có một biểu đồ trạng thái (trừ lớp trừu tượng là lớp không có đối tượng). Biểu đồ trạng thái được biểu diễn dưới dạng máy trạng thái hữu hạn với các trạng thái và sự chuyển tiếp giữa các trạng thái đó. Có hai dạng biểu đồ trạng thái: • Biểu đồ trạng thái cho một use case: mô tả các trạng thái và chuyển tiếp trạng thái của một đối tượng thuộc một lớp nào đó trong hoạt động của một use case cụ thể. Biểu đồ trạng thái hệ thống mô tả tất cả các trạng thái của một đối tượng trong toàn bộ hoạt động của cả hệ thống.", "order_start": 0, "order_end": 679, "word_count": 148}
{"parent_id": "520ae1c1-624c-443e-96d9-dec3009b8356", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ trạng thái", "title_path": "Tập ký hiệu UML cho biểu đồ trạng thái", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ trạng thái] Các thành phần trong một biểu đồ trạng thái bao gồm: Trạng thái (state). Bên trong các trạng thái có thể miêu tả các biến trạng thái hoặc các hành động (action) tương ứng với trạng thái đó. Trạng thái con (substate): là một trạng thái chứa bên trong một trạng thái khác. Trạng thái có nhiều trạng thái con gọi là trạng thái tổ hợp. • Trạng thái khởi đầu (initial state): trạng thái đầu tiên khi kích hoạt đối tượng. • Trạng thái kết thúc (final state): kết thúc vòng đời đối tượng. • Các chuyển tiếp (transition): biểu diễn các chuyển đổi giữa các trạng thái. • Sự kiện (event): sự kiện tác động gây ra sự chuyển đổi trạng thái. Mỗi sự kiện được đi kèm với các điều kiện (guard) và các hành động (action). Trong biểu đồ trạng thái của UML, một số loại sự kiện sau đây sẽ được xác định: • Sự kiện gọi (call event): Yêu cầu thực hiện một hành động (một phương thức) • Sự kiện tín hiệu (signal event): Gửi thông điệp (chứa các giá trị thuộc tính tham số liên quan) giữa các trạng thái.", "order_start": 0, "order_end": 982, "word_count": 198}
{"parent_id": "520ae1c1-624c-443e-96d9-dec3009b8356", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ trạng thái", "title_path": "Tập ký hiệu UML cho biểu đồ trạng thái", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ trạng thái] all event): Yêu cầu thực hiện một hành động (một phương thức) • Sự kiện tín hiệu (signal event): Gửi thông điệp (chứa các giá trị thuộc tính tham số liên quan) giữa các trạng thái. • Sự kiện thời gian (time event): Biểu diễn quá trình chuyển tiếp theo thời gian, thường kèm theo từ mô tả thời gian cụ thể. Các phần tử mô hình UML và ký hiệu tương ứng cho biểu đồ trạng thái được tổng kết như trong Bảng 1.5.", "order_start": 982, "order_end": 1389, "word_count": 85}
{"parent_id": "761594ca-b2f9-4e01-8d4a-0266795d1642", "subject": "Phantichthietkehttt", "section": "d. Biểu đồ tương tác dạng tuần tự", "title_path": "d. Biểu đồ tương tác dạng tuần tự", "content": "[Phantichthietkehttt / d. Biểu đồ tương tác dạng tuần tự] Các biểu đồ tương tác biểu diễn mối liên hệ giữa các đối tượng trong hệ thống và giữa các đối tượng với các tác nhân bên ngoài. Có hai loại biểu đồ tương tác: Biểu đồ tuần tự và biểu đồ cộng tác.", "order_start": 0, "order_end": 195, "word_count": 44}
{"parent_id": "709154f9-ed9f-443c-8f2e-8dea319cc239", "subject": "Phantichthietkehttt", "section": "Ý nghĩa", "title_path": "Ý nghĩa", "content": "[Phantichthietkehttt / Ý nghĩa] Biểu đồ tuần tự: Biểu diễn mối quan hệ giữa các đối tượng, giữa các đối tượng và tác nhân theo thứ tự thời gian. Biểu đồ tuần tự nhấn mạnh thứ tự thực hiện của các tương tác.", "order_start": 0, "order_end": 174, "word_count": 39}
{"parent_id": "ed47bf72-dd25-4ee2-96fe-48f36a01ff7d", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ tuần tự", "title_path": "Tập ký hiệu UML cho biểu đồ tuần tự", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ tuần tự] Các thành phần cơ bản của một biểu đồ tuần tự là: Các đối tượng (object): được biểu diễn bởi các hình chữ nhật, bên trong là tên của đối tượng. Cách viết chung của đối tượng là: tên đối tượng: tên lớp. Nếu chỉ viết: tên_lớp thì có nghĩa là bất cứ đối tượng nào của lớp tương ứng đó. Trong biểu đồ tuần tự, không phải các đối tượng đều xuất hiện ở trên cùng của biểu đồ mà chúng chỉ xuất hiện (về mặt thời gian) khi thực sự tham gia vào tương tác. Các message: được biểu diễn bằng các mũi tên hướng từ đối tượng gửi sang đối tượng nhận. Tên các message có thể biểu diễn dưới dạng phi hình thức (như các thông tin trong kịch bản) hoặc dưới dạng hình thức (với dạng giống như các phương thức). Biểu đồ tuần tự cho phép có các message từ một đối tượng tới chính bản thân nó. Trong biểu đồ tuần tự có thể có nhiều loại message khác nhau tuỳ theo mục đích sử dụng và tác động của message đến đối tượng. Các dạng message được tổng kết trong Bảng 1.6 dưới đây: • Đường lifeline: là một đường kẻ nối dài phía dưới đối tượng, mô tả quá trình của đối tượng trong tương tác thuộc biểu đồ.", "order_start": 0, "order_end": 1076, "word_count": 228}
{"parent_id": "ed47bf72-dd25-4ee2-96fe-48f36a01ff7d", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ tuần tự", "title_path": "Tập ký hiệu UML cho biểu đồ tuần tự", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ tuần tự] Các dạng message được tổng kết trong Bảng 1.6 dưới đây: • Đường lifeline: là một đường kẻ nối dài phía dưới đối tượng, mô tả quá trình của đối tượng trong tương tác thuộc biểu đồ. Chú thích: biểu đồ tuần tự cũng có thể có chú thích để người đọc dễ dàng hiểu được nội dung của biểu đồ đó.", "order_start": 1076, "order_end": 1363, "word_count": 62}
{"parent_id": "63b2e447-f46f-43e0-b1b6-964c814e43a9", "subject": "Phantichthietkehttt", "section": "e. Biểu đồ tương tác dạng cộng tác Ý nghĩa", "title_path": "e. Biểu đồ tương tác dạng cộng tác Ý nghĩa", "content": "[Phantichthietkehttt / e. Biểu đồ tương tác dạng cộng tác Ý nghĩa] Biểu đồ cộng tác: Là biểu đồ tương tác biểu diễn mối quan hệ giữa các đối tượng; giữa các đối tượng và tác nhân nhấn mạnh đến vai trò của các đối tượng trong tương tác. Biểu đồ cộng tác cũng có các messgage với nội dung tương tự như trong biểu đồ tuần tự. Tuy nhiên, các đối tượng được đặt một cách tự do trong không gian của biểu đồ và không có đường life line cho mỗi đối tượng. Các message được đánh số thể hiện thứ tự thời gian.", "order_start": 0, "order_end": 432, "word_count": 94}
{"parent_id": "fbe7f365-646b-4a66-986f-3fa6dd3eab61", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ cộng tác", "title_path": "Tập ký hiệu UML cho biểu đồ cộng tác", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ cộng tác] Các thành phần cơ bản của một biểu đồ cộng tác là: Các đối tượng: được biểu diễn bởi các hình chữ nhật, bên trong là tên của đối tượng. Cách viết chung của đối tượng là: tên đối tượng: tên lớp. Trong biểu đồ cộng tác, các đối tượng tham gia tương tác luôn xuất hiện tại một vị trí xác định. Các liên kết: giữa hai đối tượng có tương tác sẽ có một liên kết nối 2 đối tượng đó. Liên kết này không có chiều. • Các message: được biểu diễn bằng các mũi tên hướng từ đối tượng gửi sang đối tượng nhận bên cạnh liên kết giữa 2 đối tượng đó. Trong biểu đồ cộng tác, các message được đánh số thứ tự theo thứ tự xuất hiện trong kịch bản mô tả use case tương ứng.", "order_start": 0, "order_end": 652, "word_count": 143}
{"parent_id": "ae2a9393-75b4-47be-b4d1-c1ace5643363", "subject": "Phantichthietkehttt", "section": "f. Biểu đồ hoạt động Ý nghĩa", "title_path": "f. Biểu đồ hoạt động Ý nghĩa", "content": "[Phantichthietkehttt / f. Biểu đồ hoạt động Ý nghĩa] Biểu đồ hoạt động biểu diễn các hoạt động và sự đồng bộ, chuyển tiếp các hoạt động của hệ thống trong một lớp hoặc kết hợp giữa các lớp với nhau trong một chức năng cụ thể. Biểu đồ hoạt động có thể được sử dụng cho nhiều mục đích khác nhau, ví dụ như: • Để xác định các hành động phải thực hiện trong phạm vi một phương thức. • Để xác định công việc cụ thể của một đối tượng. • Để chỉ ra một nhóm hành động liên quan của các đối tượng được thực hiện như thế nào và chúng sẽ ảnh hưởng đến những đối tượng nằm xung quanh.", "order_start": 0, "order_end": 519, "word_count": 116}
{"parent_id": "14dcbfdb-79a7-48cf-a8c2-8ea07876b3aa", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML", "title_path": "Tập ký hiệu UML", "content": "[Phantichthietkehttt / Tập ký hiệu UML] Các phần tử mô hình UML cho biểu đồ hoạt động bao gồm: Hoạt động (Activity): là một quy trình được định nghĩa rõ ràng, có thể được thực hiện bởi một hàm hoặc một nhóm đối tượng. Hoạt động được thể hiện bằng hình chữ nhật tròn cạnh. • Thanh đồng bộ hóa (Synchronisation bar): cho phép ta mở ra hoặc là đóng lại các nhánh chạy song song trong tiến trình. • Điều kiện (Guard Condition): các biểu thức logic có giá trị hoặc đúng hoặc sai. Điều kiện được thể hiện trong ngoặc vuông, ví dụ: [Customer existing]. • Các luồng (swimlane): Mỗi biểu đồ động có thể biểu diễn sự phối hợp hoạt động trong nhiều lớp khác nhau. Khi đó mỗi lớp được phân tách bởi một luồng (swimlane) riêng biệt. Các luồng này được biểu diễn đơn giản là các ô khác nhau trong biểu đồ.", "order_start": 0, "order_end": 751, "word_count": 152}
{"parent_id": "14dcbfdb-79a7-48cf-a8c2-8ea07876b3aa", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML", "title_path": "Tập ký hiệu UML", "content": "[Phantichthietkehttt / Tập ký hiệu UML] hợp hoạt động trong nhiều lớp khác nhau. Khi đó mỗi lớp được phân tách bởi một luồng (swimlane) riêng biệt. Các luồng này được biểu diễn đơn giản là các ô khác nhau trong biểu đồ. Các ký hiệu UML cho biểu đồ hoạt động được tổng kết trong Bảng sau:", "order_start": 751, "order_end": 998, "word_count": 52}
{"parent_id": "f991bc16-4618-4280-ade8-5663310553ba", "subject": "Phantichthietkehttt", "section": "g. Biểu đồ thành phần Ý nghĩa", "title_path": "g. Biểu đồ thành phần Ý nghĩa", "content": "[Phantichthietkehttt / g. Biểu đồ thành phần Ý nghĩa] Biểu đồ thành phần được sử dụng để biểu diễn các thành phần phần mềm cấu thành nên hệ thống. Một hệ phần mềm có thể được xây dựng từ đầu bằng cách sử dụng mô hình lớp như đã trình bày trong các phần trước của tài liệu, hoặc cũng có thể được tạo nên từ các thành phần sẵn có. Mỗi thành phần có thể coi như một phần mềm nhỏ hơn, cung cấp một khối dạng hộp đen trong quá trình xây dựng phần mềm lớn. Nói cách khác, các thành phần là các gói được xây dựng cho quá trình triển khai hệ thống. Các thành phần có thể là các gói ở mức cao như JavaBean, các gói thư viện liên kết động dll, hoặc các phần mềm nhỏ được tạo ra từ các thành phần nhỏ hơn như các lớp và các thư viện chức năng.", "order_start": 0, "order_end": 678, "word_count": 152}
{"parent_id": "06886df1-a770-4562-a59e-5db5844a4f82", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML", "title_path": "Tập ký hiệu UML", "content": "[Phantichthietkehttt / Tập ký hiệu UML] Tập ký hiệu UML cho biểu đồ thành phần được tổng kết trong bảng sau:", "order_start": 0, "order_end": 68, "word_count": 15}
{"parent_id": "4b1ae965-a6eb-4e0a-987c-c6fb5a19e386", "subject": "Phantichthietkehttt", "section": "h. Biểu đồ triển khai hệ thống Ý nghĩa", "title_path": "h. Biểu đồ triển khai hệ thống Ý nghĩa", "content": "[Phantichthietkehttt / h. Biểu đồ triển khai hệ thống Ý nghĩa] Biểu đồ triển khai biểu diễn kiến trúc cài đặt và triển khai hệ thống dưới dạng các nodes và các mối quan hệ giữa các node đó. Thông thường, các nodes được kết nối với nhau thông qua các liên kết truyền thông như các kết nối mạng, liên kết TCP-IP, microwave… và được đánh số theo thứ tự thời gian tương tự như trong biểu đồ cộng tác.", "order_start": 0, "order_end": 333, "word_count": 70}
{"parent_id": "638057d6-a2ec-4f3d-96a1-68f2940689f0", "subject": "Phantichthietkehttt", "section": "Tập ký hiệu UML cho biểu đồ triển khai", "title_path": "Tập ký hiệu UML cho biểu đồ triển khai", "content": "[Phantichthietkehttt / Tập ký hiệu UML cho biểu đồ triển khai] Tập ký hiệu UML cho biểu đồ triển khai hệ thống được biểu diễn trong Bảng sau:", "order_start": 0, "order_end": 78, "word_count": 17}
{"parent_id": "5dc862fd-7025-46a4-a2f7-4e1938eb16d6", "subject": "Phantichthietkehttt", "section": "2.1.1 Một số khái niệm", "title_path": "2.1.1 Một số khái niệm", "content": "[Phantichthietkehttt / 2.1.1 Một số khái niệm] Khái niệm đảm bảo chất lượng phần mềm được định nghĩa như sau : Đảm bảo chất lượng phần mềm là một tập các hoạt động đã được lập kế hoạch và có hệ thống, cần thiết để cung cấp đầy đủ sự tin cậy vào quy trình phát triển phần mềm hay quy trình bảo trì phần mềm của sản phẩm hệ thống phần mềm phù hợp với các yêu cầu chức năng kỹ thuật cũng như với các yêu cầu quản lý mà giữ cho lịch biểu và hoạt động trong phạm vi ngân sách.", "order_start": 0, "order_end": 424, "word_count": 97}
{"parent_id": "e4f20ff5-1e5a-4fbd-94e5-fb5dbd188aa6", "subject": "Phantichthietkehttt", "section": "Mục tiêu đảm bảo chất lượng phần mềm", "title_path": "Mục tiêu đảm bảo chất lượng phần mềm", "content": "[Phantichthietkehttt / Mục tiêu đảm bảo chất lượng phần mềm] Những mục tiêu đảm bảo chất lượng phần mềm tương ứng với giai đoạn phát triển và bảo trì được xác định cụ thể như sau :", "order_start": 0, "order_end": 119, "word_count": 27}
{"parent_id": "b0e08b2d-b944-4acc-8845-0aaac4f43803", "subject": "Phantichthietkehttt", "section": "- Phát triển phần mềm (hướng tiến trình)", "title_path": "- Phát triển phần mềm (hướng tiến trình)", "content": "[Phantichthietkehttt / - Phát triển phần mềm (hướng tiến trình)] 1. Đảm bảo một mức độ chấp nhận được rằng phần mềm sẽ thực hiện được các yêu cầu chức năng. 2. Đảm bảo một mức đọ cấp nhận được rằng phần mềm sẽ đáp ứng được các yêu cầu về lịch biểu và ngân sách 3. Thiết lập và quản lý các hoạt động để cải thiện và nâng cao hiệu quả của phát triển phần mềm và các hoạt động SQA.", "order_start": 0, "order_end": 313, "word_count": 73}
{"parent_id": "cd618cc9-949c-4f65-98ac-d0df33e2cd85", "subject": "Phantichthietkehttt", "section": "- Bảo trì phần mềm (hướng sản phẩm)", "title_path": "- Bảo trì phần mềm (hướng sản phẩm)", "content": "[Phantichthietkehttt / - Bảo trì phần mềm (hướng sản phẩm)] 1. Đảm bảo một mức độ chấp nhận được rằng các hoạt động bảo trì phần mềm sẽ đáp ứng được các yêu cầu chức năng. 2. Đảm bảo một mức đọ cấp nhận được rằng các hoạt động bảo trì phần mềm sẽ đáp ứng được các yêu cầu về lịch biểu và ngân sách 3. Thiết lập và quản lý các hoạt động để cải thiện và nâng cao hiệu quả của bảo trì phần mềm.", "order_start": 0, "order_end": 331, "word_count": 78}
{"parent_id": "6dc9b8af-e88c-4069-9365-10ecd4bc825b", "subject": "Phantichthietkehttt", "section": "Xác minh, thẩm định và đánh giá chất lượng", "title_path": "Xác minh, thẩm định và đánh giá chất lượng", "content": "[Phantichthietkehttt / Xác minh, thẩm định và đánh giá chất lượng] Ba khía cạnh đảm bảo chất lượng của sản phẩm phần mềm gồm Verification, Validation, và Qualification. • Verification: quá trình đánh giá một hệ thống hay một thành phần để xác định xem những sản phẩm của một pha phát triển xác định có thỏa mãn những điểu kiện được đặt gia khi bắt đầu pha đó hay không. • Validation: quá trình đánh giá một hệ thống hay một thành phần trong suốt hoặc khi kết thúc quá trình phát triển để xác định xem nó có thỏa mãn những yêu cầu đã đặc tả hay không. • Qualification: quá trình xác định một hệ thống hoặc một thành phần có phù hợp với việc sử dụng hay không. Theo những định nghĩa của IEEE, verification kiểm tra tính nhất quán của sản phẩm đang phát triển với những sản phẩm đã được phát triển ở pha trước. Khi thực hiện, người thẩm tra đi sau quy trình phát triền và giả sử rằng tất cả những pha phát triển đằng trước đã được hoàn thành một cách chính xác hoặc là như kế hoặc gốc hoặc là sau khi đã sửa chữa những sai sót được phát hiện. Validation miêu tả sự quan tâm của khách hàng, bằng cách thẩm tra những yêu cầu gốc của họ.", "order_start": 0, "order_end": 1064, "word_count": 220}
{"parent_id": "6dc9b8af-e88c-4069-9365-10ecd4bc825b", "subject": "Phantichthietkehttt", "section": "Xác minh, thẩm định và đánh giá chất lượng", "title_path": "Xác minh, thẩm định và đánh giá chất lượng", "content": "[Phantichthietkehttt / Xác minh, thẩm định và đánh giá chất lượng] nh xác hoặc là như kế hoặc gốc hoặc là sau khi đã sửa chữa những sai sót được phát hiện. Validation miêu tả sự quan tâm của khách hàng, bằng cách thẩm tra những yêu cầu gốc của họ. Qualification tập trung vào những khía cạnh hoạt động, ở đó việc bảo trì là vấn đề chính. Một thành phần phần mềm đã được phát triển và tài liệu hóa theo những chuẩn, kiểu, và cấu trúc chuyên nghiệp sẽ dễ dàng để bảo trì hơn những thành phần có code lạ. Người lên kế hoạch cần phải xác định xem những khía cạnh nào nên được sát hạnh trong mỗi hoạt động đảm bảo chất lượng phần mềm. Xác minh thường là hoạt động có tính kỹ thuật cao hơn, sử dụng những tri thức về các yêu cầu, đặc tả phần mềm. Xác nhận thường phụ thuộc vào tri thức về lĩnh vực tương ứng. Cụ thể là, tri thức về ứng dụng của phần mềm được viết. Ví dụ, xác nhận của phần mềm về máy bay yêu cầu tri thức từ kỹ sư hàng không và phi công. Cụm từ IV & V - independent verification and validation- nghĩa là xác nhận và xác minh độc lập. IV & V yêu cầu việc đánh giá phải được thực hiện bởi người không phải là lập trình viên.", "order_start": 1064, "order_end": 2130, "word_count": 232}
{"parent_id": "6dc9b8af-e88c-4069-9365-10ecd4bc825b", "subject": "Phantichthietkehttt", "section": "Xác minh, thẩm định và đánh giá chất lượng", "title_path": "Xác minh, thẩm định và đánh giá chất lượng", "content": "[Phantichthietkehttt / Xác minh, thẩm định và đánh giá chất lượng] từ IV & V - independent verification and validation- nghĩa là xác nhận và xác minh độc lập. IV & V yêu cầu việc đánh giá phải được thực hiện bởi người không phải là lập trình viên. Một số trường hợp đội IV & V thuộc dự án, hoặc thuộc cùng công ty, cũng có thể thuộc một tổ chức độc lập. Vì sự độc lập của IV & V, tiến trình thường chưa bắt đầu cho tới khi dự án kết thúc và thường được thực hiện bởi chuyên gia trong lĩnh vực hơn là người phát triển phần mềm.", "order_start": 2130, "order_end": 2589, "word_count": 102}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] Đã có nhiều tác giả nghiên cứu về các tiêu chí chất lượng phần mềm từ các yêu cầu. Theo thời gian có thể quan niệm về việc đảm bảo chất lượng phần mềm có phần thay đổi, tuy nhiên mô hình các yếu tố đảm bảo chất lượng phần mềm của McCall ra đời vào những năm 70 của thế kỷ trước vẫn còn được nhiều người nhắc đến như là cơ sở tham chiếu các yêu cầu phần mềm. Sau McCall cũng có một số mô hình được quan tâm như mô hình do Evans, Marciniak do hay mô hình của Deutsch và Willis, tuy nhiên những mô hình này chỉ bổ sung hay sửa đổi một vài yếu tố chất lượng. Theo McCall, các yếu tố chất lượng phần mềm được chia làm ba loại : - Các yếu tố hoạt động của sản phẩm bao gồm tính chính xác, tin cậy, hiệu quả, tính toàn vẹn, sử dụng được - Các yếu tố rà soát bao gồm tính bảo trì, linh hoạt, có thể test được - Các yếu tố chuyển giao bao gồm tính khả chuyển, có khả năng sử dụng lại, có khả năng giao tác.", "order_start": 0, "order_end": 897, "word_count": 202}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] sử dụng được - Các yếu tố rà soát bao gồm tính bảo trì, linh hoạt, có thể test được - Các yếu tố chuyển giao bao gồm tính khả chuyển, có khả năng sử dụng lại, có khả năng giao tác. Chi tiết các thuộc tính được phân tích như sau : (1) Các yếu tố vận hành sản phẩm : Sự chính xác, độ tin cậy, tính hiệu quả, tính toàn vẹn và khả năng sử dụng được : • Sự chính xác : Các yêu cầu về độ chính xác được xác định trong một danh sách các đầu ra cần thiết của hệ thống phần mềm, như màn hình hiển thị truy vấn số dư của khách hàng trong một hệ thống thông tin kế toán bán hàng…Các đặc tả đầu ra thường là đa chiều, một số chiều thông dụng là : o Nhiệm vụ đầu ra (ví dụ : bản in hóa đơn bán hàng, hay đèn báo động đỏ khi nhiệt độ tăng lên trên 250 độ F) o Độ chính xác yêu cầu của các đầu ra này; chúng có thể bị ảnh hưởng bất lợi bởi các tính toán không chính xác hay các dữ liệu không chính xác. o Tính đầy đủ của thông tin đầu ra; chúng có thể bị ảnh hưởng bất lợi bởi dữ liệu không đầy đủ. o Up-to-dateness của thông tin (xác định bằng thời gian giữa sự kiện và việc xem xét hệ thống phần mềm.", "order_start": 897, "order_end": 1984, "word_count": 252}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] hông tin đầu ra; chúng có thể bị ảnh hưởng bất lợi bởi dữ liệu không đầy đủ. o Up-to-dateness của thông tin (xác định bằng thời gian giữa sự kiện và việc xem xét hệ thống phần mềm. o Độ sẵn sàng của thông tin (thời gian đáp ứng : được định nghĩa là thời gian cần thiết để có được các thông tin yêu cầu) o Các chuẩn cho việc code và viết tài liệu cho hệ thống phần mềm. Độ tin cậy : Các yêu cầu về độ tin cậy giải quyết các lỗi để cung cấp dịch vụ. Chúng xác định tỷ lệ lỗi hệ thống phần mềm tối đa cho phép, các lỗi này có thể là lỗi toàn bộ hệ thống hoặc một hay nhiều chức năng riêng biệt của nó. Tính hiệu quả : Các yêu cầu về tính hiệu quả giải quyết vấn đề về các tài nguyên phần cứng cần thiết để thực hiện tất cả các chức năng của hệ thống phần mềm với sự phù hợp của tất cả các yêu cầu khác. Các tài nguyên phần cứng chính được xem xét ở đây là khả năng xử lý của máy tính (được đo bằng MIPS – triệu lệnh/giây; MHz – triệu chu kỳ/giây…); khả năng lưu trữ dữ liệu (dung lượng bộ nhớ, dung lượng đĩa – được đo bằng MBs, GBs, TBs…) và khả năng truyền dữ liệu (thường được đo bằng MBPS, GBPS ).", "order_start": 1984, "order_end": 3082, "word_count": 248}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] MHz – triệu chu kỳ/giây…); khả năng lưu trữ dữ liệu (dung lượng bộ nhớ, dung lượng đĩa – được đo bằng MBs, GBs, TBs…) và khả năng truyền dữ liệu (thường được đo bằng MBPS, GBPS ). Các yêu cầu này có thể bao gồm cả các giá trị tối đa tài nguyên phần cứng được sử dụng trong hệ thống phần mềm. Một yêu cầu khác về tính hiệu quả đó là thời gian giữa các lần phải sạc điện đối với các hệ thống nằm trên các máy tính xách tay hay các thiết bị di động. Tính toàn vẹn: Các yêu cầu về tính toàn vẹn giải quyết các vấn đề về bảo mật hệ thống phần mềm, các yêu cầu này để ngăn chặn sự truy cập trái phép, để phân biệt giữa phần lớn nhân viên chỉ được phép xem thông tin với một nhóm hạn chế những người được phép thêm và thay đổi dữ liệu… Tính khả dụng: Các yêu cầu về khả năng sử dụng được sẽ đưa ra phạm vi của tài nguyên nhân lực cần thiết để đào tạo một nhân viên mới và để vận hành hệ thống phần mềm.", "order_start": 3082, "order_end": 3977, "word_count": 202}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] đổi dữ liệu… Tính khả dụng: Các yêu cầu về khả năng sử dụng được sẽ đưa ra phạm vi của tài nguyên nhân lực cần thiết để đào tạo một nhân viên mới và để vận hành hệ thống phần mềm. (2) Các yếu tố về rà soát sản phẩm : bảo trì được, linh động và kiểm tra được : Khả năng bảo trì được : Các yêu cầu về khả năng bảo trì được sẽ xác định người dùng và nhân viên bảo trì phải nỗ lực thế nào để xác định được nguyên nhân của các lỗi phần mềm, để sửa lỗi và để xác nhận việc sửa lỗi thành công. Các yêu cầu của yếu tố này nói tới cấu trúc modul của phần mềm, tài liệu chương trình nội bộ và hướng dẫn sử dụng của lập trình viên… Tính linh động : Các yêu cầu về tính linh động cũng bao gồm cả các khả năng và nỗ lực cần thiết để hỗ trợ các hoạt động bảo trì.", "order_start": 3977, "order_end": 4726, "word_count": 176}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] ình nội bộ và hướng dẫn sử dụng của lập trình viên… Tính linh động : Các yêu cầu về tính linh động cũng bao gồm cả các khả năng và nỗ lực cần thiết để hỗ trợ các hoạt động bảo trì. Chúng gồm các nguồn lực (man-day) cần thiết để thích nghi với một gói phần mềm, với các khách hàng trong cùng nghề, với các mức độ hoạt động khác nhau, với các loại sản phẩm khác nhau…Các yêu cầu về yếu tố này cũng hỗ trợ các hoạt động bảo trì trở nên hoàn hảo, như thay đối và bổ sung vào phần mềm để tăng dịch vụ của nó và để thích nghi với các thay đổi trong môi trường thương mại và kỹ thuật của công ty. Khả năng test được : Các yêu cầu về khả năng kiểm tra được nói tới việc kiểm tra sự vận hành có tốt hay không của các hệ thống thông tin. Các yêu cầu về khả năng kiểm tra được liên quan tới các tính năng đặc biệt trong chương trình giúp người tester dễ dàng thực hiện công việc của mình hơn, ví dụ như đưa ra các kết quả trung gian.", "order_start": 4726, "order_end": 5648, "word_count": 207}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] khả năng kiểm tra được liên quan tới các tính năng đặc biệt trong chương trình giúp người tester dễ dàng thực hiện công việc của mình hơn, ví dụ như đưa ra các kết quả trung gian. Các yêu cầu về khả năng kiểm tra được liên quan tới vận hành phần mềm bao gồm các chuẩn đoán tự động được thực hiện bởi hệ thống phần mềm trước khi bắt đầu hệ thống, để tìm hiểu xem có phải tất cả các thành phần của hệ thống phần mềm đều làm việc tốt hay không, và để có một bản báo cáo về các lỗi đã được phát hiện. Một loại khác của yêu cầu này là việc check các dự đoán tự động, được các kỹ thuật viên bảo trì sử dụng để phát hiện nguyên nhân gây lỗi phần mềm. (3) Các yếu tố về chuyển giao sản phẩm : tính lưu động (khả năng thích nghi với môi trường), khả năng tái sử dụng và khả năng cộng tác được : Tính lưu động : các yêu cầu về tính lưu động nói tới khả năng thích nghi của hệ thống phần mềm với các môi trường khác, bao gồm phần cứng khác, các hệ điều hành khác… Các yêu cầu này đòi hỏi các phần mềm cơ bản có thể tiếp tục sử dụng độc lập hoặc đồng thời trong các trường hợp đa dạng.", "order_start": 5648, "order_end": 6721, "word_count": 241}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] trường khác, bao gồm phần cứng khác, các hệ điều hành khác… Các yêu cầu này đòi hỏi các phần mềm cơ bản có thể tiếp tục sử dụng độc lập hoặc đồng thời trong các trường hợp đa dạng. Khả năng tái sử dụng : Các yêu cầu về khả năng tái sử dụng nói tới việc sử dụng các modul phần mềm trong một dự án mới đang được phát triển mà các modul này ban đầu được thiết kế cho một dự án khác. Các yêu cầu này cũng cho phép các dự án tương lai có thể sử dụng một modul đã có hoặc một nhóm các modul hiện đang được phát triển. Tái sử dụng phần mềm sẽ tiết kiệm tài nguyên phát triển, rút ngắn thời gian phát triển và tạo ra các moduls chất lượng cao hơn. Chất lượng modul cao hơn là dựa trên giả định rằng hầu hết các lỗi phần mềm đều được phát hiện bởi các hoạt động đảm bảo chất lượng phần mềm thực hiện trên phần mềm ban đầu, bởi những người sử dụng phần mềm ban đầu và trong suốt những lần tái sử dụng trước của nó. Các vấn đề về tái sử dụng phần mềm đã trở thành một phần trong chuẩn công nghiệp phần mềm (IEEE,1999).", "order_start": 6721, "order_end": 7728, "word_count": 223}
{"parent_id": "6123392d-bb72-4a78-9edc-b0dfe0e20783", "subject": "Phantichthietkehttt", "section": "2.1.2 Các tiêu chí chất lượng", "title_path": "2.1.2 Các tiêu chí chất lượng", "content": "[Phantichthietkehttt / 2.1.2 Các tiêu chí chất lượng] ời sử dụng phần mềm ban đầu và trong suốt những lần tái sử dụng trước của nó. Các vấn đề về tái sử dụng phần mềm đã trở thành một phần trong chuẩn công nghiệp phần mềm (IEEE,1999). Khả năng cộng tác : Các yêu cầu về khả năng cộng tác tập trung vào việc tạo ra các giao diện với các hệ thống phần mềm khác. Các yêu cầu về khả năng cộng tác có thể xác định tên của phần mềm với giao diện bắt buộc. Chúng cũng có thể xác định cấu trúc đầu ra được chấp nhận như một tiêu chuẩn trong một ngành công nghiệp cụ thể hoặc một lĩnh vực ứng dụng.", "order_start": 7728, "order_end": 8263, "word_count": 119}
{"parent_id": "53b68124-46f4-46b0-a57f-0b13d58fc621", "subject": "Phantichthietkehttt", "section": "Các tiêu chí chất lượng ảnh hưởng tới hoạt động đảm bảo chất lượng phần mềm như nào", "title_path": "Các tiêu chí chất lượng ảnh hưởng tới hoạt động đảm bảo chất lượng phần mềm như nào", "content": "[Phantichthietkehttt / Các tiêu chí chất lượng ảnh hưởng tới hoạt động đảm bảo chất lượng phần mềm như nào] Những hoạt động đảm bảo chất lượng là hướng quy trình, nói cách khác, có liên kết tới sự hoàn thành của một pha dự án, sự hoàn tất một mốc dự án, và nhiều hơn nữa. Những hoạt động đảm bảo chất lượng được tích hợp vào trong kế hoạch phát triển. Những người lên kế hoặc đảm bảo chất lượng cho một dự án cần xác định: • Danh sách những hoạt động đảm bảo chất lượng cần thiết cho dự án. • Với mỗi hoạt động đảm bảo chất lượng: o Thời gian. o Loại hoạt động đảm bảo chất lượng áp dụng. o Người thực hiện hoạt động và tài nguyên yêu cầu. o Những tài nguyên yêu cầu cho việc khắc phục những nhược sai sót và những thay đổi. Cường độ của những hoạt động đảm bảo chất lượng đã được lên kế hoạch được chỉ ra bởi số những hoạt động yêu cầu. Những yếu tố dự án và nhóm ảnh hưởng tới cường độ như sau: Yếu tố dự án: • Độ lớn của dự án. • Sự phức tạp và khó của kỹ thuật. • Phạm vi của những thành phần sử dụng lại. Hậu quả nếu dự án bị lỗi. Yếu tố nhóm: • Trình độ chuyên môn của những thành viên trong nhóm. • Sự quen thuộc của nhóm với dự án và Kinh nghiệm của nhóm trong lĩnh vực.", "order_start": 0, "order_end": 1070, "word_count": 241}
{"parent_id": "53b68124-46f4-46b0-a57f-0b13d58fc621", "subject": "Phantichthietkehttt", "section": "Các tiêu chí chất lượng ảnh hưởng tới hoạt động đảm bảo chất lượng phần mềm như nào", "title_path": "Các tiêu chí chất lượng ảnh hưởng tới hoạt động đảm bảo chất lượng phần mềm như nào", "content": "[Phantichthietkehttt / Các tiêu chí chất lượng ảnh hưởng tới hoạt động đảm bảo chất lượng phần mềm như nào] ử dụng lại. Hậu quả nếu dự án bị lỗi. Yếu tố nhóm: • Trình độ chuyên môn của những thành viên trong nhóm. • Sự quen thuộc của nhóm với dự án và Kinh nghiệm của nhóm trong lĩnh vực. • Tính sẵn sàng của những thành viên có thể trợ giúp nhóm. • Sự hiểu biết giữa những thành viên trong nhóm, hay nói cách khác là số thành viên mới trong nhóm.", "order_start": 1070, "order_end": 1409, "word_count": 75}
{"parent_id": "29bd8127-32c8-408e-8f62-d72579165534", "subject": "Phantichthietkehttt", "section": "Chất lượng đặc tả", "title_path": "Chất lượng đặc tả", "content": "[Phantichthietkehttt / Chất lượng đặc tả] Đặc tả không có các hoạt động trước nó, và tất cả các hoạt động khác đều theo sau đặc tả. Vì vậy, nếu đặc tả không tốt thì phân tích, thiết kế cũng sẽ không tốt, và dẫn tới phát triển, bảo trì của 1 phần mềm kém hơn, hoặc thậm chí một phần mềm lỗi, và công sức bỏ ra để đảm bảo chất lượng thành lãng phí. Vì vậy, điều tối quan trọng là đặc tả phải đầy đủ và được định nghĩa tốt. Đặc tả thường gồm 6 nội dung sau: • Chức năng: đặc tả các chức năng nào sẽ được phát triển • Phi chức năng: (a) Khả năng chịu tải: đặc tả khả năng chịu tải của hệ thống (ví dụ: 100 người cùng thao tác) (b) Intended use: đặc tả yêu cầu hoặc các yêu cầu mà sản phẩm cần thoả mãn. (c) Tính tin cậy: đặc tả thời gian mà sản phẩm có thể hoạt động tốt trước khi cần bảo trì và phù hợp với yêu cầu của người dùng.", "order_start": 0, "order_end": 785, "word_count": 180}
{"parent_id": "29bd8127-32c8-408e-8f62-d72579165534", "subject": "Phantichthietkehttt", "section": "Chất lượng đặc tả", "title_path": "Chất lượng đặc tả", "content": "[Phantichthietkehttt / Chất lượng đặc tả] yêu cầu hoặc các yêu cầu mà sản phẩm cần thoả mãn. (c) Tính tin cậy: đặc tả thời gian mà sản phẩm có thể hoạt động tốt trước khi cần bảo trì và phù hợp với yêu cầu của người dùng. (d) Tính an toàn: đặc tả ngưỡng an toàn cho con người và đặc tính khi sử dụng phần mềm (e) Tính bảo mật: đặc tả các mối đe doạ mà sản phẩm cần chuẩn bị Làm thế nào để đảm bảo đặc tả là đầy đủ và chính xác? Với đặc tả chức năng, người phân tích nghiệp vụ, hoặc người phân tích hệ thống có thể đảm đương nhiệm vụ này. Với đặc tả phi chức năng, cần xây dựng các chuẩn nội bộ hoặc áp dụng các chuẩn chuyên nghiệp.", "order_start": 785, "order_end": 1374, "word_count": 135}
{"parent_id": "d531b413-a393-408b-bd82-52fe95510ef1", "subject": "Phantichthietkehttt", "section": "Đảm bảo chất lượng đặc tả", "title_path": "Đảm bảo chất lượng đặc tả", "content": "[Phantichthietkehttt / Đảm bảo chất lượng đặc tả] Trong công nghiệp phần mềm, đặc tả được xem như là đặc tả của người dùng. Nghĩa là, người dùng cuối coi đây như các yêu cầu của phần mềm mong muốn. Các tình huống sau có thể được dùng để lấy đặc tả người dùng: Người phân tích nghiệp vụ tìm hiểu, viết báo cáo, xây dựng đặc tả. Họ cần: • Gặp tất cả người dùng cuối để lấy các yêu cầu và lưu ý của họ • Gặp tất cả người đứng đầu các bộ phận để lấy yêu cầu và lưu ý của họ Gặp người quản lý để lấy yêu cầu và lưu ý của họ Tổng hợp các yêu cầu và trình bày để người dùng cuối, người đứng đầu các bộ phận và người quản lý phản hồi, nhận xét • Chỉnh sửa theo phản hồi, nhận xét và xây dựng bản đặc tả chuẩn Có sẵn một bản yêu cầu người dùng như một phần của bản đề xuất Yêu cầu tham khảo một sản phẩm tương tự và cung cấp các tuỳ chỉnh riêng cho khách hàng. Căn cứ vào các tình huống trên, khi một đặc tả đã sẵn sàng, các hoạt động đảm bảo chất lượng sẽ được thực hiện. Nhiệm vụ của bước đảm bảo chất lượng trong giai đoạn này là đảm bảo các đặc tả đã đầy đủ và phủ hết cả các yêu cầu chức năng và yêu cầu phi chức năng.", "order_start": 0, "order_end": 1064, "word_count": 247}
{"parent_id": "d531b413-a393-408b-bd82-52fe95510ef1", "subject": "Phantichthietkehttt", "section": "Đảm bảo chất lượng đặc tả", "title_path": "Đảm bảo chất lượng đặc tả", "content": "[Phantichthietkehttt / Đảm bảo chất lượng đặc tả] chất lượng sẽ được thực hiện. Nhiệm vụ của bước đảm bảo chất lượng trong giai đoạn này là đảm bảo các đặc tả đã đầy đủ và phủ hết cả các yêu cầu chức năng và yêu cầu phi chức năng. Các công cụ có thể sử dụng để đảm bảo chất lượng cho đặc tả là: Tài liệu quy trình: chi tiết phương pháp để lấy, phát triển, phân tích và tổng hợp đặc tả Các chuẩn (standard), hướng dẫn (guideline), các biểu mẫu (template): xác định tập tối thiểu các đặc tả cần phải xây dựng Danh sách kiểm tra (checklist): giúp phân tích để đảm bảo tính đầy đủ của đặc tả Sử dụng các công cụ này, người phân tích có thể phát triển đặc tả đầy đủ và rõ ràng để sẵn sàng cho hoạt động tiếp theo (phân tích, thiết kế) và đảm bảo chất lượng cho đặc tả. Các công cụ cũng có thể được dùng để đảm bảo chất lượng đặc tả là rà soát chính thức và rà soát ngang hàng.", "order_start": 1064, "order_end": 1885, "word_count": 181}
{"parent_id": "10437a01-ec3f-44cd-b051-7063956714aa", "subject": "Phantichthietkehttt", "section": "Chất lượng phân tích, thiết kế", "title_path": "Chất lượng phân tích, thiết kế", "content": "[Phantichthietkehttt / Chất lượng phân tích, thiết kế] Nếu phân tích, thiết kế không tốt, sản phẩm sẽ lỗi thậm chí cả khi đặc tả được làm tốt. Phân tích gồm xác định kiến trúc, chức năng, …, cách tiếp cận cho các yêu cầu về tính linh hoạt, tính di động, tính bảo trì được,… Thiết kế gồm thiết kế cơ sở dữ liệu, thiết kế giao diện, báo cáo… Phân tích, thiết kế gồm các thành phần sau: 1. Thiết kế chức năng 2. Kiến trúc phần mềm 3. Điều hướng (navigation) 4. Thiết kế cơ sở dữ liệu 5. Nền tảng phát triển 6. Nền tảng triển khai 7. Thiết kế giao diện người dùng 8. Thiết kế báo cáo 9. Bảo mật 10. Khả năng chịu lỗi 11. Khả năng chịu tải 12. Tính tin cậy 13. Tính bảo trì được 14. Tính hiệu quả và tính đồng thời 15. Kết nối 16. Đặc tả chương trình 17. Thiết kế kiểm thử Ta cần người thiết kế có trình độ để đảm bảo thiết kế đúng đã được chọn và triển khai. Các chuẩn thiết kế phần mềm là cần thiết, có thể là được xây dựng nội bộ, hoặc lấy từ một tổ chức chuyên nghiệp. Các chuẩn này hỗ trợ người thiết kế để đạt được bản thiết kế tốt nhất có thể.", "order_start": 0, "order_end": 990, "word_count": 221}
{"parent_id": "10437a01-ec3f-44cd-b051-7063956714aa", "subject": "Phantichthietkehttt", "section": "Chất lượng phân tích, thiết kế", "title_path": "Chất lượng phân tích, thiết kế", "content": "[Phantichthietkehttt / Chất lượng phân tích, thiết kế] thiết kế phần mềm là cần thiết, có thể là được xây dựng nội bộ, hoặc lấy từ một tổ chức chuyên nghiệp. Các chuẩn này hỗ trợ người thiết kế để đạt được bản thiết kế tốt nhất có thể. Thông thường, đầu pha phân tích cần lựa chọn cách thức thiết kế và quyết định các yếu tố chung như số lượng tầng, nền tảng kỹ thuật sử dụng, kết nối trong phần mềm… Bằng cách này, người thiết kế có thể đưa ra giải pháp tốt nhất có thể cho dự án. Một bản mẫu thiết kế có thể được xây dựng và đánh giá. Ở cuối pha phân tích, cần bước đánh giá dựa trên các chuẩn sẵn có để đảm bảo phân tích đạt yêu cầu của dự án. Bản phân tích cần được rà soát ngang hàng, rà soát từ chuyên gia, từ nhà quản lý trước khi chuyển sang thiết kế chi tiết.", "order_start": 990, "order_end": 1703, "word_count": 160}
{"parent_id": "13555fda-cc0c-45f8-805c-f8d927ecb163", "subject": "Phantichthietkehttt", "section": "Đảm bảo chất lượng phân tích, thiết kế", "title_path": "Đảm bảo chất lượng phân tích, thiết kế", "content": "[Phantichthietkehttt / Đảm bảo chất lượng phân tích, thiết kế] Pha phân tích, thiết kế nhận đầu vào là sản phẩm của pha đặc tả, từ đó xây dựng tài liệu phân tích thiết kế. Tài liệu này sẽ được lập trình viên sử dụng để lập trình ra phần mềm đặt yêu cầu. Phân tích – còn gọi là thiết kế mức cao: đặc tả chức năng phần mềm, đặc tả yêu cầu phần mềm, kiến trúc phần mềm. Ở bước này, kiến trúc tổng thể của phần mềm, bao gồm số tầng, số module, cách tiếp cận để đạt được chức năng, thiết kế cơ sở dữ liệu, tính tin cậy, tính bảo mật, … sẽ được xác định và tài liệu hoá. Tài liệu này được sử dụng cho pha thiết kế chi tiết. Thiết kế - còn gọi là thiết kế chi tiết: chi tiết của từng đơn vị chương trình, màn hình, báo cáo, bảng,… được xây dựng và lâp trình viên có thể sử dụng nó để lâp trình cho phần mềm.", "order_start": 0, "order_end": 737, "word_count": 168}
{"parent_id": "13555fda-cc0c-45f8-805c-f8d927ecb163", "subject": "Phantichthietkehttt", "section": "Đảm bảo chất lượng phân tích, thiết kế", "title_path": "Đảm bảo chất lượng phân tích, thiết kế", "content": "[Phantichthietkehttt / Đảm bảo chất lượng phân tích, thiết kế] iết kế - còn gọi là thiết kế chi tiết: chi tiết của từng đơn vị chương trình, màn hình, báo cáo, bảng,… được xây dựng và lâp trình viên có thể sử dụng nó để lâp trình cho phần mềm. Các công cụ để đảm bảo chất lượng phân tích, thiết kế gồm: Tài liệu quy trình: chi tiết phương thức để thiết kế được xem xét, tiêu chí để lựa chọn các giải pháp cho dự án, cho pha phân tích Chuẩn, hướng dẫn, các biểu mẫu: xác định kiến trúc cùng với ưu, nhược của nó, phương thức để có danh sách các lựa chọn thay thế,… Danh sách kiểm tra (Checklist): giúp người thiết kế đảm bảo thiết kế là đầy đủ và chính xác", "order_start": 737, "order_end": 1329, "word_count": 129}
{"parent_id": "8b3c0b29-38c9-44eb-beec-844668c07655", "subject": "Phantichthietkehttt", "section": "Chất lượng lập trình", "title_path": "Chất lượng lập trình", "content": "[Phantichthietkehttt / Chất lượng lập trình] Thông thường, pha phát triển thường có các hoạt động sau: Tạo cơ sở dữ liệu và các bảng (table) Phát triển các thư viện kết nối động cho các hoạt động chung Phát triển giao diện Phát triển báo cáo Phát triển kế hoạch test đơn vị Phát triển các thành phần với các khía cạnh khác như bảo mật, tính hiệu quả, khả năng chịu lỗi,.. Chất lượng phát triển tốt đạt được bằng cách cung cấp hướng dẫn lập trình cho ngôn ngôn ngữ sử dụng. Hướng dẫn này cần chứa cách đặt tên, cấu trúc code, cách lập trình hiệu quả, cách ngăn ngừa lỗi và giúp lập trình viên viết code đáng tin cậy và không mắc lỗi. Tất nhiên, cần có các lập trình viên tốt.", "order_start": 0, "order_end": 629, "word_count": 132}
{"parent_id": "a091b8ae-de8b-4aa7-9d72-e4c49c30486e", "subject": "Phantichthietkehttt", "section": "Đảm bảo chất lượng lập trình", "title_path": "Đảm bảo chất lượng lập trình", "content": "[Phantichthietkehttt / Đảm bảo chất lượng lập trình] Phát triển là bước xây dựng phần mềm tuân theo đặc tả. Trong pha này, mã nguồn được xây dựng và kết nối với các thư viện có sẵn, để hoàn thành các yêu cầu lập trình cho sản phẩm. Mã nguồn sẽ được dịch sang chương trình chạy được trên các phần cứng đã xác định trước. Đây cũng là bước cơ sở dữ liệu được xây dựng, từ đó dữ liệu có thể được nạp và sử dụng trong phần mềm. Làm thế nào để đảm bảo chất lượng pha phát triển? Ta có thể sử dụng các chuẩn nội bộ sẵn có về chất lượng code, cũng như các hướng dẫn lập trình cho ngôn ngữ lựa chọn. Ngoài ra, những thay đổi không được kiểm soát có thể dẫn tới lỗi. Vì vậy, quản lý thay đổi và quản lý cấu hình rất quan trọng trong đảm bảo chất lượng code.", "order_start": 0, "order_end": 694, "word_count": 155}
{"parent_id": "4ac0aa99-6b25-4529-9759-b362a986886b", "subject": "Phantichthietkehttt", "section": "a. Khái niệm", "title_path": "a. Khái niệm", "content": "[Phantichthietkehttt / a. Khái niệm] Có thể định nghĩa một cách dễ hiểu như sau: Kiểm thử phần mềm là quá trình thực thi một hệ thống phần mềm để xác định xem phần mềm có đúng với đặc tả không và môi trường hoạt động có đúng yêu cầu không. Software testing objectives Các mục tiêu trực tiếp • Xác định và phát hiện nhiều lỗi nhất có thể trong phần mềm được kiểm thử • Sau khi sửa chữa các lỗi đã xác định và kiểm tra lại, làm cho phần mềm đã được kiểm thử đến một mức độ chấp nhận được về chất lượng. Thực hiện các yêu cầu kiểm thử cần thiết một cách hiệu quả và có hiệu quả, trong phạm vi ngân sách và thời gian cho phép. Các mục tiêu gián tiếp Biên dịch một bản ghi về các lỗi phần mềm để sử dụng trong công tác phòng chống lỗi (bằng các hành động khắc phục và ngăn ngừa).", "order_start": 0, "order_end": 737, "word_count": 163}
{"parent_id": "0dd8789d-c073-424b-9415-8734288e52fb", "subject": "Phantichthietkehttt", "section": "b. Các mức độ kiểm thử", "title_path": "b. Các mức độ kiểm thử", "content": "[Phantichthietkehttt / b. Các mức độ kiểm thử] Các mức độ kiểm thử được xây dựng tương ứng với từng pha trong vòng đời phát triển phần mềm. Kiểm thử đơn vị là hoạt động kiểm thử nhỏ nhất. Kiểm thử thực hiện trên các hàm hay thành phần riêng lẻ, cần hiểu biết về thiết kế chương trình và code. Kiểm thử đơn vị được thực hiện bởi Lập trình viên (không phải kiểm thử viên) Mục đích: Đảm bảo thông tin được xử lý đúng và có đầu ra chính xác trong mối tương quan giữa dữ liệu nhập và chức năng của đơn vị. Kiểm thử tích hợp: nhằm phát hiện lỗi giao tiếp xảy ra giữa các thành phần cũng như lỗi của bản thân từng thành phần (nếu có). Thành phần có thể là: các module, các ứng dụng riêng lẻ, các ứng dụng client/server trên một mạng Kiểm thử hệ thống: là một mức của tiến trình kiểm thử phần mềm khi các module và tích hợp các module đã được test. Mục tiêu của kiểm thử hệ thống là để đánh giá phần mềm có tuân thủ theo các yêu cầu đã đưa ra không, gồm cả yêu cầu chức năng và yêu cầu phi chức năng. Vì vậy, System Test lại gồm nhiều loại kiểm thử khác nhau, cả kiểm thử chức năng và kiểm thử phi chức năng.", "order_start": 0, "order_end": 1053, "word_count": 229}
{"parent_id": "0dd8789d-c073-424b-9415-8734288e52fb", "subject": "Phantichthietkehttt", "section": "b. Các mức độ kiểm thử", "title_path": "b. Các mức độ kiểm thử", "content": "[Phantichthietkehttt / b. Các mức độ kiểm thử] cầu đã đưa ra không, gồm cả yêu cầu chức năng và yêu cầu phi chức năng. Vì vậy, System Test lại gồm nhiều loại kiểm thử khác nhau, cả kiểm thử chức năng và kiểm thử phi chức năng. Kiểm thử chấp nhận: là một cấp độ trong tiến trình kiểm thử phần mềm nhằm kiểm thử hệ thống về khả năng chấp nhận được. Mục tiêu của kiểm thử này là để đánh giá sự tuân thủ của hệ thống với các yêu cầu nghiệp vụ và thẩm định xem đã có thể chấp nhận để bàn giao chưa. Kiểm thử chấp nhận được khách hàng thực hiện (hoặc ủy quyền cho một nhóm thứ ba thực hiện).", "order_start": 1053, "order_end": 1591, "word_count": 120}
{"parent_id": "1049d800-970f-440c-bb1b-c5c443bcca36", "subject": "Phantichthietkehttt", "section": "2.3.1. Mục tiêu của rà soát Mục tiêu của rà soát Định nghĩa", "title_path": "2.3.1. Mục tiêu của rà soát Mục tiêu của rà soát Định nghĩa", "content": "[Phantichthietkehttt / 2.3.1. Mục tiêu của rà soát Mục tiêu của rà soát Định nghĩa] Định nghĩa của IEEE (1990), quá trình rà soát là: “Một quá trình hoặc một cuộc họp mà trong đó một sản phẩm công việc hoặc một tập các sản phẩm công việc được đưa ra tới toàn thể cá nhân tham gia vào dự án, các giám đốc, người dùng, khách hàng và các bên quan tâm đến dự án nhằm lấy ý kiến phê bình và phê chuẩn” Một số phương pháp dùng để xem xét lại tài liệu: Xem xét lại thiết kế hình thức (Formal design reviews) Xem xét lại ngang hàng (Peer reviews) Ý kiến chuyên gia", "order_start": 0, "order_end": 472, "word_count": 102}
{"parent_id": "7c8c52ca-9e44-4041-bc08-9d993cdfb70d", "subject": "Phantichthietkehttt", "section": "Mục tiêu", "title_path": "Mục tiêu", "content": "[Phantichthietkehttt / Mục tiêu] Mục đích được chia làm 2 loại: mục đích trực tiếp và gián tiếp. Mục đích trực tiếp: Phát hiện lỗi phân tích và thiết kế. Xác định các rủi ro mới. Xác định sự sai lệch so với mẫu, các kiểu thủ tục và qui ước. Để phê chuẩn sản phẩm của phân tích hoặc thiết kế. Mục đích gián tiếp: - Nơi họp mặt không chính thức để trao đổi về những kiến thức chuyên môn. Ghi lại những lỗi phân tích và thiết kế sẽ hỗ trợ một cơ sở cho những hoạt động sửa chữa lỗi trong tương lai.", "order_start": 0, "order_end": 462, "word_count": 103}
{"parent_id": "c8b320ac-6acb-4015-bb26-6ae4963a6586", "subject": "Phantichthietkehttt", "section": "2.3.2. Các hình thức rà soát", "title_path": "2.3.2. Các hình thức rà soát", "content": "[Phantichthietkehttt / 2.3.2. Các hình thức rà soát] a. Rà soát chính thức Ví dụ một số loại rà soát chính thức : • DPR – Development Plan Review : Review kế hoạch phát triển • SRSR – Software Requirement Specification Review : Review đặc tả yêu cầu phần mềm • PDR – Preliminary Design Review : Review thiết kế sơ bộ • DBDR- Detailed Design Review : Review thiết kế chi tiết • TPR – Test Plan Review : Review kế hoạch kiểm thử • STPR – Software Test Procedure Review : Review thủ tục kiểm thử phần mềm • VDR- Version Description Review : Review mô tả phiên bản • OMR- Operator Manual Review : Review vận hành thủ công • SMR- Support Manual Review :Review trợ giúp thủ công • TRR- Test Readiness Review : Review sự sẵn sàng kiểm thử • PRR- Product Release Review : Review bản phát hành sản phẩm • IPR-Installation Plan Review : Review kế hoạch cài đặt", "order_start": 0, "order_end": 797, "word_count": 158}
{"parent_id": "a6738693-10e7-48b4-bb71-acbe01ff83bd", "subject": "Phantichthietkehttt", "section": "Các nhân tố ảnh hưởng tới DRs", "title_path": "Các nhân tố ảnh hưởng tới DRs", "content": "[Phantichthietkehttt / Các nhân tố ảnh hưởng tới DRs] • Những người tham gia • Sự chuẩn bị trước • Phiên DR Các hoạt động sau DR được đề xuất", "order_start": 0, "order_end": 87, "word_count": 21}
{"parent_id": "a70aeec5-67a9-4fd0-b81e-ffa96c32a39f", "subject": "Phantichthietkehttt", "section": "Review Leader :", "title_path": "Review Leader :", "content": "[Phantichthietkehttt / Review Leader :] • Có kiến thức và kinh nghiệm trong việc phát triển kiểu dự án được review • Có thâm niên ở mức độ bằng với hoặc cao hơn của project leader • Có mối quan hệ tốt với project leader và đội dự an • Có vị trí bên ngoài đội dự án", "order_start": 0, "order_end": 224, "word_count": 53}
{"parent_id": "7b0b511d-1d69-49dc-932c-e8bba57e037d", "subject": "Phantichthietkehttt", "section": "Review team:", "title_path": "Review team:", "content": "[Phantichthietkehttt / Review team:] Phần lớn không thuộc đội dự án Kích thước từ 3-5 người Đa dạng về kinh nghiệm và phương pháp", "order_start": 0, "order_end": 92, "word_count": 20}
{"parent_id": "7830faa4-8a60-4b77-b585-30e6c6585849", "subject": "Phantichthietkehttt", "section": "Sự chuẩn bị cho một phiên làm việc DR", "title_path": "Sự chuẩn bị cho một phiên làm việc DR", "content": "[Phantichthietkehttt / Sự chuẩn bị cho một phiên làm việc DR] Được hoàn thành bởi 3 thành viên: review leader, review team và development team..", "order_start": 0, "order_end": 82, "word_count": 14}
{"parent_id": "33d7beab-688f-48df-9a51-752232baf24b", "subject": "Phantichthietkehttt", "section": "Chuẩn bị của Review leader", "title_path": "Chuẩn bị của Review leader", "content": "[Phantichthietkehttt / Chuẩn bị của Review leader] • Bổ nhiệm các thành viên nhóm Lập lịch các phiên review Phân chia tài liệu thiết kế cho các thành viên của nhóm", "order_start": 0, "order_end": 112, "word_count": 24}
{"parent_id": "9f6cb616-504b-49ca-8a09-315202972336", "subject": "Phantichthietkehttt", "section": "Chuẩn bị của Development team", "title_path": "Chuẩn bị của Development team", "content": "[Phantichthietkehttt / Chuẩn bị của Development team] Trình diễn ngắn tài liệu thiết kế Checklist các công việc review", "order_start": 0, "order_end": 64, "word_count": 12}
{"parent_id": "df7d0c29-1f28-4a60-a06e-d69005fed33a", "subject": "Phantichthietkehttt", "section": "Phiên DR", "title_path": "Phiên DR", "content": "[Phantichthietkehttt / Phiên DR] Một cuộc họp phiên DR thông thường gồm có : 1. Trình diễn ngắn gọn về tài liệu thiết kế 2. Các bình luận của các thành viên review team 3. Kiểm tra và xác nhận thảo luận mỗi bình luận 4. Các quyết định về tài liệu thiết kế để xác định tiến trình dự án. Các quyết định có thể có 3 loại : Phê duyệt đầy đủ Phê duyệt từng phần Từ chối phê duyệt", "order_start": 0, "order_end": 341, "word_count": 78}
{"parent_id": "32adb1d4-fdb0-4170-9e29-11f559268aaf", "subject": "Phantichthietkehttt", "section": "Các hoạt động hậu review", "title_path": "Các hoạt động hậu review", "content": "[Phantichthietkehttt / Các hoạt động hậu review] • Báo cáo Review • Review leader thực hiện sau phiên review • Bao gồm : o Tổng kết các thảo luận review o Quyết định về sự tiếp tục của dự án o Danh sách các hoạt động cần thiết phải làm o Tên thành viên chịu trách nhiệm theo sát việc hiệu chỉnh • Tiến trình theo dõi o Review leader thực hiện o Chắc rằng việc hiệu chỉnh được thực hiện đúng đắn Việc theo dõi cần được ghi lại", "order_start": 0, "order_end": 376, "word_count": 83}
{"parent_id": "08b3e22a-2ecd-439f-a31d-04e3fd1bcd67", "subject": "Phantichthietkehttt", "section": "b. Rà soát ngang hàng", "title_path": "b. Rà soát ngang hàng", "content": "[Phantichthietkehttt / b. Rà soát ngang hàng] Mục đích chính của peer review là xác định lỗi và độ lệch dựa vào các chuẩn. Có hai phương pháp peer reviews: xét duyệt (inspection) kiểm tra từng bước (walkthrough). Walkthrough phát hiện sai sót và ghi chú lên tài liệu. Inspection phát hiện sai sót và kết hợp với nỗ lực để cải tiến.", "order_start": 0, "order_end": 285, "word_count": 56}
{"parent_id": "9e022b6c-6219-4aca-9391-b0751f934517", "subject": "Phantichthietkehttt", "section": "Những người tham gia vào peer reviews", "title_path": "Những người tham gia vào peer reviews", "content": "[Phantichthietkehttt / Những người tham gia vào peer reviews] Một đội peer review tối ưu 3-5 người tham gia. Tất cả những người tham gia nên là những người cùng địa vị của nhà thiết kế hệ thống phần mềm.", "order_start": 0, "order_end": 141, "word_count": 31}
{"parent_id": "cb8fab37-b443-4f21-9d51-d8bfce55ea76", "subject": "Phantichthietkehttt", "section": "Một đội peer review đề cử bao gồm:", "title_path": "Một đội peer review đề cử bao gồm:", "content": "[Phantichthietkehttt / Một đội peer review đề cử bao gồm:] • Một leader review. • Một người thực thi (author). Các chuyên gia đặc biệt (specialized professionals).", "order_start": 0, "order_end": 104, "word_count": 17}
{"parent_id": "7e973d0a-b415-4393-af3a-9430d1c1fc9c", "subject": "Phantichthietkehttt", "section": "Phân công trách nhiệm trong đội (team assignments)", "title_path": "Phân công trách nhiệm trong đội (team assignments)", "content": "[Phantichthietkehttt / Phân công trách nhiệm trong đội (team assignments)] Hai trong số các thành viên sẽ là: một người dẫn chương trình một người viết tài liệu trong cuộc thảo luận.", "order_start": 0, "order_end": 107, "word_count": 22}
{"parent_id": "fc3482fc-7c05-4955-8224-b4347c22897b", "subject": "Phantichthietkehttt", "section": "Chuẩn bị cho phiên peer review", "title_path": "Chuẩn bị cho phiên peer review", "content": "[Phantichthietkehttt / Chuẩn bị cho phiên peer review] Leader: o Xác định những đoạn trong tài liệu thiết kế sẽ đuợc review o Lựa chọn thành viên nhóm o Lập lịch cho những phiên review o Đưa tài liệu cho các thành viên trong đội trước phiên review • Đội peer review: yêu cầu của inspection khá tỉ mỉ, còn walkthrough chỉ yêu cầu đơn giản. o Inspection: Đọc & liệt kê chú thích của họ o Walkth-rough : Đọc các đoạn sẽ được review", "order_start": 0, "order_end": 373, "word_count": 77}
{"parent_id": "ed770742-73bc-49b8-b5fb-ff1626270197", "subject": "Phantichthietkehttt", "section": "Phiên peer review", "title_path": "Phiên peer review", "content": "[Phantichthietkehttt / Phiên peer review] Inspection : o Presenter đọc một đoạn tài liệu và thêm vào nếu cần thiết. o Những người liên quan hoặc đưa ra chú thích, hoặc phản ứng với những lời chú thích trong tài liệu. Walkthrough: o Bắt đầu bằng sự trình bày ngắn của author (thường ko phải là presenter) hoặc tổng quan về dự án và những đoạn thiết kế sẽ được review. o Ghi lại vị trí, mô tả, kiểu, đặc điểm (sai sót, những phần thiếu, những phần thêm vào) của mỗi lỗi được chấp nhận. Quy tắc thời gian: phiên không nên vượt quá 2 giờ, hoặc lập lịch không nhiều hơn 2 ngày. Tài liệu sau mỗi phiên review: o Báo cáo những phát hiện trong phiên inspection o Báo cáo tóm tắt của phiên inspection Các hoạt động sau peer review (post-peer review activities)", "order_start": 0, "order_end": 709, "word_count": 142}
{"parent_id": "67d9c47c-bc9e-4754-8d76-acf57fe69fc7", "subject": "Phantichthietkehttt", "section": "Inspection:", "title_path": "Inspection:", "content": "[Phantichthietkehttt / Inspection:] o Nhắc nhở, sửa chữa hiệu quả, làm lại tất cả các lỗi o Chuyển giao các bản báo cáo inspection tới CAB để phân tích.", "order_start": 0, "order_end": 116, "word_count": 26}
{"parent_id": "51e9ca85-a561-439e-b4b5-9a83e0550b41", "subject": "Phantichthietkehttt", "section": "Hiệu quả của peer review (the efficency of peer reviews)", "title_path": "Hiệu quả của peer review (the efficency of peer reviews)", "content": "[Phantichthietkehttt / Hiệu quả của peer review (the efficency of peer reviews)] Một vài độ đo phổ biến ước lượng hiệu suất của peer review: o Số giờ trung bình trên một lỗi. o Mật độ phát hiện thiếu sót (Số thiếu sót trung bình trên một trang tài liệu thiết kế). o Hiệu năng peer review bên trong. o Peer review coverage: Là tỉ lệ nhỏ của tài liệu và toàn bộ code đã từng trải qua peer view c. Ý kiến chuyên gia Ý kiến của chuyên ra rất hữu ích trong những trường hợp sau: o Thiếu sự hiểu biết đầy đủ về lĩnh vực nào đó. o Tạm thời thiếu những người chuyên nghiệp để tham gia vào đội xem xét lại o Các thành viên chuyên nghiệp cao cấp trong tổ chức không thống nhất được với nhau. o Trong các tổ chức nhỏ số lượng ứng viên phù hợp cho đội xem xét lại là không đủ.", "order_start": 0, "order_end": 683, "word_count": 151}
{"parent_id": "c88c0aff-fd4b-4cce-9cce-1c2bc3c0c599", "subject": "Phantichthietkehttt", "section": "d. So sánh rà soát chính thức và rà soát ngang hàng", "title_path": "d. So sánh rà soát chính thức và rà soát ngang hàng", "content": "[Phantichthietkehttt / d. So sánh rà soát chính thức và rà soát ngang hàng] Để rõ hơn những đặc điểm của các phương pháp rà soát có thể tham khảo bảng so sánh giữa ba phương pháp rà soát sau đây:", "order_start": 0, "order_end": 119, "word_count": 27}
{"parent_id": "9cc6bdd7-50f0-41c0-8a38-44038f24b030", "subject": "Phantichthietkehttt", "section": "Khái niệm:", "title_path": "Khái niệm:", "content": "[Phantichthietkehttt / Khái niệm:] Black-box testing là phương pháp kiểm thử mà không cần biết cài đặt của chương trình. Kiểm thử hộp đen quan trọng trong công nghiệp Chúng ta cần có một bản chương trình chạy được và đặc tả. Test cases được công thức hoá là một cặp. Ví dụ, (input, output mong muốn) Một số kỹ thuật thiết kế test: phân lớp tương đương, test biên, phân loại, kiểm thử theo cặp…", "order_start": 0, "order_end": 358, "word_count": 72}
{"parent_id": "2fba0ba4-79bd-4890-b087-32ca0df8c060", "subject": "Phantichthietkehttt", "section": "Kỹ thuật Phân lớp tương đương:", "title_path": "Kỹ thuật Phân lớp tương đương:", "content": "[Phantichthietkehttt / Kỹ thuật Phân lớp tương đương:] Phân lớp tương đương là một phương pháp kiểm thử hộp đen chia miền đầu vào của chương trình thành các lớp dữ liệu, từ đó suy dẫn ra các ca kiểm thử. Lớp tương đương biểu thị cho tập các trạng thái hợp lệ hay không hợp lệ đối với điều kiện vào. Thiết kế Test-case bằng phân lớp tương đương tiến hành theo 2 bước: 1. Xác định các lớp tương đương. 2. Xác định các ca kiểm thử.", "order_start": 0, "order_end": 373, "word_count": 81}
{"parent_id": "7076d5d6-d250-4568-9659-c79953c8a49d", "subject": "Phantichthietkehttt", "section": "Kỹ thuật Phân tích giá trị biên:", "title_path": "Kỹ thuật Phân tích giá trị biên:", "content": "[Phantichthietkehttt / Kỹ thuật Phân tích giá trị biên:] Kinh nghiệm cho thấy các ca kiểm thử mà khảo sát tỷ mỷ các điều kiện biên có tỷ lệ phần trăm cao hơn các ca kiểm thử khác. Các điều kiện biên là những điều kiện mà các tình huống ngay tại, trên và dưới các cạnh của các lớp tương đương đầu vào và các lớp tương đương đầu ra. Phân tích các giá trị biên là phương pháp thiết kế ca kiểm thử bổ sung thêm cho phân lớp tương đương, nhưng khác với phân lớp tương đương ở 2 khía cạnh: Phân tích giá trị biên không lựa chọn phần tử bất kỳ nào trong 1 lớp tương đương là điển hình, mà nó yêu cầu là 1 hay nhiều phần tử được lựa chọn như vậy mà mỗi cạnh của lớp tương đương đó chính là đối tượng kiểm tra. Ngoài việc chỉ tập trung chú ý vào các trạng thái đầu vào (không gian đầu vào), các ca kiểm thử cũng nhận được bằng việc xem xét không gian kết quả (các lớp tương đương đầu ra).", "order_start": 0, "order_end": 822, "word_count": 183}
{"parent_id": "2b809a90-9fd9-4224-a86d-cbc668655d56", "subject": "Phantichthietkehttt", "section": "Kỹ thuật Bảng quyết định", "title_path": "Kỹ thuật Bảng quyết định", "content": "[Phantichthietkehttt / Kỹ thuật Bảng quyết định] • Miêu tả các qui tăc nghiẹp vụ phưc tap mà phần mềm phải thực hiẹn dươi dang dê đoc và dê kiểm soát Ví dụ 1 chưc nang nhỏ cua cong ty bảo hiểm : khuyên mai cho nhưng chu xe nêu ho thỏa ít nhất 1 trong 2 điều kiẹn: đa lâp gia đình / là sinh viên giỏi. Môi dư liẹu nhâp là 1 giá tri luân lý, nên bảng quyêt đinh chi cần có 4 cọt, miêu tả 4 luât khác nhau : Từ bảng quyêt đinh chuyển thành bảng các testcase trong đó môi cọt miêu tả 1 luât được chuyển thành 1 đên n cọt miêu tả các testcase tưong ưng vơi luât đó.", "order_start": 0, "order_end": 511, "word_count": 120}
{"parent_id": "780a8cf9-dc7c-4740-8daf-d7468a4c5d79", "subject": "Phantichthietkehttt", "section": "Lược đồ chuyển trạng", "title_path": "Lược đồ chuyển trạng", "content": "[Phantichthietkehttt / Lược đồ chuyển trạng] • Là 1 công cụ rất hữu ích để đặc tả các yêu cầu phần mềm hoặc để đặc tả bảng thiết kế hệ thống phần mềm. • Lược đồ chuyển trạng thái ghi nhận các sự kiện xảy ra, rồi được hệ thống xử lý cũng như những đáp ứng của hệ thống. Khi hệ thống phải nhớ trạng thái trước đó của mình, hay phải biết trình tự các hoạt động nào là hợp lệ, trình tự nào là không hợp lệ thì lược đồ chuyển trạng thái là rất thích hợp.", "order_start": 0, "order_end": 404, "word_count": 94}
{"parent_id": "bd4178bf-8390-4bbc-94cd-715d9d90c6fe", "subject": "Phantichthietkehttt", "section": "Kiểm thử theo cặp", "title_path": "Kiểm thử theo cặp", "content": "[Phantichthietkehttt / Kiểm thử theo cặp] Thực tế cho thấy hầu hết các lỗi đều được sinh ra từ sự kết hợp giá trị của các cặp tham số đầu vào. Để thực hiện kiểm thử theo cặp, ta cần: • Lựa chọn tham số đầu vào và các giá trị tương ứng • Lấy tổ hợp (pairwise) của các giá trị giữa 2 tham số Xây dựng bộ test sao cho bao phủ được tất cả các cặp xác định ở trên", "order_start": 0, "order_end": 316, "word_count": 77}
{"parent_id": "29f10630-ee46-48ea-bb1e-04e669d793cd", "subject": "Phantichthietkehttt", "section": "Khái niệm:", "title_path": "Khái niệm:", "content": "[Phantichthietkehttt / Khái niệm:] Kiểm thử hộp trắng dựa vào thuât giải cụ thể, vào cấu truc dư liẹu bên trong cua module cần kiểm thử để xác đinh module đó có thực hiẹn đung khong. • Do đó ngươi Kiểm thử hộp trắng phải có ky nang, kiên thưc để có thể thong hiểu chi tiêt về đoan code cần kiểm thử. • Thương tôn rất nhiều thơi gian và cong sưc", "order_start": 0, "order_end": 309, "word_count": 69}
{"parent_id": "c6a91a81-1e9e-4b64-b4d7-ec4091cb8fa9", "subject": "Phantichthietkehttt", "section": "Kiểm thử luồng điều khiển", "title_path": "Kiểm thử luồng điều khiển", "content": "[Phantichthietkehttt / Kiểm thử luồng điều khiển] Đương thi hành (Execution path) : là 1 kich bản thi hành đon vi phần mềm tưong ưng : danh sách có thư tự các lẹnh được thi hành ưng vơi 1 lần chay cụ thể cua đon vi phần mềm, băt đầu từ điểm nhâp cua đon vi phần mềm đên điểm kêt thuc cua đon vi phần mềm. Mục tiêu cua phưong pháp kiểm thử luông điều khiển là đảm bảo moi đương thi hành cua đon vi phần mềm cần kiểm thử đều chay đung. Rất tiêc trong thực tê, cong sưc và thơi gian để đat mục tiêu trên đây là rất lơn, ngay cả trên nhưng đon vi phần mềm nhỏ. Ta nên kiểm thử sô test case tôi thiểu mà kêt quả đọ tin cây tôi đa. Nhưng làm sao xác đinh được sô test case tôi thiểu nào có thể đem lai kêt quả có đọ tin cây tôi đa ? Phu kiểm thử (Coverage) : là ti lẹ các thành phần thực sự được kiểm thử so vơi tông thể sau khi đa kiểm thử các test case được chon. Phu càng lơn thì đọ tin cây càng cao. Thaà nh phần liên quan có thể là lẹnh, điểm quyêt đinh, điều kiẹn con, đương thi hành hay là sự kêt hợp cua chung. Các mức phủ kiểm thử: • Phu cấp 0 : kiểm thử nhưng gì có thể kiểm thử được, phần con lai để ngươi dung phát hiẹn và báo lai sau.", "order_start": 0, "order_end": 1091, "word_count": 253}
{"parent_id": "c6a91a81-1e9e-4b64-b4d7-ec4091cb8fa9", "subject": "Phantichthietkehttt", "section": "Kiểm thử luồng điều khiển", "title_path": "Kiểm thử luồng điều khiển", "content": "[Phantichthietkehttt / Kiểm thử luồng điều khiển] ẹn con, đương thi hành hay là sự kêt hợp cua chung. Các mức phủ kiểm thử: • Phu cấp 0 : kiểm thử nhưng gì có thể kiểm thử được, phần con lai để ngươi dung phát hiẹn và báo lai sau. Đây là mưc đọ kiểm thử khong thực sự có trách nhiẹm. Phu cấp 1 : kiểm thử sao cho môi lẹnh được thực thi ít nhất 1 lần. Phu cấp 2 : kiểm thử sao cho môi điểm quyêt đinh đều được thực hiẹn ít nhất 1 lần cho trương hợp TRUE lân FALSE. Ta goi mưc kiểm thử này là phu các nhánh (Branch coverage). Phu các nhánh đảm bảo phu các lẹnh. Phu cấp 3 : kiểm thử sao cho môi điều kiẹn luân lý con (subcondition) cua từng điểm quyêt đinh đều được thực hiẹn ít nhất 1 lần cho trương hợp TRUE lân FALSE. Ta goi mưc kiểm thử này là phu các điều kiẹn con (subcondition coverage). Phu các điều kiẹn con chưa chăc đảm bảo phu các nhánh. Phu cấp 4 : kiểm thử sao cho môi điều kiẹn luân lý con (subcondition) cua từng điểm quyêt đinh đều được thực hiẹn ít nhất 1 lần cho trương hợp TRUE lân FALSE & điểm quyêt đinh cung được kiểm thử cho cả 2 nhánh. Ta goi mưc kiểm thử này là phu các nhánh & điều kiẹn con (branch & subcondition coverage).", "order_start": 1091, "order_end": 2190, "word_count": 242}
{"parent_id": "6ed307f6-39e7-4ca1-87d2-db01c479202b", "subject": "Phantichthietkehttt", "section": "2.5 CÂU HỎI ÔN TẬP", "title_path": "2.5 CÂU HỎI ÔN TẬP", "content": "[Phantichthietkehttt / 2.5 CÂU HỎI ÔN TẬP] 1. Khái niệm Đảm bảo chất lượng phần mềm? 2. Khái niệm V&V và IV&V? 3. Xác định đặc tả theo bộ tiêu chí MCCall? Lấy ví dụ minh hoạ? 4. Phân biệt các loại hoạt động review? 5. Nêu các level kiểm thử 6. Trình bày các kỹ thuật kiểm thử?", "order_start": 0, "order_end": 233, "word_count": 52}
{"parent_id": "d995e4bb-0c22-40f8-a9f3-59d40658108c", "subject": "Phantichthietkehttt", "section": "3.1.1 Tìm hiểu lĩnh vực chuyên môn", "title_path": "3.1.1 Tìm hiểu lĩnh vực chuyên môn", "content": "[Phantichthietkehttt / 3.1.1 Tìm hiểu lĩnh vực chuyên môn] Tóm tắt các bước thực hiện: • Bước 1: Làm việc nhóm (có thể dùng brainstorming) để liệt kê tất cả các từ khóa chuyên môn trong lĩnh vực của ứng dụng • Bước 2: Phân các từ tìm ra thành nhóm cho dễ theo dõi • Bước 3: Giải thích nghĩa của từng từ khóa và lập bảng kết quả các từ khóa (glosary list). Áp dụng các bước trên vào bài toán quản lí đăng kí học tín chỉ của một trường đại học, gộp bước 1 và 2, có thể gom các từ khóa trong lĩnh vực quản lí đăng kí tín chỉ thành ba nhóm như sau:", "order_start": 0, "order_end": 485, "word_count": 111}
{"parent_id": "7117e7cc-c71e-459f-90b8-ebecef7ec056", "subject": "Phantichthietkehttt", "section": "Untitled", "title_path": "Untitled", "content": "[Phantichthietkehttt / Untitled] Thành viên Nhân viên Sinh viên Nhân viên quản lí Nhân viên khảo thí Nhân viên giáo vụ Giảng viên Người dùng Đăng nhập Đăng xuất Đổi mật khẩu Cập nhật thông tin cá nhân Sinh viên đăng kí học Sinh viên xem lịch học Sinh viên sửa đăng kí Sinh viên xem điểm Giảng viên đăng kí dạy Giảng viên nhập điểm Giảng viên xem lịch dạy Giảng viên xem điểm Giáo vụ quản lí môn học Giáo vụ quản lí lớp học phần Giáo vụ quản lí thông tin sinh viên Giáo vụ quản lí thông tin học k Quản lí thông tin trường Quản lí thông tin Khoa Quản lí thông tin bô môn Quản lí thông tin giảng viên Xem thống kê giảng viên Xem thống kê sinh viên Xem thống kê học lực Xem thống kê phòng học Vật, đối tượng Trường Khoa Ngành học Bộ môn Năm học Khóa học Học kì Môn học Lớp học phần Tuần học Ngày học trong tuần Kíp/ca học trong ngày Phòng học Tòa nhà Đầu điểm thành phần Điểm thi Điểm trung bình môn Điểm chữ Tín chỉ Tổng tín chỉ tích lũy Điểm trung bình tích lũy Học lực Loại học lực", "order_start": 0, "order_end": 947, "word_count": 206}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] Tóm tắt các bước thực hiện: • Bước 1: Giới thiệu mục đích hệ thống • Bước 2: Phạm vi hệ thống: ai được dùng phần mềm/hệ thống? Mỗi người vào vào hệ thống được phép thực hiện các chức năng nào? Bước 3: Với mỗi chức năng mà người dùng được phép thực hiện ở bước 2, mô tả chi tiết hoạt động nghiệp vụ của chức năng đấy diễn ra như thế nào? Bước 4: Các đối tượng nào được quản lí, xử lí trong hệ thống? Mỗi đối tượng cần dùng/quản lí các thuộc tính nào? • Bước 5: Quan hệ (số lượng) giữa các đối tượng đã nêu ở bước 4? Áp dụng vào hệ thống quản lí đăng kí tín chỉ, các bước được tiến hành như sau: Bước 1: Mục đích của hệ thống: Hệ thống trang web phục vụ công tác quản lí đăng kí tín chỉ của sinh viên, đăng kí giảng dạy của giảng viên, quản lí điểm các môn học của một trường đại học.", "order_start": 0, "order_end": 782, "word_count": 175}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] Mục đích của hệ thống: Hệ thống trang web phục vụ công tác quản lí đăng kí tín chỉ của sinh viên, đăng kí giảng dạy của giảng viên, quản lí điểm các môn học của một trường đại học. Bước 2: Phạm vi hệ thống: Những người được vào hệ thống và chức năng mỗi người được thực hiện khi vào hệ thống này được quy định như sau: Thành viên hệ thống: ◦ Đăng nhập ◦ Đăng xuất ◦ Đổi mật khẩu cá nhân Sinh viên: ◦ Được thực hiện các chức năng như thành viên ◦ Đăng kí học, sửa thông tin đăng kí của mình ◦ Xem lịch học của mình ◦ Xem điểm của mình • Giảng viên: ◦ Đăng kí dạy, sửa thông tin đăng kí dạy ◦ Nhập, sửa điểm các lớp mình dạy ◦ Xem lịch dạy của mình ◦ Xem thống kê liên quan đến các lớp mình dạy • Nhân viên giáo vụ: ◦ Quản lí thông tin sinh viên: thêm, xóa, sửa theo yêu cầu từ sinh viên ◦ Quản lí thông tin môn học ◦ Quản lí thông tin lớp học phần • Nhân viên quản lí: ◦ Quản lí thông tin chung: thông tin trường, thông tin khoa, thông tin bộ môn, thông tin các toàn nhà, phòng học, thông tin năm học, kì học.", "order_start": 782, "order_end": 1790, "word_count": 228}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] g tin lớp học phần • Nhân viên quản lí: ◦ Quản lí thông tin chung: thông tin trường, thông tin khoa, thông tin bộ môn, thông tin các toàn nhà, phòng học, thông tin năm học, kì học. ◦ Quản lí thông tin giảng viên theo yêu cầu từ giảng viên ◦ Xem các loại thống kê Nhân viên khảo thí: ◦ Xuất bảng điểm theo yêu cầu của sinh viên Những chức năng không đề cập đến thì mặc định là không thuộc phạm vi của hệ thống. Bước 3: Hoạt động nghiệp vụ của các chức năng: Theo nguyên tắc, mỗi chức năng liệt kê trong bước 2 đều phải mô tả chi tiết. Tuy nhiên, trong phạm vi tài liệu này, chỉ có ba chức năng được mô tả chi tiết vì đây là các chức năng được dùng để minh họa cho các bước phân tích, thiết kế từ đầu đến cuối. Các chức năng còn lại coi như bài tập cho người học.", "order_start": 1790, "order_end": 2551, "word_count": 169}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] a chức năng được mô tả chi tiết vì đây là các chức năng được dùng để minh họa cho các bước phân tích, thiết kế từ đầu đến cuối. Các chức năng còn lại coi như bài tập cho người học. Sinh viên đăng kí học: Sinh viên đăng nhập vào hệ thống -> chọn chức năng đăng kí tín chỉ (đang trong thời gian mở đăng kí mới được chọn) -> chọn kì đăng kí + ngành học (có thể có sinh viên học đồng thời hai chuyên ngành) -> hệ thống hiện danh sách các môn học có thể đăng kí (mã, tên môn học, số tín chỉ, mô tả), các lớp học phần đã đăng kí rồi, nếu có -> Sinh viên chọn môn học -> hệ thống hiện danh sách các lớp học phần của môn học đấy (mã, tên, sĩ số tối đa, sĩ số hiện tại, phòng học, giảng viên, lịch học hàng tuần vào các ngày nào trong tuần, kíp nào trong ngày): chỉ active các nhóm mà không bị trùng lịch học với các môn đã chon trước, các nhóm bị trùng lịch thì chỉ xem, không chọn được -> Sinh viên chọn lớp học phần mình thích -> hệ thống quay lại trang bắt đầu đăng kí với lớp học phần vừa chọn được bổ sung vào danh sách các lớp học phần đã chọn.", "order_start": 2551, "order_end": 3593, "word_count": 235}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] không chọn được -> Sinh viên chọn lớp học phần mình thích -> hệ thống quay lại trang bắt đầu đăng kí với lớp học phần vừa chọn được bổ sung vào danh sách các lớp học phần đã chọn. Sinh viên lặp lại các bước trên cho đến khi chọn đủ số tín chỉ trong ngưỡng cho phép -> nút lưu được active -> Sinh viên click lưu thì thông tin đăng kí mới chính thức được lưu vào hệ thống, hệ thống quay về giao diện chính của sinh viên. Giảng viên nhập điểm: Giảng viên đăng nhập vào hệ thống -> chọn chức năng nhập điểm -> Chọn học kì đang active -> hệ thống hiện danh sách các môn học do giảng viên dạy của kì đã chọn (mã, tên, số tín chỉ, mô tả) -> Giảng viên click chọn môn học muốn nhập điểm -> Hệ thống hiện danh sách các lớp học phần do giảng viên dạy (mã, tên, sĩ số thực, phòng học, ngày học, kíp học) -> Giảng viên chọn 1 lớp học phần muốn nhập -> Hệ thống hiện danh sách các sinh viên đăng kí lớp học phần được chọn với điểm thành phần, nếu có: thứ tự, mã sinh viên, họ tên, các đầu điểm thành phần, điểm thi, cột trung bình môn và điểm chữ được tự tính sau khi nhập -> Giảng viên nhập đầu điểm muốn nhập c", "order_start": 3593, "order_end": 4692, "word_count": 242}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] hành phần, nếu có: thứ tự, mã sinh viên, họ tên, các đầu điểm thành phần, điểm thi, cột trung bình môn và điểm chữ được tự tính sau khi nhập -> Giảng viên nhập đầu điểm muốn nhập cho tất cả sinh viên trong danh sách và click lưu -> hệ thống lưu điểm vào và quay về giao diện chính của giảng viên. • Quản lí xem thống kê theo loại học lực: Nhân viên quản lí đăng nhập vào hệ thống -> chọn chức năng xem thống kê -> hệ thống hiện giao diện chọn thông tin thống kê -> chọn thống kê loại học lực -> Hệ thống hiện giao diện thống kê loại học lực -> Quản lí chọn học kì muốn thống kê -> Kết quả thống kê hiện lên, mỗi loại học lực trên một dòng, xếp theo thứ tự cao nhất đến thấp nhất của loại học lực trong bảng đánh giá (Ưu tú, xuất sắc, giỏi, khá, trung bình, yếu kém): thứ tự, loại học lực, tổng số sinh viên đạt loại đó, điểm trung bình sinh viên trong nhóm đạt loại đó trong học kì đã chọn -> Quản lí click vào một loại học lực -> Hệ thống hiện danh sách các sinh viên đạt loại học lực đấy lên, xếp theo thứ tự các ngành học, đến thứ tự abc của tên sinh viên: thứ tự, mã sinh viên, họ và tên, ngành h", "order_start": 4692, "order_end": 5792, "word_count": 246}
{"parent_id": "1ca91a92-5b38-45df-9b6a-05bad0f2e319", "subject": "Phantichthietkehttt", "section": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "title_path": "3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên", "content": "[Phantichthietkehttt / 3.1.2 Mô tả hệ thống bằng ngôn ngữ tự nhiên] học lực -> Hệ thống hiện danh sách các sinh viên đạt loại học lực đấy lên, xếp theo thứ tự các ngành học, đến thứ tự abc của tên sinh viên: thứ tự, mã sinh viên, họ và tên, ngành học, khóa học, tổng số tín chỉ của học kì, điểm trung bình của học kì -> Quản lí click vào một sinh viên danh sách -> Hệ thống hiện lên danh sách các môn và kết quả của sinh viên đã học trong học kì đó, xếp theo thứ tự abc của tên môn học: thứ tự, tên môn học, số tín chỉ, điểm trung bình môn đó của sinh viên. Dòng cuối là tổng số tín chỉ, điểm trung bình cả học kì của sinh viên -> Quản lí click vào một môn học trong danh sách -> Hệ thống hiện lên điểm chi tiết của môn học của sinh viên: mã môn, tên môn, tổng tín chỉ, các đầu điểm thành phần dạng bảng: tên đầu điểm thành phần, tỉ lệ % tính của đầu điểm thành phần, điểm của sinh viên. Dòng cuối là điểm trung bình môn của sinh viên trong môn học đó.", "order_start": 5792, "order_end": 6676, "word_count": 200}
{"parent_id": "8213bf79-d56f-47e6-a7a5-00a5eee35108", "subject": "Phantichthietkehttt", "section": "Bước 4: Thông tin các đối tượng cần xử lí, quản lí:", "title_path": "Bước 4: Thông tin các đối tượng cần xử lí, quản lí:", "content": "[Phantichthietkehttt / Bước 4: Thông tin các đối tượng cần xử lí, quản lí:] Nhóm các thông tin liên quan đến con người: • Thành viên: tên đăng nhập, mật khẩu, họ tên, địa chỉ, ngày sinh, email, số điện thoại • Sinh viên: giống thành viên, có thêm: mã sinh viên. Theo mỗi ngành học còn có khóa học, ngành học Nhân viên: giống thành viên, có thêm: vị trí công việc. Nhân viên quản lí: giống nhân viên • Nhân viên giáo vụ: giống nhân viên • Nhân viên khảo thí: giống nhân viên • Giảng viên: giống nhân viên Nhóm các thông tin liên quan đến cơ sở vật chất: Tòa nhà: tên, mô tả Phòng học: tên, sức chứa tối đa, mô tả Nhóm các thông tin liên quan đến đơn vị, tổ chức: Trường: tên, địa chỉ, mô tả • Khoa: tên, mô tả • Ngành học: tên, mô tả • Bộ môn: tên, mô tả Nhóm các thông tin liên quan đến chuyên môn, vận hành: • Năm học: tên, mô tả Kì học: tên, mô tả Tuần học: tên, mô tả Ngày trong tuần: tên, mô tả Kíp học trong ngày: tên, mô tả Môn học: tên, số tín chỉ, mô tả Lớp học phần: tên, mô tả, sĩ số tối đa, sĩ số hiện tại, giảng viên dạy, phòng học, tuần nào học ngày nào, kíp nào.", "order_start": 0, "order_end": 1000, "word_count": 221}
{"parent_id": "8213bf79-d56f-47e6-a7a5-00a5eee35108", "subject": "Phantichthietkehttt", "section": "Bước 4: Thông tin các đối tượng cần xử lí, quản lí:", "title_path": "Bước 4: Thông tin các đối tượng cần xử lí, quản lí:", "content": "[Phantichthietkehttt / Bước 4: Thông tin các đối tượng cần xử lí, quản lí:] tả Kíp học trong ngày: tên, mô tả Môn học: tên, số tín chỉ, mô tả Lớp học phần: tên, mô tả, sĩ số tối đa, sĩ số hiện tại, giảng viên dạy, phòng học, tuần nào học ngày nào, kíp nào. Nhóm thông tin liên quan đến thống kê: Thống kê theo loại học lực • Thống kê sinh viên theo kết quả học • Thống kê các môn học theo kết quả học Thống kê giảng viên theo: số giờ dạy, kết quả học Thống kê học kì theo số sinh viên", "order_start": 1000, "order_end": 1408, "word_count": 94}
{"parent_id": "3487e93e-b8e5-41e2-b636-f56684889fba", "subject": "Phantichthietkehttt", "section": "Bước 5: Quan hệ giữa các đối tượng, thông tin:", "title_path": "Bước 5: Quan hệ giữa các đối tượng, thông tin:", "content": "[Phantichthietkehttt / Bước 5: Quan hệ giữa các đối tượng, thông tin:] Một trường có nhiều khoa Một khoa có nhiều bộ môn Một khoa có nhiều ngành học • Một bộ môn quản lí chuyên môn nhiều môn học • Một bộ môn có nhiều giảng viên Một năm học có nhiều học kì Một học kì liên quan đến nhiều năm học. Một năm học + một học kì tạo ra một kì học (kì học # học kì). Một kì học có nhiều môn học Một môn học, vào một kì học, có nhiều lớp học phần Một lớp học phần có thể học vào nhiều buổi, mỗi buổi có thể liên quan đến 1 tuần khác nhau, 1 ngày khác nhau, 1 kíp khác nhau, 1 phòng học khác nhau, 1 giảng viên khác nhau. Một giảng viên có thể dạy nhiều môn học trong mỗi kì học Một môn học, trong một kì học, giảng viên có thể dạy nhiều lớp học phần khác nhau, miễn sao không trùng lịch buổi nào. Một lớp học phần, có thể có nhiều giảng viên dạy. Nhưng mỗi buổi học chỉ có một giảng viên dạy. Một môn học có nhiều đầu điểm thành phần. Mỗi đầu điểm thành phần, đối với mỗi môn học, có tỉ lệ % tính điểm nhất định.", "order_start": 0, "order_end": 931, "word_count": 213}
{"parent_id": "3487e93e-b8e5-41e2-b636-f56684889fba", "subject": "Phantichthietkehttt", "section": "Bước 5: Quan hệ giữa các đối tượng, thông tin:", "title_path": "Bước 5: Quan hệ giữa các đối tượng, thông tin:", "content": "[Phantichthietkehttt / Bước 5: Quan hệ giữa các đối tượng, thông tin:] iảng viên dạy. Nhưng mỗi buổi học chỉ có một giảng viên dạy. Một môn học có nhiều đầu điểm thành phần. Mỗi đầu điểm thành phần, đối với mỗi môn học, có tỉ lệ % tính điểm nhất định. Một tuần có thể có nhiều buổi dạy/học Một ngày có thể có nhiều buổi học/dạy Một kíp có thể có nhiều buổi học/dạy của nhiều lớp học phần khác nhau Một phòng học có thể có nhiều lớp học phần vào học ở những buổi khác nhau. Một sinh viên có thể đăng kí học nhiều ngành khác nhau (tối đa 2 ngành đồng thời). • Với mỗi ngành, sinh viên phải học một số môn nhất định, và điểm tính theo từng ngành. Các môn trùng nhau giữa các ngành thì sinh viên chỉ phải học 1 lần, qua là được. Mỗi sinh viên, mỗi môn học, có một diểm trung bình môn.", "order_start": 931, "order_end": 1640, "word_count": 155}
{"parent_id": "e11b8166-9cad-42ad-ae5c-c9a2b331e78f", "subject": "Phantichthietkehttt", "section": "3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case", "title_path": "3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case", "content": "[Phantichthietkehttt / 3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case] Tóm tắt các bước thực hiện để vẽ biểu đồ use case tổng quan: • Bước 1: Đề xuất các actor. Với mỗi người dùng xác định ở bước 2 của mục 3.1.2, đề xuất thành một actor tương ứng. Nếu các actor có đặc điểm gì chung, có thể đề xuất actor trừu tượng thành actor cha của các actor tương ứng. Ngoài ra, cần xem xét cần có các actor gián tiếp tác động vào để thực hiện các chức năng hay không. Bước 2: Đề xuất use case. Với mỗi chức năng xác định của mục 3.1.2, đề xuất thành một use case tương ứng Bước 3: Mịn hóa các use case. Nếu có ít nhất 2 use case trùng nhau, cần xem xét gộp lại thành 1. Nếu gộp lại gây hiểu nhầm về số các actor tác động vào, thì có thể dùng use case trừu tượng cho các use case giống nhau, mỗi use case con liên quan đến nhóm các actor tương ứng mà thôi. Tóm tắt các bước thực hiện để vẽ biểu đồ use case chi tiết: • Bước 1: Trích phần use case của chức năng tương ứng từ biểu đồ use case tổng quan. Bước 2: Phân rã use case chính thành các use case con: mỗi giao diện (hoặc một số giao diện) tương tác với người dùng có thể đề xuất thành một use case con.", "order_start": 0, "order_end": 1075, "word_count": 239}
{"parent_id": "e11b8166-9cad-42ad-ae5c-c9a2b331e78f", "subject": "Phantichthietkehttt", "section": "3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case", "title_path": "3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case", "content": "[Phantichthietkehttt / 3.1.3 Mô tả hệ thống bằng ngôn ngữ UML - use case] đồ use case tổng quan. Bước 2: Phân rã use case chính thành các use case con: mỗi giao diện (hoặc một số giao diện) tương tác với người dùng có thể đề xuất thành một use case con. • Bước 3: Xác định quan hệ của use case con với use case chính: generalization, include, hay extend. • Bước 4: Gộp các use case con tương tự nhau bằng cách dùng các use case trừu tượng tổng quát hơn. Lưu ý tránh sai sót trong biểu đồ use case: Tên use case phải là động từ chỉ hành động của actor. Không nên là động từ chỉ hành động của hệ thống. Cũng không nên là danh từ, tính từ... Mỗi use case phải có tương tác với ít nhất một actor, có thể là trực tiếp hoặc gián tiếp: phải tồn tại ít nhất một đường đi từ một actor nào đó đến use case theo hướng: quan hệ include thì theo chiều mũi tên, quan hệ extend thì ngược chiều mũi tên, quan hệ kế thừa thì gộp lại.", "order_start": 1075, "order_end": 1917, "word_count": 182}
{"parent_id": "877d9fba-fa47-45f2-8b35-ea6f1aa5218d", "subject": "Phantichthietkehttt", "section": "a. Biểu đồ use case tổng quan", "title_path": "a. Biểu đồ use case tổng quan", "content": "[Phantichthietkehttt / a. Biểu đồ use case tổng quan] Từ bước 2 trong mục 3.1.2, ta có thể đề xuất được các actor của hệ thống: sinh viên, giảng viên, quản lí, giáo vụ, và khảo thí. Tất cả đều có chức năng giống thành viên nên kế thừa từ thành viên. Riêng giảng viên, quản lí, giáo vụ, khảo thí còn kế thừa từ actor nhân viên của trường. Nhân viên kế thừa trực tiếp từ thành viên. Các chức năng tương ứng với từng actor: • Thành viên: đăng nhập, đổi mật khẩu Sinh viên: đăng kí học, xem lịch học, xem điểm. Ngoài ra có thể tham gia gián tiếp vào các chức năng: quản lí thông tin sinh viên, xuất bảng điểm cho sinh viên. • Giảng viên: đăng kí dạy, xem lịch dạy, nhập điểm, xem thống kê cá nhân. Ngoài ra có thể tham gia gián tiếp vào chức năng quản lí thông tin giảng viên. • Giáo vụ: quản lí thông tin sinh viên theo yêu cầu sinh viên, quản lí môn học, lớp học phần. Khảo thí: xuất bảng điểm theo yêu cầu sinh viên. Quản lí: quản lí thông tin chung, quản lí thông tin giảng viên theo yêu cầu giảng viên, xem các loại báo cáo thống kê. Trong số các chức năng này, việc xem lịch học của sinh viên là tương tự chức năng xem lịch dạy của giảng viên.", "order_start": 0, "order_end": 1091, "word_count": 233}
{"parent_id": "877d9fba-fa47-45f2-8b35-ea6f1aa5218d", "subject": "Phantichthietkehttt", "section": "a. Biểu đồ use case tổng quan", "title_path": "a. Biểu đồ use case tổng quan", "content": "[Phantichthietkehttt / a. Biểu đồ use case tổng quan] in giảng viên theo yêu cầu giảng viên, xem các loại báo cáo thống kê. Trong số các chức năng này, việc xem lịch học của sinh viên là tương tự chức năng xem lịch dạy của giảng viên. Nên hai use case này được cho kế thừa từ use case xem TKB. Như vậy, biểu đồ use case tổng quan của hệ thống được trình bày như Hình 3.1, với mô tả các use case như sau: • Đăng kí học: UC này cho phép sinh viên vào hệ thống đăng kí các môn học theo nguyện vọng cá nhân. • Xem lịch học: UC này cho phép sinh viên vào hệ thống xem lịch học cá nhân • Xem điểm: UC này cho phép sinh viên vào hệ thống xem kết quả các môn học của mình. Đăng kí dạy: UC này cho phép giảng viên vào hệ thống để đăng kí lịch dạy của mình vào đầu mỗi kì học. • Xem lịch dạy: UC này cho phép giảng viên xem lịch dạy cá nhân Nhập điểm: UC này cho phép giảng viên nhập điểm các lớp học phần do mình dạy Xem thống kê cá nhân: UC này cho phép giảng viên xem các thống kê cá nhân Quản lí thông tin giảng viên: UC này cho phép giáo vụ quản lí thông tin giảng viên theo yêu cầu của giảng viên tương ứng.", "order_start": 1091, "order_end": 2140, "word_count": 238}
{"parent_id": "877d9fba-fa47-45f2-8b35-ea6f1aa5218d", "subject": "Phantichthietkehttt", "section": "a. Biểu đồ use case tổng quan", "title_path": "a. Biểu đồ use case tổng quan", "content": "[Phantichthietkehttt / a. Biểu đồ use case tổng quan] nhân: UC này cho phép giảng viên xem các thống kê cá nhân Quản lí thông tin giảng viên: UC này cho phép giáo vụ quản lí thông tin giảng viên theo yêu cầu của giảng viên tương ứng. Quản lí thông tin sinh viên: UC này cho phép giáo vụ quản lí thông tin sinh viên theo yêu cầu từ sinh viên tương ứng. • Quản lí thông tin môn học: UC này cho phép giáo vụ quản lí thông tin các môn học • Quản lí thông tin lớp học phần: UC này cho phép giáo vụ quản lí thông tin các lớp học phần. • Xuất bảng điểm: UC này cho phép khảo thí xuất bảng điểm cho sinh viên theo yêu cầu từ sinh viên. • Xem thống kê: UC này cho phép nhân viên quản lí xem các loại báo cáo thống kê.", "order_start": 2140, "order_end": 2794, "word_count": 148}
{"parent_id": "a2b3399f-74ef-47cc-9546-818fc7554f5a", "subject": "Phantichthietkehttt", "section": "b. Use chi tiết của đăng kí học", "title_path": "b. Use chi tiết của đăng kí học", "content": "[Phantichthietkehttt / b. Use chi tiết của đăng kí học] Chức năng đăng kí học có các giao diện tương tác với sinh viên: • Đăng nhập -> đề xuất UC đăng nhập Đăng kí -> đề xuất UC đăng kí Chọn môn học -> đề xuất UC chọn môn học Chọn lớp học phần -> đề xuất UC chọn lớp học phần Đăng nhập, chọn môn học, chọn lớp học phần là bắt buộc mới hoàn thành được việc đăng kí, do đó UC đăng kí include các UC này. Như vậy, biểu đồ UC chi tiết cho modul đăng kí học được trình bày trong Hình 3.2. Các UC được mô tả như sau: • Chọn môn học: UC này cho phép sinh viên chọn môn học để đăng kí học • Chọn lớp học phần: UC này cho phép sinh viên chọn lớp học phần để đăng kí học.", "order_start": 0, "order_end": 605, "word_count": 142}
{"parent_id": "cb8cfa94-e091-4dca-8584-cb501ed637e9", "subject": "Phantichthietkehttt", "section": "c. Use case chi tiết modul nhập điểm", "title_path": "c. Use case chi tiết modul nhập điểm", "content": "[Phantichthietkehttt / c. Use case chi tiết modul nhập điểm] Hình Trong chức năng nhập điểm, giảng viên phải tương tác với các giao diện: • Đăng nhập -> thống nhất với UC đăng nhập Chọn kì học + môn học -> đề xuất UC chọn môn học • Chọn lớp học phần -> đề xuất UC chọn lớp học phần Nhập điểm chi tiết -> đề xuất UC nhập điểm chi tiết • Các UC trên đều bắt buộc thực hiện mới hoàn thành việc nhập điểm -> chúng đều bị chứa trong UC nhập điểm Như vậy, biểu đồ UC chi tiết cho modul nhập điểm được trình bày trong Hình 3.3. Trong đó các UC được mô tả như sau: • Chọn môn học: UC này cho phép giảng viên chọn môn học để nhập điểm Chọn lớp học phần: UC này cho phép giảng viên chọn lớp học phần để nhập điểm Nhập điểm chi tiết: UC cho phép giảng viên nhập/sửa điểm chi tiết từng đầu điểm thành phần của từng sinh viên trong một lớp học phần do mình dạy d.", "order_start": 0, "order_end": 789, "word_count": 177}
{"parent_id": "cb8cfa94-e091-4dca-8584-cb501ed637e9", "subject": "Phantichthietkehttt", "section": "c. Use case chi tiết modul nhập điểm", "title_path": "c. Use case chi tiết modul nhập điểm", "content": "[Phantichthietkehttt / c. Use case chi tiết modul nhập điểm] n chọn lớp học phần để nhập điểm Nhập điểm chi tiết: UC cho phép giảng viên nhập/sửa điểm chi tiết từng đầu điểm thành phần của từng sinh viên trong một lớp học phần do mình dạy d. Use case chi tiết cho modul xem thống kê loại học lực Trong chức năng này, nhân viên quản lí có thể phải tương tác với các giao diện: • Đăng nhập -> thống nhất với UC đăng nhập Xem thống kê loại học lực -> đề xuất UC xem TK loại học lực Xem thống kê các sinh viên của 1 loại học lực -> đề xuất UC xem TK sinh viên của loại học lực. • Xem kết quả của một sinh viên -> đề xuất UC xem điểm các môn học của sinh viên Xêm chi tiết một môn học của sinh viên -> đề xuất UC xem điểm chi tiết 1 môn học của sinh viên. • Các giao diện thống kê lần lượt theo dạng: giao diện sau là tùy chọn từ giao diện trước. Do đó, chúng có quan hệ mở rộng lần lượt cái sau từ cái trước. Như vậy, biểu đồ UC chi tiết cho chức năng thống kê loại học lực được trình bày như trong Hình 3.4.", "order_start": 789, "order_end": 1732, "word_count": 216}
{"parent_id": "cb8cfa94-e091-4dca-8584-cb501ed637e9", "subject": "Phantichthietkehttt", "section": "c. Use case chi tiết modul nhập điểm", "title_path": "c. Use case chi tiết modul nhập điểm", "content": "[Phantichthietkehttt / c. Use case chi tiết modul nhập điểm] giao diện trước. Do đó, chúng có quan hệ mở rộng lần lượt cái sau từ cái trước. Như vậy, biểu đồ UC chi tiết cho chức năng thống kê loại học lực được trình bày như trong Hình 3.4. Trong đó, các UC chi tiết được mô tả như sau: • Xem TK loại học lực: UC này cho phép NVQL xem thống kê số lượng sinh viên trong mỗi loại học lực của một kì học • Xem TK sinh viên của một loại học lực: UC này cho phép NVQL xem TK kết quả các sinh viên của một loại học lực • Xem TK điểm của một sinh viên: UC này cho phép NVQL xem kết quả các môn học của một sinh viên trong một kì học Xem kết quả một một học của một sinh viên: UC này cho phép NVQL xem kết quả chi tiết một môn học của một sinh viên.", "order_start": 1732, "order_end": 2412, "word_count": 159}
{"parent_id": "3b3f9653-0e46-4723-a3dc-a314eaa28014", "subject": "Phantichthietkehttt", "section": "3.2.1 Viết kịch bản", "title_path": "3.2.1 Viết kịch bản", "content": "[Phantichthietkehttt / 3.2.1 Viết kịch bản] Lưu ý tránh sai sót trong kịch bản: • Mỗi use case chính trong biểu đồ use case tổng quan thường có một kịch bản chuẩn và có thể có nhiều kịch bản ngoại lệ. • Use case có bao nhiêu actor thì kịch bản cũng có bấy nhiêu actor • Kịch bản càng chi tiết càng tốt: thông tin hệ thống hiện lên, thông tin người dùng nhập vào...", "order_start": 0, "order_end": 320, "word_count": 70}
{"parent_id": "b1f0176e-1d23-4d3a-8278-55be0d3b23ee", "subject": "Phantichthietkehttt", "section": "a. Kịch bản cho modul đăng kí học", "title_path": "a. Kịch bản cho modul đăng kí học", "content": "[Phantichthietkehttt / a. Kịch bản cho modul đăng kí học] 7. Sinh viên click chọn môn Lập trình hướng đối tượng 8. Giao diện các lớp học phần hiện ra:", "order_start": 0, "order_end": 92, "word_count": 20}
{"parent_id": "5c211f5f-02fd-45cf-b6f9-39d9c53a4281", "subject": "Phantichthietkehttt", "section": "b. Kịch bản cho modul nhập điểm", "title_path": "b. Kịch bản cho modul nhập điểm", "content": "[Phantichthietkehttt / b. Kịch bản cho modul nhập điểm] 6. Giao diện các lớp học phần do giảng viên dạy hiện lên: 7. Giảng viên click vào nhóm số 1 8. Giao diện nhập điểm chi tiết cho nhóm số 1 hiện lên: có thông tin nhóm số 1, môn học lập trình hướng đối tượng, và danh sách điểm sinh viên, dưới cùng là nút lưu: 9. Giảng viên nhập đầu điểm thi: A: 5, C:6, D:7, S:8, V:9 và click lưu 10. Hệ thống báo thành công và quay về giao diện chính của giảng viên.", "order_start": 0, "order_end": 399, "word_count": 89}
{"parent_id": "2b5d87de-968f-4ec3-9e98-8d429f35464b", "subject": "Phantichthietkehttt", "section": "c. Kịch bản cho modul xem thống kê loại học lực", "title_path": "c. Kịch bản cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Kịch bản cho modul xem thống kê loại học lực] Kịch bản chính 5. Quản lí click vào dòng Xuất sắc 6. Giao diện thống kê các sinh viên xuất sắc trong kì kiện lên: 7. Quản lí click vào sinh viên Đoàn văn H 8. Giao diện kết quả các môn học của sinh viên Đoàn văn H hiện lên: 9. Quản lí click vào môn Lập trình hướng đối tượng 10. Giao diện kết quả môn Lập trình hướng đối tượng của Đoàn Văn H hiện lên:", "order_start": 0, "order_end": 351, "word_count": 79}
{"parent_id": "c162aae7-8c4c-4865-9a51-cca94f4b814e", "subject": "Phantichthietkehttt", "section": "3.2.2 Trích lớp thực thể", "title_path": "3.2.2 Trích lớp thực thể", "content": "[Phantichthietkehttt / 3.2.2 Trích lớp thực thể] Tóm tắt các bước trong phương pháp trích danh từ để trích lớp thực thể cho hệ thống: • Bước 1: Mô tả ngắn gọn nhưng phải đầy đủ hệ thống trong một đoạn văn. Có thể mô tả lần lượt các chức năng của hệ thống theo từng người dùng để tránh bị sót. Có thể thay thế bước này bằng cách tổng hợp tất cả các kịch bản (bao gồm kịch bản chuẩn và kịch bản ngoại lệ) của tất cả các use case của hệ thống. • Bước 2: Trích các danh từ xuất hiện trong đoạn văn của bước 1. Mỗi danh từ xuất hiện chỉ cần tính một lần. Bước 3: Đánh giá các danh từ. ◦ Một là đề xuất danh từ thành một lớp thực thể. ◦ Hai là đề xuất danh từ thành thuộc tính của lớp nào đó. ◦ Ba là loại bỏ danh từ đó vì quá chung chung, trừu tượng, hoặc ngoài pham vi quản lí của hệ thống. • Bước 4: Xác định quan hệ số lượng giữa các thực thể. ◦ Nếu quan hệ 1-1 thì có thể giữ nguyên hoặc gộp lại. ◦ Nếu quan hệ 1-n thì giữ nguyên. ◦ Nếu quan hệ là n-n thì phải đề xuất các lớp thực thể trung gian để tách thành ít nhất 2 quan hệ 1-n.", "order_start": 0, "order_end": 983, "word_count": 229}
{"parent_id": "c162aae7-8c4c-4865-9a51-cca94f4b814e", "subject": "Phantichthietkehttt", "section": "3.2.2 Trích lớp thực thể", "title_path": "3.2.2 Trích lớp thực thể", "content": "[Phantichthietkehttt / 3.2.2 Trích lớp thực thể] hệ 1-1 thì có thể giữ nguyên hoặc gộp lại. ◦ Nếu quan hệ 1-n thì giữ nguyên. ◦ Nếu quan hệ là n-n thì phải đề xuất các lớp thực thể trung gian để tách thành ít nhất 2 quan hệ 1-n. • Bước 5: Xác định quan hệ đối tượng giữa các thực thể: quan hệ kế thừa, hợp thành (aggregation), gắn chặt (composition), liên kết (association), phụ thuộc (dependence)... Lưu ý khi vẽ biểu đồ lớp thực thể pha phân tích: • Tên lớp, tên thuộc tính có thể dùng ngôn ngữ tự nhiên vẫn được, tuy nhiên, nên đặt tên theo chuẩn code convention để vào pha thiết kế đỡ phải thay đổi. • Thuộc tính chưa cần kiểu dữ liệu • Các lớp thực thể chưa cần thuộc tính id trong pha phân tích. Áp dụng cho hệ thống quản lí đăng kí tín chỉ, các bước được thực hiện như sau:", "order_start": 983, "order_end": 1714, "word_count": 157}
{"parent_id": "ad393f42-9208-4be3-bc15-03fc811ac8a9", "subject": "Phantichthietkehttt", "section": "Bước 1: Mô tả hệ thống trong một đoạn văn", "title_path": "Bước 1: Mô tả hệ thống trong một đoạn văn", "content": "[Phantichthietkehttt / Bước 1: Mô tả hệ thống trong một đoạn văn] Hệ thống là một trang web hỗ trợ quản lí đăng kí tín chỉ và điểm của sinh viên trong một trường đại học. Trong đó, sinh viên được phép đăng kí các môn học, lớp học phần theo lịch học cá nhân vào đầu mỗi học kì; xem lịch học hàng ngày với đầy đủ thông tin về kíp học, ngày học, tuần học, phòng học, tòa nhà; xem kết quả học chi tiết với từng môn học, từng đầu điểm thành phần của môn học, cũng như điểm trung bình tích lũy các kì học của từng năm học hay từ đầu khóa học theo ngành học của sinh viên. Giảng viên được phép đăng kí dạy các môn học, các lớp học phần theo nguyện vọng cá nhân, sau đó sẽ được bộ môn quản lí duyệt và phân công chính thức; nhập hay sửa điểm của các sinh viên trong các lớp học phần do mình dạy; xem lịch dạy hàng tuần; và có thể xem các thống kê cá nhân về tỉ lệ sinh viên qua môn, điểm trung bình của sinh viên theo các môn học hay lớp học phần do mình dạy. Nhân viên giáo vụ có thể quản lí thông tin liên quan đến các môn học; lên lịch hay điều chỉnh lịch học cho các lớp học phần; quản lí thông tin sinh viên theo yêu cầu của sinh viên.", "order_start": 0, "order_end": 1066, "word_count": 239}
{"parent_id": "ad393f42-9208-4be3-bc15-03fc811ac8a9", "subject": "Phantichthietkehttt", "section": "Bước 1: Mô tả hệ thống trong một đoạn văn", "title_path": "Bước 1: Mô tả hệ thống trong một đoạn văn", "content": "[Phantichthietkehttt / Bước 1: Mô tả hệ thống trong một đoạn văn] Nhân viên giáo vụ có thể quản lí thông tin liên quan đến các môn học; lên lịch hay điều chỉnh lịch học cho các lớp học phần; quản lí thông tin sinh viên theo yêu cầu của sinh viên. Nhân viên khảo thí có thể xuất bảng điểm toàn khóa theo yêu cầu của sinh viên. Nhân viên quản lí có thể quản lí thông tin giảng viên theo yêu cầu của giảng viên; xem các loại thống kê: thống kê loại học lực, thống kê sinh viên theo kết quả học, theo ngành học, theo khoa, theo năm học, hay học kì; thống kê giảng viên theo khối lượng giảng dạy, theo kết quả sinh viên, theo khoa hay bộ môn.", "order_start": 1066, "order_end": 1637, "word_count": 123}
{"parent_id": "35bbd80c-18fb-4821-b64f-e4429fffff5b", "subject": "Phantichthietkehttt", "section": "Bước 2: Trích các danh từ xuất hiện trong đoạn văn", "title_path": "Bước 2: Trích các danh từ xuất hiện trong đoạn văn", "content": "[Phantichthietkehttt / Bước 2: Trích các danh từ xuất hiện trong đoạn văn] • Các danh từ liên quan đến người: sinh viên, nhân viên, giảng viên, nhân viên giáo vụ, nhân viên khảo thí, nhân viên quản lí • Các danh từ liên quan đến vật: trường đại học, toà nhà, phòng học, bảng điểm • Các danh từ liên quan đến thông tin: Khoa, ngành học, bộ môn, năm học, học kì, môn học, lớp học phần, điểm thành phần, điểm tích lũy, điểm trung bình môn, tín chỉ, học lực, khóa học, lịch học, thời khóa biểu, tuần học, ngày học, kíp học, báo cáo thống kê, thống kê học lực, thống kê sinh viên, thống kê giảng viên, thống kê môn học, thống kê học kì.", "order_start": 0, "order_end": 556, "word_count": 117}
{"parent_id": "1a7c7c8c-b81b-4404-bbfc-c3793b2d41b2", "subject": "Phantichthietkehttt", "section": "ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính", "title_path": "ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính", "content": "[Phantichthietkehttt / ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính] • Các danh từ trừu tượng: hệ thống, trang web, báo cáo thống kê, thông tin -> loại. • Các danh từ liên quan đến người: ◦ Thành viên hệ thống -> Thanhvien (trừu tượng): tên, tên đăng nhập, mật khẩu, ngày sinh, địa chỉ, email, điện thoại, vai trò, ghi chú. ◦ Sinh viên -> lớp Sinhvien: kế thừa lớp Thành viên, thêm thuộc tính: mã sinh viên. ◦ Nhân viên -> lớp Nhanvien (trừu tượng): kế thừa lớp Thành viên, thêm thuộc tính: vị trí. ◦ Giảng viên -> lớp Giangvien: kế thừa Thanhvien ◦ Nhân viên giáo vụ -> lớp Giaovu: Kế thừa Thanhvien ◦ Nhân viên khảo thí -> lớp NVKhaothi: kế thừa Thanhvien ◦ Nhân viên quản lí -> lớp NVQuanli: Kế thừa Thanhvien • Các danh từ liên quan đến vật: ◦ Trường đại học -> lớp Truong: tên, địa chỉ, mô tả ◦ Tòa nhà -> lớp Toanha: Tên, mô tả ◦ Phòng học -> lớp Phonghoc: Tên, sức chứa, mô tả ◦ Bảng điểm, là số nhiều của một điểm của một môn học nên không đề xuất lớp.", "order_start": 0, "order_end": 891, "word_count": 187}
{"parent_id": "1a7c7c8c-b81b-4404-bbfc-c3793b2d41b2", "subject": "Phantichthietkehttt", "section": "ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính", "title_path": "ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính", "content": "[Phantichthietkehttt / ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính] n, địa chỉ, mô tả ◦ Tòa nhà -> lớp Toanha: Tên, mô tả ◦ Phòng học -> lớp Phonghoc: Tên, sức chứa, mô tả ◦ Bảng điểm, là số nhiều của một điểm của một môn học nên không đề xuất lớp. • Các danh từ thông tin: ◦ Khoa + ngành -> lớp Khoa: Tên, mô tả ◦ Bộ môn -> lớp Bomon: Tên, mô tả ◦ Năm học -> lớp Namhoc: Tên, mô tả ◦ Học kì -> lớp Hocki: Tên, mô tả ◦ Môn học -> lớp Monhoc: Tên, số tín chỉ, mô tả ◦ Lớp học phần -> lớp Lophocphan: Tên ◦ Đầu điểm thành phần -> Daudiem: tên, mô tả ◦ Điểm tích lũy, điểm trung mình môn là thông tin dẫn xuất nên đề xuất là thuộc tính của một lớp nào đó, quyết định sau. ◦ Tín chỉ là thuộc tính của môn học ◦ Học lực -> lớp Loaihocluc: tên, mô tả ◦ Khóa học là thuộc tính của sinh viên học một ngành học. ◦ Lịch học -> lớp Lichhoc: liên quan đến tuần học, ngày học, kíp học, phòng học, giảng viên. ◦ Thời khóa biểu là số nhiều của lịch học.", "order_start": 891, "order_end": 1761, "word_count": 203}
{"parent_id": "1a7c7c8c-b81b-4404-bbfc-c3793b2d41b2", "subject": "Phantichthietkehttt", "section": "ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính", "title_path": "ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính", "content": "[Phantichthietkehttt / ước 3: Đánh giá và lựa chọn các danh từ làm lớp thực thể hoặc thuộc tính] thuộc tính của sinh viên học một ngành học. ◦ Lịch học -> lớp Lichhoc: liên quan đến tuần học, ngày học, kíp học, phòng học, giảng viên. ◦ Thời khóa biểu là số nhiều của lịch học. ◦ Tuần học -> lớp Tuanhoc: tên, mô tả ◦ Ngày học -> lớp Ngayhoc: tên thứ ngày trong tuần, mô tả ◦ Kíp học -> lớp Kip: tên, mô tả ◦ Thống kê loại học lực -> lớp TKLoaihocluc ◦ Thống kê môn học -> lớp TKMonhoc ◦ Thống kê giảng viên -> lớp TKGiangvien ◦ Thống kê sinh viên -> TKSinhvien ◦ Thống kê học kì -> TKHocki", "order_start": 1761, "order_end": 2253, "word_count": 108}
{"parent_id": "b7126a9f-da00-4607-a008-be47fd64db0e", "subject": "Phantichthietkehttt", "section": "Bước 4: Xác định quan hệ số lượng giữa các thực thể", "title_path": "Bước 4: Xác định quan hệ số lượng giữa các thực thể", "content": "[Phantichthietkehttt / Bước 4: Xác định quan hệ số lượng giữa các thực thể] Trường có nhiều khoa/ngành -> quan hệ giữa Truong và Khoa là 1-n • Khoa có nhiều bộ môn -> Khoa - Bomon là 1-n • Bộ môn có nhiều giảng viên -> Bomon - Giangvien là 1-n Trường có nhiều tòa nhà -> Truong - Toanha là 1-n Tòa nhà có nhiều phòng học -> Toanha - Phonghoc là 1-n Một năm học có nhiều học kì, một học kì có thể nằm trong nhiều năm học -> Namhoc - Hocki là n-n -> đề xuất lớp Kihoc kết nối giữa 1 năm học và 1 học kì (Kihoc # Hocki). Một kì học có nhiều môn học, một môn học có thể học trong nhiều kì học -> Kihoc - Monhoc là n-n -> đề xuất lớp MonhocKihoc xác định duy nhất một môn học dạy trong một kì học. Một môn học có một số môn học tiên quyết. Một môn học, trong một kì học, có nhiều lớp học phần -> MonhocKihoc - Lophocphan là 1-n. Một môn học có nhiều đầu điểm thành phần, một đầu điểm thành phần có thể xuất hiện trong nhiều môn học -> Monhoc - Daudiem là n-n -> đề xuất lớp MonhocDaudiem xác định duy nhất một đầu điểm trong một môn học.", "order_start": 0, "order_end": 956, "word_count": 214}
{"parent_id": "b7126a9f-da00-4607-a008-be47fd64db0e", "subject": "Phantichthietkehttt", "section": "Bước 4: Xác định quan hệ số lượng giữa các thực thể", "title_path": "Bước 4: Xác định quan hệ số lượng giữa các thực thể", "content": "[Phantichthietkehttt / Bước 4: Xác định quan hệ số lượng giữa các thực thể] m thành phần, một đầu điểm thành phần có thể xuất hiện trong nhiều môn học -> Monhoc - Daudiem là n-n -> đề xuất lớp MonhocDaudiem xác định duy nhất một đầu điểm trong một môn học. Một sinh viên có thể học nhiều ngành học/khoa, một ngành/khoa có thể có nhiều sinh viên -> Sinhvien - Khoa là n-n -> đề xuất lớp SinhvienKhoa xác định duy nhất một sinh viên học một ngành/khoa nhất định. Một sinh viên, đối với một ngành học, có thể học nhiều lớp học phần của nhiều môn học (mỗi môn học 1 lớp), mỗi lớp học phần có thể có nhiều sinh viên -> SinhvienKhoa - Lophocphan là n-n -> đề xuất lớp Dangkihoc xác định duy nhất một sinh viên đăng kí vào một lớp học phần của một môn học nhất định. Một Dangkihoc có nhiều MonhocDaudiem, 1 MonhocDaudiem có nhiều Dangkihoc, nên đề xuất lớp Ketqua xác định duy nhất đầu điểm thành phần của sinh viên đã học môn học xác định. Một lớp học phần có nhiều buổi học (lịch học) khác nhau -> Lophocphan - Lichhoc là 1- n. • Tương tự, các quan hệ Giangvien - Lichhoc, Phonghoc - Lichhoc, Tuanhoc - Lichhoc, Ngayhoc - Lichhoc, Kiphoc - Lichhoc đều là 1-n.", "order_start": 956, "order_end": 2034, "word_count": 218}
{"parent_id": "b7126a9f-da00-4607-a008-be47fd64db0e", "subject": "Phantichthietkehttt", "section": "Bước 4: Xác định quan hệ số lượng giữa các thực thể", "title_path": "Bước 4: Xác định quan hệ số lượng giữa các thực thể", "content": "[Phantichthietkehttt / Bước 4: Xác định quan hệ số lượng giữa các thực thể] học) khác nhau -> Lophocphan - Lichhoc là 1- n. • Tương tự, các quan hệ Giangvien - Lichhoc, Phonghoc - Lichhoc, Tuanhoc - Lichhoc, Ngayhoc - Lichhoc, Kiphoc - Lichhoc đều là 1-n. Ngoài ra, thông tin Họ và tên có thể tách thành một lớp thực thể riêng. Thông tin địa chỉ cũng có thể tách thành một lớp thực thể riêng.", "order_start": 2034, "order_end": 2350, "word_count": 64}
{"parent_id": "c2bd0494-f2e5-4a37-bebd-051a2b5be51a", "subject": "Phantichthietkehttt", "section": "Bước 5: Xác định quan hệ đối tượng giữa các thực thể", "title_path": "Bước 5: Xác định quan hệ đối tượng giữa các thực thể", "content": "[Phantichthietkehttt / Bước 5: Xác định quan hệ đối tượng giữa các thực thể] • Khoa là thành phần của Trường • Bộ môn là thành phần của Khoa. • Giảng viên là thành phần của Bộ môn • Môn học là thành phần của Bộ môn • Tòa nhà là thành phần của Trường • Phòng học là thành phần của tòa nhà Năm học và Học kì liên kết tạo ra Kì học duy nhất • Sinh viên và ngành học liên kết tạo ra SinhvienKhoa duy nhất. • Môn học và đầu điểm liên kết tạo ra MonhocDaudiem duy nhất • Sinh viên và lớp học phần liên kết tạo ra Dangkihoc duy nhất Đăng kí học và MonhocDaudiem liên kết tạo ra điểm thành phần duy nhất cho sinh viên đối với môn học. Thông tin môn học nằm trong thông tin lớp học phần • Thông tin lớp học phần, giảng viên, phòng học, tuần học, ngày học, kíp học nằm trong thông tin lịch học. Thông tin địa chỉ nằm trong thông tin về thành viên, trường Thông tin họ và tên nằm trong thông tin thành viên. Các lớp thống kê kế thừa từ các thực thể tương ứng. Kết quả thu được biểu đồ lớp thực thể pha phân tích toàn hệ thống như trong Hình 3.5.", "order_start": 0, "order_end": 957, "word_count": 211}
{"parent_id": "cbd50b69-3a67-4632-8009-0f15c7de602c", "subject": "Phantichthietkehttt", "section": "3.2.3 Trích các lớp biên và điều khiển", "title_path": "3.2.3 Trích các lớp biên và điều khiển", "content": "[Phantichthietkehttt / 3.2.3 Trích các lớp biên và điều khiển] Tóm tắt các bước thực hiện để vẽ biểu đồ lớp pha phân tích: • Bước 1: Mỗi giao diện xuất hiện có thể đề xuất thành một lớp biên. Bước 2: Với mỗi giao diện, xem xét cần các thành phần nào để nhận dữ liệu vào, hiện dữ liệu lên, hay submit dữ liệu vào hệ thống. Mỗi thành phần như vậy đề xuất thành một thuộc tính của giao diện, đặt tên với các tiền tố tương ứng: ◦ in: tiền tố của tên thuộc tính nhận dữ liệu vào (ô text, ô chọn....) ◦ out: tiền tố của tên thuộc tính hiện dữ liệu lên (bảng biểu, thông báo...) ◦ sub: tiền tố của tên thuộc tính để submit dữ liệu (nút nhấn, liên kết...) • Bước 3: Với mỗi chức năng phải thực hiện tầng dưới tầng giao diện, thực hiện đề xuất phương thức: ◦ Đề xuất tên phương thức (có thể đặt tên gợi nhớ, và tuân thủ code convention) ◦ Xác định tham số đầu vào là gì, tham số đầu ra là gì. ◦ Đề xuất gán hành động tương ứng với chức năng này cho lớp thực thể nào. Theo nguyên tắc: ▪ Nếu tham số đầu ra liên quan lớp thực thể nào thì gán phương thức này cho lớp đó Nếu không, xét tham số đầu vào.", "order_start": 0, "order_end": 1026, "word_count": 229}
{"parent_id": "cbd50b69-3a67-4632-8009-0f15c7de602c", "subject": "Phantichthietkehttt", "section": "3.2.3 Trích các lớp biên và điều khiển", "title_path": "3.2.3 Trích các lớp biên và điều khiển", "content": "[Phantichthietkehttt / 3.2.3 Trích các lớp biên và điều khiển] ương ứng với chức năng này cho lớp thực thể nào. Theo nguyên tắc: ▪ Nếu tham số đầu ra liên quan lớp thực thể nào thì gán phương thức này cho lớp đó Nếu không, xét tham số đầu vào. Nếu tham số đầu vào chỉ liên quan đến 1 thực thể thì gán phương thức này cho thực thể đó. Nếu tham số vào liên quan đến hai hay nhiều thực thể, thì tìm thực thể nào nhỏ nhất mà chứa được càng nhiều càng tốt các tham số đầu vào, gán phương thức này cho lớp thực thể đó. • Vẽ biểu đồ lớp pha phân tích cho từng modul. Lưu ý khi vẽ biểu đồ lớp pha phân tích: • Tên lớp, tên thuộc tính có thể dùng ngôn ngữ tự nhiên vẫn được, tuy nhiên, nên đặt tên theo chuẩn code convention để vào pha thiết kế đỡ phải thay đổi. Thuộc tính chưa cần kiểu dữ liệu Quan hệ giữa các lớp thực thể phải thống nhất, đồng bộ với quan hệ giữa chúng trong biểu đồ lớp thực thể đã vẽ ở bước trước.", "order_start": 1026, "order_end": 1874, "word_count": 191}
{"parent_id": "364d47f5-57ec-4bdd-85ab-62d47e7578c0", "subject": "Phantichthietkehttt", "section": "a. Phân tích tĩnh modul đăng kí học", "title_path": "a. Phân tích tĩnh modul đăng kí học", "content": "[Phantichthietkehttt / a. Phân tích tĩnh modul đăng kí học] • Ban đầu, giao diện chính của sinh viên -> đề xuất lớp GDChinhSV, cần các thành phần: ◦ chọn đăng kí học: kiểu submit • Bước 2, giao diện chọn kì học, ngành học -> đề xuất lớp GDChonnganh, cần có các thành phần: ◦ Chọn ngành học để đăng kí: vừa input, vừa output ◦ Chọn kì học: vừa input, vừa output ◦ Nút chọn tiếp tục: kiểu submit • Để có danh sách ngành học để chọn ở bước 2, cần xử lí dưới hệ thống: ◦ Tìm các ngành học của sinh viên ◦ input: sinh viên ◦ output: danh sách Khoa ◦ đề xuất phương thức getKhoacuaSV(), gán cho lớp Khoa. • Để có danh sách kì học đang mở đăng kí, cần xử lí bên dưới hệ thống: ◦ Tìm các kì học đang mở đăng kí ◦ input: không có ◦ output: danh sách Kihoc ◦ đề xuất phương thức getKihocDangki(), gán vào lớp Kihoc • Bước 4, giao diện đăng kí -> đề xuất lớp GDDangki, cần có các thành phần: ◦ Bảng danh sách các môn học: vừa output, vừa submit ◦ Nút tiếp tục, nút lưu: kiểu submit • Để có danh sách các đăng kí đã có, cần xử lí bên dưới hệ thống: ◦ Tìm các môn học/lớp học phần đã đăng của sinh viên ở kì học đã chọn ◦ input: học kì, sinh viên ◦ output: danh sách Dangki", "order_start": 0, "order_end": 1100, "word_count": 243}
{"parent_id": "364d47f5-57ec-4bdd-85ab-62d47e7578c0", "subject": "Phantichthietkehttt", "section": "a. Phân tích tĩnh modul đăng kí học", "title_path": "a. Phân tích tĩnh modul đăng kí học", "content": "[Phantichthietkehttt / a. Phân tích tĩnh modul đăng kí học] anh sách các đăng kí đã có, cần xử lí bên dưới hệ thống: ◦ Tìm các môn học/lớp học phần đã đăng của sinh viên ở kì học đã chọn ◦ input: học kì, sinh viên ◦ output: danh sách Dangkihoc ◦ đề xuất phương thức getDangkicuaSV(), gán vào lớp Dangkihoc • Bước 6, giao diện chọn môn học -> đề xuất lớp GDMonhoc, cần các thành phần: ◦ bảng danh sách các môn học có thể đăng kí: vừa output, vừa submit • Để hiển thị được danh sách các môn học, cần xử lí trước dưới hệ thống: ◦ Tìm các môn học có thể dăng kí của sinh viên ◦ input: sinh viên, kì học ◦ output: danh sách Monhoc ◦ đề xuất phướng thức getMonhoccuaSV(), gán cho lớp Monhoc. Bước 8, giao diện lớp học phần -> đề xuất lớp GDLophocphan, cần có: ◦ bảng danh sách lớp học phần: vừa output, vừa submit Để hiển thị danh sách lớp học phần, cần xử lí trước từ dưới hệ thống: ◦ Tìm các lớp học phần của môn học ◦ input: monhoc, kì học ◦ output: danh sách Lophocphan ◦ đề xuất phương thức getLHPcuaMH(), gán cho lớp Lophocphan. Kết quả thu được biểu đồ lớp cho modul đăng kí học như trong Hình 3.6.", "order_start": 1100, "order_end": 2139, "word_count": 220}
{"parent_id": "7de52991-0ac0-44df-9a42-cd6be03c0fca", "subject": "Phantichthietkehttt", "section": "b. Phân tích tĩnh cho modul nhập điểm", "title_path": "b. Phân tích tĩnh cho modul nhập điểm", "content": "[Phantichthietkehttt / b. Phân tích tĩnh cho modul nhập điểm] • Ban đầu, giao diện chính của giảng viên -> đề xuất lớp GDChinhGV, cần có: ◦ chọn nhập/sửa điểm: kiểu submit Bước 2, giao diện chọn kì học -> đề xuất GDKihoc, cần có: ◦ danh sách kì học: vừa input, vừa output ◦ nút tiếp tục: kiểu submit • Để có danh sách kì học đang học, cần xử lí dưới hệ thống: ◦ Tìm các kì học đnag học ◦ input: không có ◦ output: danh sách các Kihoc ◦ đề xuất phương thức getKihocDanghoc(), gán cho lớp Kihoc. • Bước 4, giao diện chọn môn học -> đề xuất GDMonhoc, cần có: ◦ danh sách các môn học: vừa output, vừa submit • Sau khi chọn kì học, cần xử lí dưới hệ thống để lấy danh sách môn học: ◦ Tìm các môn học của giảng viên đang dạy ◦ input: giảng viên, kì học ◦ output: danh sách các MonhocDaudiem ◦ đề xuất phương thức getMHcuaGV(), gán cho lớp Monhoc.", "order_start": 0, "order_end": 778, "word_count": 166}
{"parent_id": "7de52991-0ac0-44df-9a42-cd6be03c0fca", "subject": "Phantichthietkehttt", "section": "b. Phân tích tĩnh cho modul nhập điểm", "title_path": "b. Phân tích tĩnh cho modul nhập điểm", "content": "[Phantichthietkehttt / b. Phân tích tĩnh cho modul nhập điểm] nh sách môn học: ◦ Tìm các môn học của giảng viên đang dạy ◦ input: giảng viên, kì học ◦ output: danh sách các MonhocDaudiem ◦ đề xuất phương thức getMHcuaGV(), gán cho lớp Monhoc. • Bước 6, giao diện chọn lớp học phần -> đề xuất lớp GDLophocphan, cần có: ◦ bảng danh sách lớp học phần: vừa output, vừa submit • Để có danh sách lớp học phần, cần xử lí trước từ dưới hệ thống: ◦ Lấy danh sách các lớp học phần của môn học do giảng viên dạy ◦ input: môn học, giảng viên ◦ output: danh sách Lophocphan ◦ đề xuất phương thức getLHPcuaGV(), gán cho lớp Lophocphan • Bước 8, giao diện nhập điểm -> đề xuất lớp GDNhapdiem, cần có: ◦ Danh sách sinh viên + các đầu điểm: vừa output, vừa input ◦ Nút lưu, nút reset: kiểu submit • Để có danh sách sinh viên, cần xử lí trước từ dưới hệ thống: ◦ lấy danh sách sinh viên + các đầu điểm đã có lên ◦ input: lớp học phần ◦ output: thông tin sinh viên + các đầu điểm thành phần của môn học (Dangkihoc) ◦ đề xuất phương thức getDiemSVtheoLHP(), gán cho lớp Dangkihoc.", "order_start": 778, "order_end": 1776, "word_count": 208}
{"parent_id": "7de52991-0ac0-44df-9a42-cd6be03c0fca", "subject": "Phantichthietkehttt", "section": "b. Phân tích tĩnh cho modul nhập điểm", "title_path": "b. Phân tích tĩnh cho modul nhập điểm", "content": "[Phantichthietkehttt / b. Phân tích tĩnh cho modul nhập điểm] iểm đã có lên ◦ input: lớp học phần ◦ output: thông tin sinh viên + các đầu điểm thành phần của môn học (Dangkihoc) ◦ đề xuất phương thức getDiemSVtheoLHP(), gán cho lớp Dangkihoc. • Sau khi click lưu điểm, cần xử lí dưới hệ thống: ◦ lưu danh sách sinh viên + các đầu điểm vào ◦ input: thông tin sinh viên + các đầu điểm thành phần của môn học (Dangkihoc) ◦ output: thành công hay không ◦ đề xuất phương thức luuDiemSVtheoLHP(), gán cho lớp Dangkihoc. Kết quả thu được biểu đồ lớp phân tích modul nhập điểm như trong Hình 3.7.", "order_start": 1776, "order_end": 2302, "word_count": 106}
{"parent_id": "522e3232-db75-42ea-a45e-70ad79a5e678", "subject": "Phantichthietkehttt", "section": "c. Phân tích tĩnh cho modul xem thống kê loại học lực", "title_path": "c. Phân tích tĩnh cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Phân tích tĩnh cho modul xem thống kê loại học lực] Ban đầu, giao diện chính của quản lí -> đề xuất lớp GDChinhQL, cần có ◦ chọn xem thống kê: kiểu submit Bước 2, giao diện chọn loại thống kê và kì học -> đề xuất lớp GDChonTK, cần có: ◦ danh sách loại thống kê: vừa input, vừa output ◦ danh sách kì học đã kết thúc: vừa input, vừa output ◦ nút xem: kiểu submit • Đề có danh sách kì học đã kết thúc, cần xử lí trước từ dưới hệ thống: lấy danh sách kì học đã kết thúc C input: không có ◦ output: tất cả kì học đã kết thúc ◦ đề xuất phương thức getKihocDaxong(), gán cho lớp Kihoc • Bước 4+6, giao diện thống kê loại học lực -> đề xuất lớp GDTKLoaihocluc, cần có: ◦ danh sách thống kê loại học lực: output, submit • Để có dữ liệu thống kê, cần xử lí từ dưới hệ thống: ◦ lấy dữ liệu thống kê loại học lực của học kì đã chọn ◦ input: học kì ◦ output: danh sách TKLoaihocluc ◦ đề xuất phương thức getTKHocluc(), gán cho lớp TK • Bước 8, giao diện các sinh viên của loại học lực -> GDSVLoaihocluc, cần có: ◦ Danh sách các sinh viên + điểm: kiểu output, submit • Để có danh sách các sinh viên và điểm tổng kết, cần xử lí: • Bước 10, giao diện danh sách điểm cá", "order_start": 0, "order_end": 1100, "word_count": 241}
{"parent_id": "522e3232-db75-42ea-a45e-70ad79a5e678", "subject": "Phantichthietkehttt", "section": "c. Phân tích tĩnh cho modul xem thống kê loại học lực", "title_path": "c. Phân tích tĩnh cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Phân tích tĩnh cho modul xem thống kê loại học lực] -> GDSVLoaihocluc, cần có: ◦ Danh sách các sinh viên + điểm: kiểu output, submit • Để có danh sách các sinh viên và điểm tổng kết, cần xử lí: • Bước 10, giao diện danh sách điểm các môn học của sinh viên -> lớp GDDiemSV, cần: ◦ danh sách điểm các môn học của sinh viên: output, submit • Để có danh sách điểm các môn học của sinh viên, cần xử lí: ◦ lấy danh sách điểm các môn học của sinh viên ◦ input: sinh viên, học kì ◦ output: danh sách các điểm sinh viên (Dangkihoc) ◦ đề xuất phương thức getDSDiemSV(), gán cho lớp Dangkihoc • Bước 12, giao diện điểm chi tiết môn học -> lớp GDDiemMHcuaSV, cần có: ◦ thông tin môn học: output ◦ danh sách các đầu điểm và điểm: output • Để có thông tin điểm chi tiết, cần xử lí: ◦ lấy điểm chi tiết môn học của sinh viên ◦ input: môn học, sinh viên ◦ output: điểm chi tiết của môn học (Dangkihoc) ◦ đề xuất phương thức getDiemMHcuaSV(), gán cho lớp Dangkihoc. Kết quả thu được biểu đồ lớp phân tích modul xem thống kê loại học lực như trong Hình 3.8.", "order_start": 1100, "order_end": 2087, "word_count": 207}
{"parent_id": "67bd81ca-77b0-46d4-9c5d-9c0b1472e498", "subject": "Phantichthietkehttt", "section": "3.2.4 Phân tích hoạt động", "title_path": "3.2.4 Phân tích hoạt động", "content": "[Phantichthietkehttt / 3.2.4 Phân tích hoạt động] Tóm tắt các bước thực hiện để vẽ biểu đồ trạng thái của một modul/chức năng: • Bước 1: Mỗi trạng thái chờ tương ứng với mỗi lần hệ thống hiển thị 1 giao diện để chờ tương tác của người dùng Bước 2: Điều kiện chuyển trạng thái tương ứng với hành động của người dùng trên giao diện tương ứng. Tóm tắt các bước thực hiện để vẽ biểu đồ tuần tự/giao tiếp pha phân tích: • Bước 1: Viết kịch bản phiên bản 2 từ biểu đồ lớp của modul: Mỗi bước là một hành động của một lớp nào đó trong biểu đồ lớp, hoặc là của tác nhân. Bước 2: Vẽ biểu đồ giao tiếp cho kịch bản chuẩn: các bước tương ứng với các bước trong kịch bản phiên bản 2. Quan hệ giữa các lớp phải thống nhất với quan hệ giữa chúng trong biểu đồ lớp của modul. Bước 3: chuyển hóa biểu đồ giao tiếp thành biểu đồ tuần tự cho kịch bản chuẩn. Kiểm tra lại các bước đúng tuần tự và logic nghiệp vụ.", "order_start": 0, "order_end": 844, "word_count": 185}
{"parent_id": "252ecea4-635f-4c2c-a01d-1a383e50e657", "subject": "Phantichthietkehttt", "section": "a. Modul đăng kí học", "title_path": "a. Modul đăng kí học", "content": "[Phantichthietkehttt / a. Modul đăng kí học] Biểu đồ trạng thái mô tả hoạt động của modul như biểu diễn trong Hình 3.9: Từ giao diện chính của sinh viên, nếu chức năng đăng kí được chọn thì chuyển sang giao diện chọn ngành học, • Từ giao diện chọn ngành học, khi ngành được chọn, hệ thống chuyển sang giao diện đăng kí học. Tại giao diện đăng kí, nếu click tiếp tục thì chuyển sang giao diện chọn môn học. Nếu chọn một lớn đã đăng kí thì chuyển sang giao diện chọn lớp học phần để chọn lại. Nếu chọn lưu thì lưu và kết thúc. • Tại giao diện chọn môn học, nếu môn học được chọn thì chuyển sang giao diện chọn lớp học phần. Tại giao diện chọn lớp học phần, sau khi chọn lớp học phần thì quay về giao diện đăng kí. Kịch bản v.2 cho modul đăng kí môn học như sau (Hình 3.10): 1. Tại giao diện chính của sinh viên sau khi đăng nhập, sinh viên click chọn đăng kí. 2. Lớp GDChinhSV gọi lớp GDChonnganh 3. GDChonnganh gọi lớp Kihoc yêu cầu tìm danh sách các kì học đnag mở đăng kí 4. Lớp Kihoc tìm các kì học đang mở đăng kí 5. Lớp Kihoc trả kết quả lại cho lớp GDChonnganh 6. GDChonnganh gọi lớp Khoa yêu cầu tìm danh sách ngành 7.", "order_start": 0, "order_end": 1079, "word_count": 230}
{"parent_id": "252ecea4-635f-4c2c-a01d-1a383e50e657", "subject": "Phantichthietkehttt", "section": "a. Modul đăng kí học", "title_path": "a. Modul đăng kí học", "content": "[Phantichthietkehttt / a. Modul đăng kí học] h các kì học đnag mở đăng kí 4. Lớp Kihoc tìm các kì học đang mở đăng kí 5. Lớp Kihoc trả kết quả lại cho lớp GDChonnganh 6. GDChonnganh gọi lớp Khoa yêu cầu tìm danh sách ngành 7. Lớp Khoa tìm các ngành học của sinh viên 8. Lớp Khoa trả kết quả lại cho lớp GDChonnganh 9. Lớp GDChonnganh hiển thị cho sinh viên 10. Sinh viên click 1 ngành của mình học 11. Lớp GDChonnganh gọi lớp GDDangki 12. Lớp GDDangki gọi lớp Dangkihoc yêu cầu tìm thông tin đã đăng kí 13. Lớp Dangkihoc lấy thông tin đã đăng kí của sinh viên 14. Lớp Dangkihoc trả kết quả lại cho lớp GDDangki. 15. Lớp GDDangki hiển thị cho sinh viên. 16. Sinh viên chọn tiếp tục đăng kí 17. Lớp GDDangki gọi GDMonhoc 18. Lớp GDMonhoc gọi lớp Monhoc yêu cầu tìm các môn học được đăng kí 19. Lớp Monhoc tìm các môn học mà sinh viên được đăng kí 20. Lớp Monhoc trả kết quả lại cho lớp GDMonhoc 21. Lớp GDMonhoc hiển thị cho sinh viên 22. Sinh viên click chọn 1 môn học 23. Lớp GDMonhoc gọi lớp GDLophocphan 24. Lớp GDLophocphan gọi lớp Lophocphan yếu cầu tìm các lớp học phần của môn học 25. Lớp Lophocphan tìm các lớp học phần của môn học 26.", "order_start": 1079, "order_end": 2176, "word_count": 228}
{"parent_id": "252ecea4-635f-4c2c-a01d-1a383e50e657", "subject": "Phantichthietkehttt", "section": "a. Modul đăng kí học", "title_path": "a. Modul đăng kí học", "content": "[Phantichthietkehttt / a. Modul đăng kí học] n học 23. Lớp GDMonhoc gọi lớp GDLophocphan 24. Lớp GDLophocphan gọi lớp Lophocphan yếu cầu tìm các lớp học phần của môn học 25. Lớp Lophocphan tìm các lớp học phần của môn học 26. Lớp Lophocphan trả kết quả cho lớp GDLophocphan 27. Lớp GDLophocphan hiển thị cho sinh viên 28. Sinh viên click 1 lớp lớp học phần 29. GDLophocphan gọi lại lớp GDDangki 30. GDDangki lại hiển thị (Lặp các bước từ 12 đến 27 đến khi đủ số tín chỉ) 31. Sinh viên click lưu 32. Lớp GDDangki gọi lớp Dangkihoc yêu cầu lưu 33. Lớp Dangkihoc lưu thông tin đăng kí 34. Lớp Dangkihoc trả kết quả lại cho lớp GDDangki 35. Lớp GDDangki báo đăng kí thành công.", "order_start": 2176, "order_end": 2804, "word_count": 125}
{"parent_id": "daa2f457-229c-413b-bedf-99aa1da924e1", "subject": "Phantichthietkehttt", "section": "b. Modul nhập điểm", "title_path": "b. Modul nhập điểm", "content": "[Phantichthietkehttt / b. Modul nhập điểm] Biểu đồ trạng thái của modul được trình bày trong Hình 3.11: • Tại giao diện chính của giảng viên, hệ thống chuyển sang giao diện chọn môn học khi chức năng chọn môn học được chọn. • Tại giao diện chọn môn học, khi giảng viên chọn 1 môn học, hệ thống sẽ chuyển sang giao diện chọn lớp học phần. • Tại giao diện chọn lớp học phần, khi giảng viên chọn 1 lớp học phần, hệ thống sẽ chuyển sang giao diện nhập điểm. Tại giao diện nhập điểm, sau khi nhập nhập và chọn lưu, hệ thống lưu điểm vào và kết thúc. Kịch bản v.2 của modul diễn ra như sau (Hình 3.12): 1. Tại giao diện chính của giảng viên, sau khi đăng nhập, giảng viên chọn chức năng n điểm. 2. Lớp GDChinhGV gọi GDKihoc 3. Lớp GDKihoc goi lớp Kihoc yêu cầu tìm kì học đang học 4. Lớp Kihoc tìm các kì học đang học 5. Lớp Kihoc trả kết quả cho lớp GDKihoc 6. Lớp GDKihoc hiển thị cho giảng viên 7. Giảng viên chọn 1 kì học. 8. Lớp GDKihoc gọi GDMonhoc. 9. Lớp GDMonhoc gọi lớp Monhoc yêu cầu tìm các môn do giảng viên dạy 10. Lớp Monhoc tìm các môn học do giảng viên dang dạy 11. Lớp Monhoc trả kết quả lại cho lớp GDMonhoc. 12.", "order_start": 0, "order_end": 1082, "word_count": 231}
{"parent_id": "daa2f457-229c-413b-bedf-99aa1da924e1", "subject": "Phantichthietkehttt", "section": "b. Modul nhập điểm", "title_path": "b. Modul nhập điểm", "content": "[Phantichthietkehttt / b. Modul nhập điểm] hoc. 9. Lớp GDMonhoc gọi lớp Monhoc yêu cầu tìm các môn do giảng viên dạy 10. Lớp Monhoc tìm các môn học do giảng viên dang dạy 11. Lớp Monhoc trả kết quả lại cho lớp GDMonhoc. 12. Lớp GDMonhoc hiển thị cho giảng viên 13. Giảng viên chọn 1 môn học trong danh sách 14. Lớp GDMonhoc gọi lớp GDLophocphan 15. Lớp GDLophocphan gọi lớp Lophocphan yêu cầu tìm lớp học phần của giảng viên 16. Lớp Lophocphan tìm các lớp học phần do giảng viên dạy, của môn học đã chọn 17. Lớp Lophocphan trả kết quả lại cho lớp GDLophocphan 18. Lớp GDLophocphan hiển thị cho giảng viên. 19. Giảng viên chọn 1 lớp học phần trong danh sách 20. Lớp GDLophocphan gọi lớp GDNhapdiem 21. Lớp GDNhapdiem gọi lớp Dangkihoc yêu cầu tìm thông tin điểm đã có 22. Lớp Dangkihoc tìm sinh viên và các đầu điểm đã có của lớp học phần 23. Lớp Dangkihoc trả kết quả lại cho lớp GDNhapdiem 24. Lớp GDNhapdiem hiển kết quả cho giảng viên. 25. Giảng viên nhập thêm đầu điểm và click lưu 26. Lớp GDNhapdiem gọi lớp Dangkihoc yêu cầu cập nhật 27. Lớp Dangkihoc lưu thông tin điểm của lớp học phần 28.", "order_start": 1082, "order_end": 2136, "word_count": 210}
{"parent_id": "daa2f457-229c-413b-bedf-99aa1da924e1", "subject": "Phantichthietkehttt", "section": "b. Modul nhập điểm", "title_path": "b. Modul nhập điểm", "content": "[Phantichthietkehttt / b. Modul nhập điểm] t quả cho giảng viên. 25. Giảng viên nhập thêm đầu điểm và click lưu 26. Lớp GDNhapdiem gọi lớp Dangkihoc yêu cầu cập nhật 27. Lớp Dangkihoc lưu thông tin điểm của lớp học phần 28. Lớp Dangkihoc trả kết quả lại cho lớp GDNhapdiem 29. Lớp GDNhapdiem thông báo thành công.", "order_start": 2136, "order_end": 2406, "word_count": 53}
{"parent_id": "94ede4e3-f40a-4e4f-8966-585636feddec", "subject": "Phantichthietkehttt", "section": "c. Modul xem thống kê loại học lực", "title_path": "c. Modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Modul xem thống kê loại học lực] Hoạt động của biểu đồ trạng thái của modul được biểu diễn trong Hình 1.13: Tại giao diện chính của nhân viên quản lí, khi chọn chức năng xem thống kê, hệ thống sẽ chuyển sang giao diện chọn kiểu thống kê • Tại giao diện chọn kiểu thống kê, chọn loại thống kê loại học lực, hệ thống chuyển snag giao diện thống kê loại học lực Tại giao diện thống kê loại học lực, khi chọn vào 1 loại học lực, hệ thống chuyển snag giao diện thống kê các sinh viên của loại học lực đã chọn Tại giao diện thống kê sinh viên, chọn một sinh viên, hệ thống chuyển sang giao diện liệt kê điểm các môn học của sinh viên đã chọn Tại giao diện điểm các môn học, chọn 1 môn học, hệ thống sẽ chuyển snag giao diện thông tin điểm chi tiết của môn học của sinh viên đã chọn. • Tại tất cả các giao diện, nếu chọn quay lại, hệ thống sẽ quay lại giao diện trước đấy. Kịch bản v.2 của modul diễn ra như sau (Hình 3.14): 1. Tại giao diện chính của nhân viên quản lí, sau khi đăng nhập, quản lí chọn xem thống kê. 2. Lớp GDChinhQL gọi lớp GDChonTK. 3. Lớp GDChonTK gọi lớp Kihoc yêu cầu tìm các kì học đã kết thúc 4.", "order_start": 0, "order_end": 1079, "word_count": 232}
{"parent_id": "94ede4e3-f40a-4e4f-8966-585636feddec", "subject": "Phantichthietkehttt", "section": "c. Modul xem thống kê loại học lực", "title_path": "c. Modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Modul xem thống kê loại học lực] ện chính của nhân viên quản lí, sau khi đăng nhập, quản lí chọn xem thống kê. 2. Lớp GDChinhQL gọi lớp GDChonTK. 3. Lớp GDChonTK gọi lớp Kihoc yêu cầu tìm các kì học đã kết thúc 4. Lớp Kihoc tìm các kì học đã kết thúc 5. Lớp Kihoc trả kết quả lại cho lớp GDChonTK. 6. Lớp GDChonTK hiển thị cho QL 7. QL chọn thống kê loại học lực 8. Lớp GDChonTK gọi lớp GDTKHocluc 9. Lớp GDTKHocluc hiển thị cho QL 10. QL chọn học kì muốn thống kê 11. Lớp GDTKHocluc gọi lớp TKLoaihocluc yêu cầu lấy dữ liệu 12. Lớp TKLoaihocluc lấy dữ liệu thống kê 13. Lớp TKLoaihocluc trả kết quả cho lớp GDTKHocluc 14. Lớp GDTKHocluc hiển thị cho QL 15. QL chọn 1 loại học lực 16. Lớp GDTKHocluc gọi lớp GDSVLoaihocluc 17. Lớp GDSVLoaihocluc gọi lớp TKSinhvien yêu cầu lấy dữ liệu 18. Lớp TKSinhvien lấy dữ liệu thống kê sinh viên của loại học lực 19. Lớp TKSinhvien trả kết quả lại cho lớp GDSVLoaihocluc 20. Lớp GDSVLoaihocluc hiển thị cho QL 21. QL click 1 sinh viên 22. Lớp GDSVLoaihocluc gọi lớp GDDiemSV 23. Lớp GDDiemSV gọi lớp Dangkihoc yêu cầu lấy dữ liệu điểm 24. Lớp Dangkihoc lấy điểm các môn học của sinh viên 25.", "order_start": 1079, "order_end": 2176, "word_count": 220}
{"parent_id": "94ede4e3-f40a-4e4f-8966-585636feddec", "subject": "Phantichthietkehttt", "section": "c. Modul xem thống kê loại học lực", "title_path": "c. Modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Modul xem thống kê loại học lực] 1. QL click 1 sinh viên 22. Lớp GDSVLoaihocluc gọi lớp GDDiemSV 23. Lớp GDDiemSV gọi lớp Dangkihoc yêu cầu lấy dữ liệu điểm 24. Lớp Dangkihoc lấy điểm các môn học của sinh viên 25. Lớp Dangkihoc trả kết quả cho lớp GDDiemSV 26. Lớp GDDiemSV hiển thị cho QL 27. QL chọn 1 môn học 28. Lớp GDDiemSV gọi lớp GDDiemMHcuaSV 29. Lớp GDDiemMHcuaSV gọi lớp Dangkihoc yêu cầu lấy điểm chi tiết 30. Lớp Dangkihoc lấy thông tin điểm chi tiết của 1 môn học của sinh viên. 31. Lớp Dangkihoc trả kết quả ;ại cho lớp GDDiemMHcuaSV 32. Lớp GDDiemMHcuaSV hiển thị cho QL", "order_start": 2176, "order_end": 2728, "word_count": 108}
{"parent_id": "155ea574-f1e7-45fd-816f-d8d8c8799118", "subject": "Phantichthietkehttt", "section": "3.3 BÀI TẬP", "title_path": "3.3 BÀI TẬP", "content": "[Phantichthietkehttt / 3.3 BÀI TẬP] 1. Lập danh sách glossary list cho ứng dụng của nhóm. 2. Mô tả hệ thống bằng ngôn ngữ tự nhiên. 3. Vẽ biểu đồ use case toàn hệ thống 4. Vẽ biểu đồ use case cho modul cá nhân 5. Viết kịch bản cho modul cá nhân 6. Trích lớp thực thể và vẽ biểu đồ lớp thực thể cho toàn hệ thống 7. Trích và vẽ biểu đồ lớp cho modul 8. Vẽ biểu đồ trạng thái cho modul 9. Viết kịch bản v.2 và vẽ biểu đồ giao tiếp cho modul.", "order_start": 0, "order_end": 403, "word_count": 94}
{"parent_id": "023d5a08-a704-4d7a-bde5-b4bf096b2edc", "subject": "Phantichthietkehttt", "section": "4.1.1 Quy trình thực hiện", "title_path": "4.1.1 Quy trình thực hiện", "content": "[Phantichthietkehttt / 4.1.1 Quy trình thực hiện] Đầu vào là biểu đồ lớp thực thể pha phân tích, tiến hành các bước như sau: • Bước 1: Bổ sung thuộc tính id cho các lớp không kế thừa từ lớp khác • Bước 2: Bổ sung kiểu dữ liệu cho các thuộc tính. Kiểu dữ liệu phải tương ứng với kiểu dữ liệu của ngôn ngữ lập trình đã chọn. • Bước 3: Chuyển đổi các quan hệ association sang các dạng aggregation/composition, nếu có: Nếu hai lớp A và B liên kết (asociation) tạo ra lớp C thì có thể chuyển thành: ◦ A chứa C, C chứa B; ◦ hoặc B chứa C, C chứa A; ◦ hoặc C chứa A và B. Bước 4: Bổ sung thuộc tính đối tượng của các lớp thực thể, nếu có ◦ Giữa hai lớp có quan hệ aggregation/composition thì lớp chứa lớp còn lại nên khai báo tường minh thuộc tính có kiểu là lớp còn lại ◦ Số lượng (số ít/số nhiều) của thuộc tính phụ thuộc vào quan hệ số lượng giữa hai thực thể. • Vẽ biểu đồ thực thể pha thiết kế Lưu ý khi vẽ biểu đồ lớp thực thể pha thiết kế: Tên lớp, tên thuộc tính nên đặt tên theo chuẩn code convention: Tên lớp nên bắt đầu bằng chữ hoa, tên thuộc tính nên bắt đầu bằng chữ thường. Có thể đặt tên gợi nhớ theo Tiếng Anh hoặc Tiếng Việt.", "order_start": 0, "order_end": 1086, "word_count": 242}
{"parent_id": "023d5a08-a704-4d7a-bde5-b4bf096b2edc", "subject": "Phantichthietkehttt", "section": "4.1.1 Quy trình thực hiện", "title_path": "4.1.1 Quy trình thực hiện", "content": "[Phantichthietkehttt / 4.1.1 Quy trình thực hiện] ộc tính nên đặt tên theo chuẩn code convention: Tên lớp nên bắt đầu bằng chữ hoa, tên thuộc tính nên bắt đầu bằng chữ thường. Có thể đặt tên gợi nhớ theo Tiếng Anh hoặc Tiếng Việt. Nếu Tiếng Việt thì không được có dấu, không được có dấu cách. Trong tên lớp/thuộc tính không được có các kí tự đặc biệt. • Thuộc tính cần khai báo tường minh kiểu dữ liệu.", "order_start": 1086, "order_end": 1438, "word_count": 74}
{"parent_id": "85b51bfb-8085-4897-951e-254834c46d52", "subject": "Phantichthietkehttt", "section": "4.1.2 Áp dụng", "title_path": "4.1.2 Áp dụng", "content": "[Phantichthietkehttt / 4.1.2 Áp dụng] Bước 1 Các lớp được bổ sung thuộc tính id: trừ các lớp TK, Sinhvien, Thanhvien, Giaovu, Giangvien, NVQuanli, NVKhaothi.", "order_start": 0, "order_end": 119, "word_count": 20}
{"parent_id": "92577fd6-5e02-4a98-aced-7a42450f996a", "subject": "Phantichthietkehttt", "section": "Bước 2", "title_path": "Bước 2", "content": "[Phantichthietkehttt / Bước 2] Thuộc tính của các lớp được bổ sung thuộc tính theo kiểu của ngôn ngữ lập trình Java. Bước 3 • Quan hệ Sinhvien - Khoa -> SinhvienKhoa chuyển thành SinhvienKhoa chứa Sinhvien và Khoa. • Quan hệ Monhoc - Daudiem -> MonhocDaudiem chuyển thành MonhocDaudiem chứa Monhoc và Daudiem. • Quan hệ Namhoc - Hocki -> Kihoc chuyển thành Kihoc chứa Namhoc và Hocki • Quan hệ Monhoc - Kihoc -> MonhocKihoc chuyển thành MonhocKihoc chứa Monhoc và Kihoc. • Quan hệ SinhvienKhoa - Lophocphan -> Dangkihoc chuyển thành Dangkihoc chứa SinhvienKhoa và Lophocphan. • Quan hệ Dangkihoc - MonhocDaudiem -> Ketqua chuyển thành Dangkihoc chứa Ketqua, Ketqua chứa MonhocDaudiem. Bổ sung các thuộc tính thành phần của quan hệ hợp thành/gắn chặt, ta thu được biểu đồ lớp thực thể pha thiết kế như trong Hình 4.1.", "order_start": 0, "order_end": 785, "word_count": 139}
{"parent_id": "ddb87589-8bbd-4db7-a7f9-369a90946d39", "subject": "Phantichthietkehttt", "section": "4.2.1 Quy trình thực hiện", "title_path": "4.2.1 Quy trình thực hiện", "content": "[Phantichthietkehttt / 4.2.1 Quy trình thực hiện] Đầu vào là biểu đồ lớp thực thể pha thiết kế, tiến hành các bước như sau: Bước 1: Với mỗi lớp thực thể, đề xuất một bảng dữ liệu tương ứng. Nên đặt tên bảng theo cách gợi nhớ tương ứng. Ví dụ, nếu lớp thực thể là Student, thì có thể đặt tên bảng tương ứng là tblStudent. • Bước 2: Với mỗi lớp thực thể, bỏ qua các thuộc tính kiểu đối tượng, lấy các thuộc tính kiểu cơ bản đưa sang làm thuộc tính của bảng tương ứng, và chuyển kiểu dữ liệu theo hệ quản trị cơ sở dữ liệu tương ứng. Bước 3: Xét quan hệ số lượng giữa các lớp thực thể, quan hệ số lượng giữa hai lớp thực thể cũng là quan hệ số lượng giữa hai bảng tương ứng với hai lớp đấy. Khi đó: ◦ Nếu hai bảng có quan hệ là 1-1 thì nên gộp lại, tuy nhiên, trong một số trường hợp đặc biệt thì có thể giữ nguyên. ◦ Nếu hai bảng có quan hệ 1-n thì giữ nguyên. ◦ Nếu hai bảng có quan hệ n-n thì nên bổ sung ít nhất một bảng trung gian để tách thành một số quan hệ 1-n.", "order_start": 0, "order_end": 916, "word_count": 209}
{"parent_id": "ddb87589-8bbd-4db7-a7f9-369a90946d39", "subject": "Phantichthietkehttt", "section": "4.2.1 Quy trình thực hiện", "title_path": "4.2.1 Quy trình thực hiện", "content": "[Phantichthietkehttt / 4.2.1 Quy trình thực hiện] iệt thì có thể giữ nguyên. ◦ Nếu hai bảng có quan hệ 1-n thì giữ nguyên. ◦ Nếu hai bảng có quan hệ n-n thì nên bổ sung ít nhất một bảng trung gian để tách thành một số quan hệ 1-n. Thực tế, nếu đến thời điểm này vẫn còn quan hệ n-n giữa các bảng thì chứng tỏ trong biểu đồ lớp thực thể, vẫn còn quan hệ n-n, cho nên tốt nhất là nên quay lại sửa từ biểu đồ lớp thực thể pha phân tích. • Bước 4: Bổ sung khóa cho các bảng: ◦ Khóa chính (Primary key - PK): Bảng nào có thuộc tính id thì thiết lập thuộc tính đó làm khóa chính cho bảng. ◦ Khóa ngoại (Foreinger key - FK): Nếu hai bảng tblA và tblB có quan hệ 1-n (1 tblA có n tblB), thì trong bảng tblB phải có khóa ngoài tham chiếu đến khóa chính của bảng tblA. Khó ngoại có thể đặt tên là aId hoặc idA. • Bước 5: Loại bỏ các thuộc tính gây dư thừa dữ liệu. Có hai loại thuộc tính gây dư thừa dữ liệu: ◦ Thuộc tính bị trùng lặp: thường là thuộc tính của cùng một đối tượng, không phải thuộc tính khóa, nhưng xuất hiện ở hai bảng khác nhau. ◦ Thuộc tính dẫn xuất: là thuộc tính có thể tính toán cơ học từ các thuộc tính khác trong CSDL.", "order_start": 916, "order_end": 1998, "word_count": 243}
{"parent_id": "ddb87589-8bbd-4db7-a7f9-369a90946d39", "subject": "Phantichthietkehttt", "section": "4.2.1 Quy trình thực hiện", "title_path": "4.2.1 Quy trình thực hiện", "content": "[Phantichthietkehttt / 4.2.1 Quy trình thực hiện] ùng một đối tượng, không phải thuộc tính khóa, nhưng xuất hiện ở hai bảng khác nhau. ◦ Thuộc tính dẫn xuất: là thuộc tính có thể tính toán cơ học từ các thuộc tính khác trong CSDL. Ví dụ một số thuộc tính xuất thân từ các lớp thực thể thống kê thì thường là thuộc tính dẫn xuất. Sau khi loại bỏ các thuộc tính dư thừa, nếu xuất hiện bảng nào không còn thuộc tính nào nữa ngoài 1 khóa ngoại thì có thể loại bỏ luôn bảng đấy.", "order_start": 1998, "order_end": 2421, "word_count": 92}
{"parent_id": "6e619f63-29c4-48ef-909f-3a9072e291c7", "subject": "Phantichthietkehttt", "section": "Bước 1", "title_path": "Bước 1", "content": "[Phantichthietkehttt / Bước 1] Mỗi lớp thực thể đề xuất bảng tương ứng: Lớp Truong -> bảng tblTruong • Lớp Khoa -> bảng tblKhoa • Lớp Toanha -> bảng tblToanha", "order_start": 0, "order_end": 127, "word_count": 26}
{"parent_id": "02cbb2f1-7ddb-4998-8126-aaa75bb5aa1a", "subject": "Phantichthietkehttt", "section": "Bước 2", "title_path": "Bước 2", "content": "[Phantichthietkehttt / Bước 2] Đưa thuộc tính không phải đối tượng của lớp thực thể thành thuộc tính của bảng tương ứng: tblTruong có các thuộc tính: id, tên, mô tả • tblKhoa: id, tên, mô tả • tblToanha: id, tên, mô tả", "order_start": 0, "order_end": 187, "word_count": 39}
{"parent_id": "9f7be39d-6d85-47f3-89f9-2bf7eb419530", "subject": "Phantichthietkehttt", "section": "Bước 3", "title_path": "Bước 3", "content": "[Phantichthietkehttt / Bước 3] Chuyến quan hệ số lượng giữa các lớp thực thể thành quan hệ số lượng giữa các bảng: 1 tblTruong - n tblKhoa • 1 tblTruong - n tblToanha • 1 tblToanha - n tblPhonghoc •", "order_start": 0, "order_end": 167, "word_count": 36}
{"parent_id": "00356868-6411-4260-a59a-5cc91076da24", "subject": "Phantichthietkehttt", "section": "Bước 4", "title_path": "Bước 4", "content": "[Phantichthietkehttt / Bước 4] Bổ sung các thuộc tính khóa. Khóa chính được thiết lập với thuộc tính id của các bảng tương ứng: trừ các bảng tblTK, tblSinhvien, tblThanhvien, tblGiangvien, tblNVQuanli, tblNVKhaothi, tblGiaovu. Khóa ngoại được thiết lập cho các bảng: • 1 tblTruong - n tblKhoa -> bảng tblKhoa có khóa ngoại tblTruongid • 1 tblTruong - n tblToanha -> bảng tblToanha có khóa ngoại tblTruongid • 1 tblToanha - n tblPhonghoc -> bảng tblPhonghoc có khóa ngoại tblToanhaid • ...", "order_start": 0, "order_end": 457, "word_count": 79}
{"parent_id": "11b41803-4fc0-42ca-afaa-35c129f50819", "subject": "Phantichthietkehttt", "section": "Bước 5", "title_path": "Bước 5", "content": "[Phantichthietkehttt / Bước 5] Các thuộc tính dẫn xuất: • điểm TBM, điểm TB chữ trong bảng tblDangkihoc • Các thuộc tính của các lớp thống kê -> loại bỏ hết các bảng thống kê. Kết quả thu được CSDL toàn hệ thống được trình bày trong Hình 4.2.", "order_start": 0, "order_end": 211, "word_count": 45}
{"parent_id": "991aa748-67ec-4cf3-94c8-182cf9dd6e69", "subject": "Phantichthietkehttt", "section": "4.3.1 Thiết kế tĩnh", "title_path": "4.3.1 Thiết kế tĩnh", "content": "[Phantichthietkehttt / 4.3.1 Thiết kế tĩnh] Đầu vào là biểu đồ lớp pha phân tích, tiến hành các bước như sau: • Bước 1: Thiết kế giao diện cho các giao diện xuất hiện trong biểu đồ. • Bước 2: Đề xuất các lớp giao diện tương ứng với ngôn ngữ lập trình và nền tảng hệ thống. Ví dụ hệ thống chạy trên ứng dụng máy bàn, hệ thống chạy trên nền web, hệ thống chạy trên nền tảng thiết bị di động. ◦ Đề xuất tên lớp tương ứng. Có thể tách, gộp các lớp giao diện so với pha phân tích ◦ Thiết kế các thuộc tính đã liệt kê trong pha phân tích. ◦ Bổ sung các thuộc tính ẩn để chứa thông tin cần thiết để xử lí và trao đổi qua lại giữa các lớp giao diện. Bước 3: Đề xuất các lớp truy xuất dữ liệu (DAO), nếu có. ◦ Nên thiết kế dạng Interface hoặc kế thừa từ lớp trừu tượng để có thể dùng chung kết nối vào CSDL cho toàn hệ thống để tiết kiệm tài nguyên. ◦ Thường, nếu lớp thực thể trong pha phân tích cần phương thức, hành động nào thì nên đề xuất lớp DAO cho lớp thực thể tương ứng, và gán phương thức đang xem xét cho lớp vùa đề xuất. ◦ Với mỗi phương thức của lớp DAO, cần lưu ý thiết kế tên gợi nhớ, các tham số đầu vào, các tham số đầu ra.", "order_start": 0, "order_end": 1087, "word_count": 247}
{"parent_id": "991aa748-67ec-4cf3-94c8-182cf9dd6e69", "subject": "Phantichthietkehttt", "section": "4.3.1 Thiết kế tĩnh", "title_path": "4.3.1 Thiết kế tĩnh", "content": "[Phantichthietkehttt / 4.3.1 Thiết kế tĩnh] thực thể tương ứng, và gán phương thức đang xem xét cho lớp vùa đề xuất. ◦ Với mỗi phương thức của lớp DAO, cần lưu ý thiết kế tên gợi nhớ, các tham số đầu vào, các tham số đầu ra. • Bước 4: Bổ sung các lướp thực thể liên quan đến modul. Giữ nguyên quan hệ giữa các thực thể như các quan hệ giữa chúng trong biểu đồ lớp thực thể.", "order_start": 1087, "order_end": 1416, "word_count": 75}
{"parent_id": "9b4496c7-1391-4845-9648-d70da12bb55b", "subject": "Phantichthietkehttt", "section": "a. Thiết kế tĩnh modul đăng kí học", "title_path": "a. Thiết kế tĩnh modul đăng kí học", "content": "[Phantichthietkehttt / a. Thiết kế tĩnh modul đăng kí học] Các giao diện cho chức năng này được thiết kế như trong Hình 4.3. Biểu đồ lớp thiết kế tương ứng trong Hình 4.4: • Tầng giao diện có các trang jsp: gdChinhSV, gdChonnganh, gdDangki, gdChonMH, gdChonLHP, và doLuuDK. Tầng thao tác với dữ liệu có các lớp DAO, KihocDAO, SinhvienKhoaDAO, MonhocKihocDAO, LophocphanDAO, DangkihocDAO. • Tầng thực thể gồm tất cả các thực thể liên quan.", "order_start": 0, "order_end": 379, "word_count": 66}
{"parent_id": "ae39176b-5a6a-4b86-a725-c0143fa0a6b8", "subject": "Phantichthietkehttt", "section": "b. Thiết kế tĩnh modul nhập điểm", "title_path": "b. Thiết kế tĩnh modul nhập điểm", "content": "[Phantichthietkehttt / b. Thiết kế tĩnh modul nhập điểm] Các giao diện cho chức năng nhập điểm được thiết kế như trong Hình 4.5. Biểu đồ lớp của modul được thiết kế như trong Hình 4.6: • Các lớp giao diện là các trang jsp: gdChinhGV, gdMonhoc, gdLophocphan, gdDiem, doLuudiem. Các lớp tầng truy cập dữ liệu DAO: DAO, KihocDAO, MonhocKihocDAO, LophocphanDAO, DangkihocDAO. • Các lớp thực thể liên quan", "order_start": 0, "order_end": 343, "word_count": 61}
{"parent_id": "ba521bdd-b78e-43c0-84ff-f2025132742b", "subject": "Phantichthietkehttt", "section": "c. Thiết kế tĩnh modul xem thống kê loại học lực", "title_path": "c. Thiết kế tĩnh modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Thiết kế tĩnh modul xem thống kê loại học lực] Giao diện cho modul được thiết kế như trong Hình 4.7. Thiết kế biểu đồ lớp cho modul được trình bày trong Hình 4.8: • Tầng giao diện gồm các trang jsp: gdChinhQL, gdChonTK, gdTKHocluc, gdTKHLSinhvien, gdTKDiemSV, gdDiemMHSV. Tầng xử lí truy cập dữ liệu: DAO, KihocDAO, TKHoclucDAO, TKSinhvienDAO, DangkihocDAO. • Các lớp thực thể liên quan.", "order_start": 0, "order_end": 340, "word_count": 57}
{"parent_id": "3208710c-dc9a-4edc-a86d-3e83826e6053", "subject": "Phantichthietkehttt", "section": "4.3.2 Thiết kế hoạt động", "title_path": "4.3.2 Thiết kế hoạt động", "content": "[Phantichthietkehttt / 4.3.2 Thiết kế hoạt động] Quy trình tiến hành các bước như sau: Bước 1: Vẽ biểu đồ hoạt động của modul: Mỗi hành động tương ứng một phương thức đã thiết kế trong biểu đồ lớp. Bước 2: Viết kịch bản phiên bản 3 và vẽ biểu đồ tuần tự cho modul. Những lưu ý về yêu cầu khác biệt của biểu đồ tuần tự pha thiết kế so với biểu đồ tuần tự pha phân tích: ◦ Tên các hành động của các lớp phải tương ứng với các phương thức đã thiết kế trong biểu đồ lớp thiết kế ◦ Biểu diễn được phạm vi và khoảng thởi gian hoạt động của từng phương thức trong biểu đồ. Lưu ý là trong các kịch bản thiết kế cho tiết ở mục này, các bước đóng gói thuộc tính con của lớp thực thể đã được lược bỏ đi cho gọn.", "order_start": 0, "order_end": 651, "word_count": 148}
{"parent_id": "6fa04d54-1b5d-4784-9d17-522da47efba1", "subject": "Phantichthietkehttt", "section": "a. Thiết kế động modul đăng kí học", "title_path": "a. Thiết kế động modul đăng kí học", "content": "[Phantichthietkehttt / a. Thiết kế động modul đăng kí học] Biểu đồ hoạt động của modul được trình bày trong Hình 4.9. Biểu đồ tuần tự được trình bày trong Hình 4.10, với kịch bản cụ thể như sau: 1. Tại giao diện chính của sinh viên, sau khi đăng nhập, sinh viên click chọn chức năng đăng kí học. 2. Trang gdChinhSV.jsp gọi trang gdChonnganh.jsp. 3. Trang gdChonnganh.jsp gọi lớp KhoaDAO yêu cầu tìm danh sách ngành học của sinh viên. 4. Lớp KhoaDAO gọi hàm getNganhhoccuaSV() 5. Hàm getNganhhoccuaSV() gọi lớp Khoa để đóng gói thông tin 6. Lớp Khoa đóng gói thông tin thực thể 7. Lớp Khoa trả kết quả về cho hàm getNganhhoccuaSV() 8. Hàm getNganhhoccuaSV() trả kết quả cho trang gdChonnganh,jsp 9. Trang gdChonnganh.jsp hiển thị cho sinh viên 10. Sinh viên chọn 1 ngành học để đăng kí 11. Trang gdChonnganh.jsp gọi trang gdDangki.jsp 12. Trang gdDangki.jsp gọi lớp DangkihocDAO yêu cầu lấy thông tin đăng kí đã có của sinh viên 13. Lớp DangkihocDAO gọi hàm getDangkicuaSV() 14. Hàm getDangkicuaSV() gọi lớp Dangkihoc để đóng gói thông tin 15. Lớp Dangkihoc đóng gói thông tin thực thể 16. Lớp Dangkihoc trả kết quả lại cho hàm getDangkicuaSV() 17.", "order_start": 0, "order_end": 1088, "word_count": 196}
{"parent_id": "6fa04d54-1b5d-4784-9d17-522da47efba1", "subject": "Phantichthietkehttt", "section": "a. Thiết kế động modul đăng kí học", "title_path": "a. Thiết kế động modul đăng kí học", "content": "[Phantichthietkehttt / a. Thiết kế động modul đăng kí học] uaSV() 14. Hàm getDangkicuaSV() gọi lớp Dangkihoc để đóng gói thông tin 15. Lớp Dangkihoc đóng gói thông tin thực thể 16. Lớp Dangkihoc trả kết quả lại cho hàm getDangkicuaSV() 17. Hàm getDangkicuaSV() trả kết quả lại cho trang gdDangki.jsp 18. Trang gdDangki.jsp hiển thị cho sinh viên. 19. Sinh viên click tiếp tục để đăng kí. 20. Trang gdDangki.jsp gọi trang gdChonMH.jsp 21. Trang gdChonMH.jsp gọi lớp MonhocKihocDAO yêu cầu lấy danh sách môn học mà sinh viên được đăng kí 22. Lớp MonhocKihocDAO gọi hàm getMonhoccuaSV() 23. Hàm getMonhoccuaSV() thực hiện và gọi lớp MonhocKihoc để đóng gói 24. Lớp MonhocKihoc đóng gói thông tin thực thể 25. Lớp MonhocKihoc trả kết quả lại cho hàm getMonhoccuaSV() 26. Hàm getMonhoccuaSV() trả kết quả lại cho trang gdChonMH.jsp 27. Trang gdChonMH.jsp hiển thị cho sinh viên. 28. Sinh viên click chọn 1 môn học 29. Trang gdChonMH.jsp gọi trang gdChonLHP.jsp 30. Trang gdChonLHP.jsp gọi lớp LophocphanDAO yêu cầu tìm danh sách lớp học phần của môn học đã chọn. 31. Lớp LophocphanDAO gọi hàm getLHPcuaMH() 32. Hàm getLHPcuaMH() thực hiện và gọi lớp Lophocphan 33.", "order_start": 1088, "order_end": 2188, "word_count": 187}
{"parent_id": "6fa04d54-1b5d-4784-9d17-522da47efba1", "subject": "Phantichthietkehttt", "section": "a. Thiết kế động modul đăng kí học", "title_path": "a. Thiết kế động modul đăng kí học", "content": "[Phantichthietkehttt / a. Thiết kế động modul đăng kí học] gọi lớp LophocphanDAO yêu cầu tìm danh sách lớp học phần của môn học đã chọn. 31. Lớp LophocphanDAO gọi hàm getLHPcuaMH() 32. Hàm getLHPcuaMH() thực hiện và gọi lớp Lophocphan 33. Lớp Lophocphan đóng gói thông tin thực thể 34. Lớp Lophocphan trả lại kết quả cho hàm getLHPcuaMH() 35. Hàm getLHPcuaMH() trả kết quả cho trang gdChonLHP.jsp 36. Trang gdChonLHP.jsp hiển thị cho sinh viên 37. Sinh viên chọn 1 lớp học phần để đăng kí 38. Trang gdChonLHP.jsp gọi lại trang gdDangki.jsp 39. Trang gdDangki.jsp hiển thị cho sinh viên. (có thể lặp lại các bước 18 đến 38 cho đến khi đủ số tín chỉ tối thiểu) 40. Sinh viên click chọn lưu đăng kí 41. Trang gdDangki.jsp gọi trang doLuuDK.jsp 42. Trang doLuuDK.jsp gọi lớp DangkihocDAO yêu cầu lưu 43. Lớp DangkihocDAO gọi hàm luuDKcuaSV() 44. Lớp DangkihocDAO trả lại lớp doLuuDK.jsp 45. Lớp doLuuDK.jsp thông báo thành công 46. Sinh viên click OK của thông báo 47. Trang doLuuDK.jsp gọi lại trang gdChinhSV.jsp 48. Trang gdChinhSV.jsp hiển thị.", "order_start": 2188, "order_end": 3173, "word_count": 174}
{"parent_id": "0ce47d1a-5cfc-4e56-b107-55b693f5df87", "subject": "Phantichthietkehttt", "section": "b. Thiết kế động modul nhập điểm", "title_path": "b. Thiết kế động modul nhập điểm", "content": "[Phantichthietkehttt / b. Thiết kế động modul nhập điểm] Biểu đồ hoạt động của modul nhập điểm được trình bày trong Hình 4.11. Tương ứng với biểu đồ tuần tự được trình bày trong Hình 4.12, kịch bản các hoạt động diễn ra như sau: 1. Tại trang gdChinhGV.jsp, sau khi đăng nhập, giảng viên chọn chức năng nhập điểm 2. Trang gdChinhGV.jsp gọi trang gdMonhoc.jsp 3. Trang gdMonhoc.jsp gọi lớp KihocDAO yêu cầu lấy thông tin các học kì đang học. 4. Lớp KihocDAO gọi hàm getKihoc() 5. Hàm getKihoc() thục hiện và gọi lớp Kihoc đóng gói thông tin 6. Lớp Kihoc đóng gói thông tin thực thể 7. Lớp Kihoc trả kết quả cho hàm getKihoc() 8. Hàm getKihoc() trả kết quả cho trang gdMonhoc.jsp 9. Trang gdMonhoc.jsp hiển thị cho giảng viên 10. Giảng viên chọn 1 kì học 11. Trang gdMonhoc.jsp submit gọi chính nó xử lí 12. Trang gdMonhoc.jsp gọi lớp MonhocKihocDAO yêu cầu lấy danh sách môn học do giảng viên dạy trong kì được chọn. 13. Lớp MonhocKihocDAO gọi hàm getMHcuaGV() 14. Hàm getMHcuaGV() thực hiện và gọi lớp MonhocKihoc để đóng gói thông tin 15. Lớp MonhocKihoc đóng gói thông tin thực thể 16. Lớp MonhocKihoc trả kết quả lại cho hàm getMHcuaGV() 17.", "order_start": 0, "order_end": 1086, "word_count": 204}
{"parent_id": "0ce47d1a-5cfc-4e56-b107-55b693f5df87", "subject": "Phantichthietkehttt", "section": "b. Thiết kế động modul nhập điểm", "title_path": "b. Thiết kế động modul nhập điểm", "content": "[Phantichthietkehttt / b. Thiết kế động modul nhập điểm] Hàm getMHcuaGV() thực hiện và gọi lớp MonhocKihoc để đóng gói thông tin 15. Lớp MonhocKihoc đóng gói thông tin thực thể 16. Lớp MonhocKihoc trả kết quả lại cho hàm getMHcuaGV() 17. Hàm getMHcuaGV() trả kết quả lại cho trang gdMonhoc.jsp 18. Trang gdMonhoc.jsp hiển thị cho giảng viên 19. Giảng viên click chọn 1 môn học 20. Trang gdMonhoc.jsp gọi trang gdLophocphan.jsp 21. Trang gdLophocphan.jsp gọi lớp LophocphanDAO yêu cầu lấy danh sách các lớp học phần của môn học đã chọn, do giảng viên đó giảng dạy 22. Lớp LophocphanDAO gọi hàm getLHPcuaGV() 23. Hàm getLHPcuaGV() thực hiện và gọi lớp Lophocphan để đóng gói thông tin 24. Lớp Lophocphan đóng gói thông tin thực thể 25. Lớp Lophocphan trả kết quả lại cho hàm getLHPcuaGV() 26. Hàm getLHPcuaGV() trả kết quả lại cho trang gdLophocphan.", "order_start": 1086, "order_end": 1877, "word_count": 139}
{"parent_id": "0ce47d1a-5cfc-4e56-b107-55b693f5df87", "subject": "Phantichthietkehttt", "section": "b. Thiết kế động modul nhập điểm", "title_path": "b. Thiết kế động modul nhập điểm", "content": "[Phantichthietkehttt / b. Thiết kế động modul nhập điểm] gói thông tin 24. Lớp Lophocphan đóng gói thông tin thực thể 25. Lớp Lophocphan trả kết quả lại cho hàm getLHPcuaGV() 26. Hàm getLHPcuaGV() trả kết quả lại cho trang gdLophocphan.jsp", "order_start": 1877, "order_end": 2059, "word_count": 32}
{"parent_id": "580f8a9c-2383-4366-8436-17c5c612c186", "subject": "Phantichthietkehttt", "section": "27. Trang gdLophocphan.jsp hiển thị cho giảng viên", "title_path": "27. Trang gdLophocphan.jsp hiển thị cho giảng viên", "content": "[Phantichthietkehttt / 27. Trang gdLophocphan.jsp hiển thị cho giảng viên] 28. Giảng viên click chọn 1 lớp học phần. 29. Trang gdLophocphan.jsp gọi trang gdDiem.jsp 30. Trang gdDiem.jsp gọi lớp DangkihocDAO yêu cầu lấy danh sách sinh viên đăng kí và kết quả đã có của lớp học phần đã chọn 31. Lớp DangkihocDAO gọi hàm getDiemcuaLHP() 32. Hàm getDiemcuaLHP() thực hiện và gọi lớp Dangkihoc để đóng gói thông tin 33. Lớp Dangkihoc đóng gói thông tin thực thể 34. Lớp Dangkihoc trả kết quả cho hàm getDiemcuaLHP() 35. Hàm getDiemcuaLHP() trả kết quả cho trang gdDiem.jsp 36. Trang gdDiem.jsp hiển thị cho giảng viên 37. Giảng viên nhập các đầu điểm cho sinh viên và click lưu 38. Trang gdDiem.jsp gọi doLuudiem.jsp 39. Trang doLuudiem.jsp gọi lớp Dangkihoc yêu cầu set lại accs thuộc tính điểm mới nhập. 40. Lớp Dangkihoc gọi các hàm set thuộc tính điểm tương ứng 41. Lớp Dangkihoc trả đối tượng về cho trang doLuudiem.jsp 42. Trang doLuudiem.jsp gọi lớp DangkihocDAO yêu cầu lưu điểm cho lớp học phần 43. Lớp DangkihocDAO gọi hàm luuDiemcuaLHP() 44. Lớp DangkihocDAO trả kết quả lại cho trang doLuudiem.jsp 45. Trang doLuudiem.jsp hiện thống báo lưu thành công 46.", "order_start": 0, "order_end": 1087, "word_count": 192}
{"parent_id": "580f8a9c-2383-4366-8436-17c5c612c186", "subject": "Phantichthietkehttt", "section": "27. Trang gdLophocphan.jsp hiển thị cho giảng viên", "title_path": "27. Trang gdLophocphan.jsp hiển thị cho giảng viên", "content": "[Phantichthietkehttt / 27. Trang gdLophocphan.jsp hiển thị cho giảng viên] cho lớp học phần 43. Lớp DangkihocDAO gọi hàm luuDiemcuaLHP() 44. Lớp DangkihocDAO trả kết quả lại cho trang doLuudiem.jsp 45. Trang doLuudiem.jsp hiện thống báo lưu thành công 46. Giảng viên click vào OK của thông báo 47. Trang doLuudiem.jsp gọi trang gdChinhGV.jsp 48. Trang gdChinhGV.jsp hiển thị", "order_start": 1087, "order_end": 1386, "word_count": 49}
{"parent_id": "ac520b44-e9e1-4676-b0fd-6d0d7a9f84c6", "subject": "Phantichthietkehttt", "section": "c. Thiết kế động cho modul xem thống kê loại học lực", "title_path": "c. Thiết kế động cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Thiết kế động cho modul xem thống kê loại học lực] Biểu đồ hoạt động của modul xem thống kê loại học lực được trình bày trong Hình 4.13. Tương ứng với biểu đồ tuần tự được trình bày trong Hình 4.14, kịch bản các hoạt động diễn ra như sau: 1. Tại trang gdChinhQL.jsp, sau khi đăng nhập, nhân viên quản lí chọn chức năn thống kê 2. Trang gdChinhQL.jsp gọi trang gdChonTK.jsp 3. Trang gdChonTK.jsp hiển thị cho NV quản lí 4. NV quản lí click xem thống kê loại học lực 5. Trang gdChonTK.jsp gọi trang gdTKHocluc.jsp 6. Trang gdTKHocluc.jsp gọi lớp KihocDAO yêu cầu lấy danh sách các kì đã học 7. Lớp KihocDAO gọi hàm getKihoc() 8. Hàm getKihoc() thực hiện và gọi lớp Kihoc đóng gói thông tin 9. Lớp Kihoc đóng gói thông tin thực thể. 10. Lớp Kihoc trả kết quả về cho hàm getKihoc() 11. Hàm getKihoc() trả kết quả về cho trang gdTKHocluc.jsp 12. Trang gdTKHocluc.jsp hiển thị cho NV quản lí 13. NV quản lí click chọn 1 kì học để xem thống kê 14. Trang gdTKHocluc.jsp submit vào chính nó để xử lí 15. Trang gdTKHocluc.jsp gọi lớp TKLoaihoclucDAO yêu cầu lấy thông tin thống kê 16. Lớp TKLoaihoclucDAO gọi hàm getTKHocluc() 17.", "order_start": 0, "order_end": 1069, "word_count": 204}
{"parent_id": "ac520b44-e9e1-4676-b0fd-6d0d7a9f84c6", "subject": "Phantichthietkehttt", "section": "c. Thiết kế động cho modul xem thống kê loại học lực", "title_path": "c. Thiết kế động cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Thiết kế động cho modul xem thống kê loại học lực] Trang gdTKHocluc.jsp submit vào chính nó để xử lí 15. Trang gdTKHocluc.jsp gọi lớp TKLoaihoclucDAO yêu cầu lấy thông tin thống kê 16. Lớp TKLoaihoclucDAO gọi hàm getTKHocluc() 17. Hàm getTKHocluc() thực hiện và gọi lớp TKLoaihocluc đóng gói thông tin 18. Lớp TKLoaihocluc đóng gói thông tin thực thể 19. Lớp TKLoaihocluc trả kết quả cho hàm getTKHocluc() 20. Hàm getTKHocluc() trả kết quả cho trang gdTKHocluc.jsp 21. Trang gdTKHocluc.jsp hiển thị cho NV quản lí 22. NV quản lí click chọn 1 loại học lực 23. Trang gdTKHocluc.jsp gọi trang gdTKHLSinhvien.jsp 24. Trang gdTKHLSinhvien.jsp gọi lớp TKSinhvienDAO yêu cầu lấy thông tin thống kê 25. Lớp TKSinhvienDAO gọi hàm getTKSVcuaHL() 26. Hàm getTKSVcuaHL() thwucj hiện và gọi lớp TKSinhvien đóng gói thông tin 27. Lớp TKSinhvien đóng gói thông tin thực thể 28. Lớp TKSinhvien trả kết quả lại cho hàm getTKSVcuaHL() 29. Hàm getTKSVcuaHL() trả kết quả lại cho trang gdTKHLSinhvien.jsp 30. Trang gdTKHLSinhvien.jsp hiển thị cho NV quản lí 31. NV quản lí click 1 sinh viên 32. Trang gdTKHLSinhvien.jsp gọi trang gdTKDiemSV.jsp 33. Trang gdTKDiemSV.", "order_start": 1069, "order_end": 2164, "word_count": 180}
{"parent_id": "ac520b44-e9e1-4676-b0fd-6d0d7a9f84c6", "subject": "Phantichthietkehttt", "section": "c. Thiết kế động cho modul xem thống kê loại học lực", "title_path": "c. Thiết kế động cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Thiết kế động cho modul xem thống kê loại học lực] gdTKHLSinhvien.jsp 30. Trang gdTKHLSinhvien.jsp hiển thị cho NV quản lí 31. NV quản lí click 1 sinh viên 32. Trang gdTKHLSinhvien.jsp gọi trang gdTKDiemSV.jsp 33. Trang gdTKDiemSV.jsp gọi lớp DangkihocDAO yêu cầu lấy thông tin điểm các môn học của sinh viên 34. Lớp DangkihocDAO gọi hàm getDiemcuaSV() 35. Hàm getDiemcuaSV thực hiện và gọi lớp Dangkihoc đóng gói thông tin 36. Lớp Dangkihoc đóng gói thông tin thực thể 37. Lớp Dangkihoc trả kết quả cho hàm getDiemcuaSV() 38. Hàm getDiemcuaSV() trả kết quả lại cho trang gdTKDiemSV.jsp 39. Trang gdTKDiemSV.jsp hiển thị cho NV quản lí 40. NV quản lí click vào một môn học 41. Trang gdTKDiemSV.jsp gọi trang gdDiemMHSV.jsp 42. Trang gdDiemMHSV.jsp gọi lớp DangkihocDAO yêu cầu lấy thông tin điểm chi tiết của môn học 43. Lớp DangkihocDAO gọi hàm getDiemMHcuaSV() 44. Hàm getDiemMHcuaSV() thực hiện và gọi lớp Dangkihoc đóng gói thông tin 45. Lớp Dangkihoc đóng gói thông tin thực thể 46. Lớp Dangkihoc trả lại cho hàm getDiemMHcuaSV() 47. Hàm getDiemMHcuaSV() trả kết quả cho trang gdDiemMHSV.jsp 48. Trang gdDiemMHSV.", "order_start": 2164, "order_end": 3231, "word_count": 178}
{"parent_id": "ac520b44-e9e1-4676-b0fd-6d0d7a9f84c6", "subject": "Phantichthietkehttt", "section": "c. Thiết kế động cho modul xem thống kê loại học lực", "title_path": "c. Thiết kế động cho modul xem thống kê loại học lực", "content": "[Phantichthietkehttt / c. Thiết kế động cho modul xem thống kê loại học lực] 45. Lớp Dangkihoc đóng gói thông tin thực thể 46. Lớp Dangkihoc trả lại cho hàm getDiemMHcuaSV() 47. Hàm getDiemMHcuaSV() trả kết quả cho trang gdDiemMHSV.jsp 48. Trang gdDiemMHSV.jsp hiển thị cho NV quản lí", "order_start": 3231, "order_end": 3438, "word_count": 35}
{"parent_id": "91d37fb3-b59d-4a93-b345-c66371e7f322", "subject": "Phantichthietkehttt", "section": "4.3.3 Thiết kế triển khai", "title_path": "4.3.3 Thiết kế triển khai", "content": "[Phantichthietkehttt / 4.3.3 Thiết kế triển khai] Quy trình tiến hành các bước như sau: • Bước 1: Vẽ biểu đồ triển khai của hệ thống: Các máy sẽ cài đặt hệ thống. Mỗi máy đặt các modul hay package nào. Các modul/package tương tác với nhau thế nào. Áp dụng cho hệ thống, các package được thiết kế theo cấu trúc trong Hình 4.15: Các lớp thực thể đặt chung trong gói model • Các lớp DAO đặt chung trong gói dao. Các trang jsp để trong gói view. Gói view được chia nhỏ thành các gói nhỏ hơn tương ứng với các giao diện cho các người dùng khác nhau: ◦ Các trang thao tác cho đăng nhập, quản lí mật khẩu đặt trong gói thanhvien. ◦ Các trang cho chức năng liên quan đến giảng viên đặt trong gói giangvien ◦ Các trang cho chức năng liên quan đến nhân viên quản lí đặt trong gói quanli ◦ Các trang cho chức năng liên quan đến sinh viên đặt trong gói sinhvien", "order_start": 0, "order_end": 799, "word_count": 168}
{"parent_id": "85c7c0fe-b835-4c41-9e6e-768229fbffd1", "subject": "Phantichthietkehttt", "section": "4.4 CÂU HỎI ÔN TẬP", "title_path": "4.4 CÂU HỎI ÔN TẬP", "content": "[Phantichthietkehttt / 4.4 CÂU HỎI ÔN TẬP] 1. Thiết kế thực thể cho toàn hệ thống 2. Thiết kế CSDL cho toàn hệ thống 3. Thiết kế giao diện liên quan cho modul 4. Thiết kế biểu đồ lớp cho modul 5. Thiết kế biểu đồ hoạt động cho modul 6. Thiết kế biểu đồ tuần tự cho modul 7. Thiết kế biểu đồ gói cho toàn hệ thống", "order_start": 0, "order_end": 269, "word_count": 62}
{"parent_id": "97c49ac9-6ab5-4469-8bcc-f06cb1cfa6e6", "subject": "Phantichthietkehttt", "section": "5.1 TỔ CHỨC DỰ ÁN", "title_path": "5.1 TỔ CHỨC DỰ ÁN", "content": "[Phantichthietkehttt / 5.1 TỔ CHỨC DỰ ÁN] Dự án trong Eclipse được tổ chức như Hình 5.1: Các lớp thực thể và điều khiển để trong thư mục \\java resources, chia nhỏ thành các package con tương ứng: model, dao. • Các trang jsp để trong thư mục \\Web content, phần xử lí đăng nhập để ở thu mục chung này, các phần xử lí riêng có thể để vào các thư mục con. Ví dụ, phần xử lí các chức năng của sinh viên thì để vào thư mục con \\sv • Các thư viện (file .jar) của kết nối CSDL, Junit thì add vào phần libraries của java resources, đồng thời copy vào thư mục \\Web content\\WEB-INF\\lib", "order_start": 0, "order_end": 532, "word_count": 112}
{"parent_id": "a4f9c885-58d6-4ef3-b65d-0c80402c7986", "subject": "Phantichthietkehttt", "section": "5.2 CÀI ĐẶT CÁC MODUL", "title_path": "5.2 CÀI ĐẶT CÁC MODUL", "content": "[Phantichthietkehttt / 5.2 CÀI ĐẶT CÁC MODUL] Nội dung phần này sẽ trình bày cài đặt 3 chức năng: sinh viên đăng kí, giảng viên nhập điểm LHP, và quản lí xem thống kê loại học lực. Tuy nhiên: Phần thực thể không trình bày code ở đây và coi như bài tập đơn giản cho người đọc. Chức năng nhập điểm và xem thống kê chỉ được cài đặt phần DAO, phần JSP cũng coi như là bài tập cho người đọc. Riêng chức năng sinh viên đăng kí được trình bày đầy đủ DAO và các trang JSP. Phần JSP chỉ sử dụng JSP đơn giản nhất mà chưa áp dụng framwork nào vào với mục đích chính là minh họa nghiệp vụ. Cho nên cũng chưa có xử lí html/css. Người đọc có thể áp dụng thêm vào để tăng tính thẩm mỹ của phần giao diện. Người đọc cần chỉnh sửa thông tin kết nối vào CSDL (dbUrl và dbClass, username, password) trong lớp DAO cho phù hợp với cấu hình CSDL trên máy mình Nếu người đọc đổi tên bảng/tên cột trong CSDL thì phải cập nhật tương ứng trong các câu lệnh SQL. Các lớp DAO có sử dụng store procedure thì ngay sau code của lớp sẽ là code của các Store Procedure tương ứng được gọi trong lớp đó.", "order_start": 0, "order_end": 1023, "word_count": 220}
{"parent_id": "c1f3dc81-34b7-43da-8ec2-a577aca8bb3e", "subject": "Phantichthietkehttt", "section": "Lớp DAO.java", "title_path": "Lớp DAO.java", "content": "[Phantichthietkehttt / Lớp DAO.java] package dao; import java.sql.Connection; import java.sql.DriverManager; public class DAO { public static Connection con; public DAO(){ if(con == null){ String dbUrl = \"jdbc:mysql://localhost:3307/qldktc? autoReconnect=true&useSSL=false\"; String dbClass = \"com.mysql.jdbc.Driver\"; try { Class.forName(dbClass); con = DriverManager.getConnection (dbUrl, \"root\", \"Cnpm@2020?\"); }catch(Exception e) { e.printStackTrace(); } }", "order_start": 0, "order_end": 421, "word_count": 43}
{"parent_id": "b180db81-b05a-4f6a-b2af-afed8659b762", "subject": "Phantichthietkehttt", "section": "Lớp ThanhvienDAO.java", "title_path": "Lớp ThanhvienDAO.java", "content": "[Phantichthietkehttt / Lớp ThanhvienDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import model.Hoten; import model.Thanhvien; public class ThanhvienDAO extends DAO{ public ThanhvienDAO() { super(); // TODO Auto-generated constructor stub } public boolean kiemtraDangnhap(Thanhvien tv){ boolean kq = false; if(tv.getUsername().contains(\"true\") || tv.getUsername().contains(\"=\")|| tv.getPassword().contains(\"true\") || tv.getPassword().contains(\"=\")) return false; String sql = \"{call kiemtraDN(?,?)}\"; //su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); cs.setString(1,tv.getUsername()); cs.setString(2,tv.getPassword()); ResultSet rs = cs.executeQuery(); if(rs.next()){ tv.setId(rs.getInt(\"id\")); tv.setVaitro(rs.getString(\"vaitro\")); //hoten Hoten ht = new Hoten(); ht.setHodem(rs.getString(\"hodem\")); ht.setTen(rs.getString(\"ten\")); tv.setHoten(ht); kq = true; } }catch(Exception e){ e.", "order_start": 0, "order_end": 905, "word_count": 80}
{"parent_id": "b180db81-b05a-4f6a-b2af-afed8659b762", "subject": "Phantichthietkehttt", "section": "Lớp ThanhvienDAO.java", "title_path": "Lớp ThanhvienDAO.java", "content": "[Phantichthietkehttt / Lớp ThanhvienDAO.java] o(rs.getString(\"vaitro\")); //hoten Hoten ht = new Hoten(); ht.setHodem(rs.getString(\"hodem\")); ht.setTen(rs.getString(\"ten\")); tv.setHoten(ht); kq = true; } }catch(Exception e){ e.printStackTrace(); kq = false; } return kq; } } CREATE DEFINER=`root`@`localhost` PROCEDURE `kiemtraDN`(IN usr VARCHAR(255), IN pwd VARCHAR(255)) BEGIN SELECT * FROM tblthanhvien WHERE username = usr AND password = pwd; END", "order_start": 905, "order_end": 1308, "word_count": 48}
{"parent_id": "09f7758e-0c52-4a99-bd10-f4d59df4e2d3", "subject": "Phantichthietkehttt", "section": "Lớp KihocDAO.java", "title_path": "Lớp KihocDAO.java", "content": "[Phantichthietkehttt / Lớp KihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Hocki; import model.Kihoc; import model.Namhoc; public class KihocDAO extends DAO{ public KihocDAO() { super(); // TODO Auto-generated constructor stub } /** * Lay danh sach cac hoc ki dang mo cho sinh vien chon dang ki hoc * @return danh sach ki hoc dang mo dang ki */ public ArrayList<Kihoc> getKihocdangki(){ ArrayList<Kihoc> kq=null; String sql = \"{call kiDangDK()}\"; //su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); ResultSet rs = cs.executeQuery(); while(rs.next()){ if(kq == null) kq = new ArrayList<Kihoc>(); Kihoc kh = new Kihoc(); kh.setId(rs.getInt(\"idkihoc\")); //nam hoc Namhoc nh = new Namhoc(); nh.setId(rs.getInt(\"idnamhoc\")); nh.setTen(rs.getString(\"namhoc\")); kh.setNamhoc(nh); //hoc ki Hocki hk = new Hocki(); hk.setId(rs.getInt(\"idhocki\")); hk.setTen(rs.getString(\"hocki\")); kh.setHocki(hk); kq.add(kh); } }catch(Exception e){ e.", "order_start": 0, "order_end": 992, "word_count": 119}
{"parent_id": "09f7758e-0c52-4a99-bd10-f4d59df4e2d3", "subject": "Phantichthietkehttt", "section": "Lớp KihocDAO.java", "title_path": "Lớp KihocDAO.java", "content": "[Phantichthietkehttt / Lớp KihocDAO.java] mhoc\")); kh.setNamhoc(nh); //hoc ki Hocki hk = new Hocki(); hk.setId(rs.getInt(\"idhocki\")); hk.setTen(rs.getString(\"hocki\")); kh.setHocki(hk); kq.add(kh); } }catch(Exception e){ e.printStackTrace(); kq = null; } return kq; } } CREATE DEFINER=`root`@`localhost` PROCEDURE `kiDangDK`() BEGIN SELECT a.id as idnamhoc, a.ten as namhoc, b.id as idhocki, b.ten as hocki, c.id as idkihoc FROM tblnamhoc a, tblhocki b, tblkihoc c WHERE c.idnamhoc = a.id AND c.idhocki = b.id AND c.dangdk = 1; END", "order_start": 992, "order_end": 1480, "word_count": 66}
{"parent_id": "c3b9ee9d-f10f-42ed-8c4f-b7ad7db973ee", "subject": "Phantichthietkehttt", "section": "Lớp SinhvienKhoaDAO.java", "title_path": "Lớp SinhvienKhoaDAO.java", "content": "[Phantichthietkehttt / Lớp SinhvienKhoaDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Hoten; import model.Khoa; import model.Sinhvien; import model.SinhvienKhoa; public class SinhvienKhoaDAO extends DAO{ public SinhvienKhoaDAO() { super(); // TODO Auto-generated constructor stub } /** * lay danh sach cac khoa/nganh ma sinh vien dang hoc de chon dang ki hoc * @param idSV: id cua sinh vien * @return danh sach cacs doi tuong SinhvienKhoa */ public ArrayList<SinhvienKhoa> getNganhcuaSV(int idSV){ ArrayList<SinhvienKhoa> kq = null; String sql = \"{call nganhcuaSV(?)}\";// su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql);", "order_start": 0, "order_end": 676, "word_count": 86}
{"parent_id": "b91dfbda-6bee-4ed8-a9e4-d924b1a7854a", "subject": "Phantichthietkehttt", "section": "Lớp MonhocKihocDAO.java", "title_path": "Lớp MonhocKihocDAO.java", "content": "[Phantichthietkehttt / Lớp MonhocKihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Kihoc; import model.Monhoc; import model.MonhocKihoc; public class MonhocKihocDAO extends DAO{ public MonhocKihocDAO() { super(); // TODO Auto-generated constructor stub } /** * Lay danh sach cac mon hoc duoc day trong hoc ki @idKihoc * @param idSVK: id cua sinh vien theo khoa/nganh hoc * @param idKihoc: id cua ki hoc dang chon * @return danh sach cac mon hoc duoc phep */ public ArrayList<MonhocKihoc> getMHcuaSV(int idSVK, int idKihoc){ ArrayList<MonhocKihoc> kq = null; String sql = \"{call MHmaSVduocDK(?,?)}\";// su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); cs.setInt(1, idSVK); cs.setInt(2, idKihoc); ResultSet rs = cs.executeQuery(); while(rs.next()){ if(kq == null) kq = new ArrayList<MonhocKihoc>(); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(rs.getInt(\"idmhkh\")); //mon hoc Monhoc mh = new Monhoc(); mh.setId(rs.getInt(\"idmh\")); mh.setTen(rs.getString(\"tenmh\")); mh.setSoTC(rs.getInt(\"sotc\")); mhkh.", "order_start": 0, "order_end": 1061, "word_count": 129}
{"parent_id": "b91dfbda-6bee-4ed8-a9e4-d924b1a7854a", "subject": "Phantichthietkehttt", "section": "Lớp MonhocKihocDAO.java", "title_path": "Lớp MonhocKihocDAO.java", "content": "[Phantichthietkehttt / Lớp MonhocKihocDAO.java] hocKihoc(); mhkh.setId(rs.getInt(\"idmhkh\")); //mon hoc Monhoc mh = new Monhoc(); mh.setId(rs.getInt(\"idmh\")); mh.setTen(rs.getString(\"tenmh\")); mh.setSoTC(rs.getInt(\"sotc\")); mhkh.setMonhoc(mh); //ki hoc Kihoc kh = new Kihoc(); kh.setId(idKihoc); mhkh.setKihoc(kh); kq.add(mhkh); } }catch(Exception e){ e.printStackTrace(); kq = null; } return kq; }", "order_start": 1061, "order_end": 1410, "word_count": 34}
{"parent_id": "7fc23bd0-8a23-4f97-8196-fb9ac70b789e", "subject": "Phantichthietkehttt", "section": "Lớp LophocphanDAO.java", "title_path": "Lớp LophocphanDAO.java", "content": "[Phantichthietkehttt / Lớp LophocphanDAO.java] int) BEGIN DECLARE idKH INT; SELECT idkihoc INTO idKH FROM tblmonhockihoc WHERE id = idMHKH; DROP TEMPORARY TABLE IF EXISTS slotdadangki; CREATE TEMPORARY TABLE slotdadangki AS SELECT a.idtuan, a.idngay, a.idkip FROM tbllichhoc a, tbllophocphan b, tbldangkihoc c, tblmonhockihoc d WHERE d.idkihoc = idKH AND b.idmonhockihoc = d.id AND a.idlophocphan = b.id AND c.idlophocphan = b.id AND c.idsinhvienkhoa = idSVK; DROP TEMPORARY TABLE IF EXISTS lhpchuaday; CREATE TEMPORARY TABLE lhpchuaday AS SELECT a.id, a.ten, a.sisotoida, a.idmonhockihoc, COUNT(e.id) as sisothuc FROM tbllophocphan a LEFT JOIN tbldangkihoc e ON e.idlophocphan = a.id WHERE a.idmonhockihoc = idMHKH GROUP BY a.id HAVING a.sisotoida > sisothuc; SELECT a.*, b.idkihoc, d.id as idmh, d.ten as tenmh, d.sotc FROM lhpchuaday a, tblmonhockihoc b, tblmonhoc d WHERE a.id NOT IN (SELECT b.id FROM tbllichhoc b, slotdadangki c WHERE b.idtuan = c.idtuan AND b.idngay = c.idngay AND b.idkip = c.idkip) AND b.id = a.idmonhockihoc AND d.id = b.", "order_start": 0, "order_end": 1001, "word_count": 148}
{"parent_id": "7fc23bd0-8a23-4f97-8196-fb9ac70b789e", "subject": "Phantichthietkehttt", "section": "Lớp LophocphanDAO.java", "title_path": "Lớp LophocphanDAO.java", "content": "[Phantichthietkehttt / Lớp LophocphanDAO.java] d WHERE a.id NOT IN (SELECT b.id FROM tbllichhoc b, slotdadangki c WHERE b.idtuan = c.idtuan AND b.idngay = c.idngay AND b.idkip = c.idkip) AND b.id = a.idmonhockihoc AND d.id = b.idmonhoc; END", "order_start": 1001, "order_end": 1194, "word_count": 33}
{"parent_id": "f5acc82f-64a1-4a5c-a566-1e61af461f97", "subject": "Phantichthietkehttt", "section": "Lớp LichhocDAO.java", "title_path": "Lớp LichhocDAO.java", "content": "[Phantichthietkehttt / Lớp LichhocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Giangvien; import model.Hoten; import model.Kiphoc; import model.Lichhoc; import model.Lophocphan; import model.Ngayhoc; import model.Phonghoc; import model.Tuanhoc;", "order_start": 0, "order_end": 281, "word_count": 24}
{"parent_id": "97db62a4-af4c-4b66-83ad-a12fedb43d38", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] dk.setLophocphan(lhp); //sinhvienkhoa SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(idSVK); //sinh vien Sinhvien sv = new Sinhvien(); sv.setId(rs.getInt(\"idsinhvien\")); svk.setSinhvien(sv); //khoa Khoa k = new Khoa(); k.setId(rs.getInt(\"idkhoa\")); svk.setKhoa(k); dk.setSinhvienKhoa(svk); kq.add(dk); } }catch(Exception e){ e.printStackTrace(); kq = null; } return kq; } public boolean luuDKcuaSV(ArrayList<Dangkihoc> listDK){ if((listDK == null)|| (listDK.size() ==0)) return false; boolean kq = false; String sqlXoa = \"DELETE FROM tbldangkihoc WHERE idsinhvienkhoa=? AND idlophocphan IN \" + \"(SELECT a.id FROM tbllophocphan a, tblmonhockihoc b WHERE b.idkihoc = ? AND a.idmonhockihoc=b.id)\"; String sqlThem = \"INSERT INTO tbldangkihoc(idsinhvienkhoa, idlophocphan) VALUES(?,?)\"; try{ this.con.setAutoCommit(false); //xoa het dang ki cu int idSVK = listDK.get(0).getSinhvienKhoa().getId(); int idKihoc = listDK.get(0).getLophocphan(). getMonhocKihoc().getKihoc().getId(); PreparedStatement psXoa = con.prepareStatement(sqlXoa); psXoa.setInt(1, idSVK); psXoa.setInt(2, idKihoc); psXoa.", "order_start": 0, "order_end": 1088, "word_count": 112}
{"parent_id": "97db62a4-af4c-4b66-83ad-a12fedb43d38", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] listDK.get(0).getLophocphan(). getMonhocKihoc().getKihoc().getId(); PreparedStatement psXoa = con.prepareStatement(sqlXoa); psXoa.setInt(1, idSVK); psXoa.setInt(2, idKihoc); psXoa.executeUpdate(); //them lai dang ki nhu dang ki moi for(Dangkihoc dk : listDK){ PreparedStatement psThem = con.prepareStatement(sqlThem); psThem.setInt(1, dk.getSinhvienKhoa().getId());", "order_start": 1088, "order_end": 1453, "word_count": 29}
{"parent_id": "93b59c53-310a-428a-8d29-60a22c2b421d", "subject": "Phantichthietkehttt", "section": "Trang gddangnhap.jsp", "title_path": "Trang gddangnhap.jsp", "content": "[Phantichthietkehttt / Trang gddangnhap.jsp] @ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.ArrayList,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <title>Dang nhap</title> </head> <body> <% if(request.getParameter(\"err\") !=null && request.getParameter(\"err\").equalsIgnoreCase(\"timeout\")){ %> <h4>Hết phiên làm việc. Làm ơn đăng nhập lại!</h4><% }else if(request.getParameter(\"err\") !=null && request.getParameter(\"err\").equalsIgnoreCase(\"fail\")){ %> <h4 color=\"red\">Sai tên đăng nhập/mật khẩu!</h4><% } %> <h2> Đăng nhập </h2> <form name=\"dangnhap\" action=\"doDangnhap.", "order_start": 0, "order_end": 734, "word_count": 61}
{"parent_id": "93b59c53-310a-428a-8d29-60a22c2b421d", "subject": "Phantichthietkehttt", "section": "Trang gddangnhap.jsp", "title_path": "Trang gddangnhap.jsp", "content": "[Phantichthietkehttt / Trang gddangnhap.jsp] && request.getParameter(\"err\").equalsIgnoreCase(\"fail\")){ %> <h4 color=\"red\">Sai tên đăng nhập/mật khẩu!</h4><% } %> <h2> Đăng nhập </h2> <form name=\"dangnhap\" action=\"doDangnhap.jsp\" method=\"post\"> <table border=\"0\"> <tr> <td>Tên đăng nhập:</td> <td><input type=\"text\" name=\"username\" id=\"username\" required /></td> </tr> <tr> <td>Mật khẩu:</td> <td><input type=\"password\" name=\"password\" id=\"password\" required /></td> </tr> <tr> <td></td> <td><input type=\"submit\" value=\"Đăng nhập\" /></td> </tr> </table> </form> </body> </html>", "order_start": 734, "order_end": 1265, "word_count": 54}
{"parent_id": "7edc19b0-8b8b-4bd1-9518-b66ce368f879", "subject": "Phantichthietkehttt", "section": "Trang doDangnhap.jsp", "title_path": "Trang doDangnhap.jsp", "content": "[Phantichthietkehttt / Trang doDangnhap.jsp] page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.ArrayList,dao.*,model.*\"%> String username = (String)request.getParameter(\"username\"); String password = (String)request.getParameter(\"password\"); Thanhvien tv = new Thanhvien(); tv.setUsername(username); tv.setPassword(password); ThanhvienDAO dao = new ThanhvienDAO(); boolean kq = dao.kiemtraDangnhap(tv); if(kq && (tv.getVaitro().equalsIgnoreCase(\"sinhvien\"))){ session.setAttribute(\"sinhvien\", tv); response.sendRedirect(\"sv\\\\gdchinhsv.jsp\"); }else if(kq &&(tv.getVaitro().equalsIgnoreCase(\"giangvien\"))){ session.setAttribute(\"giangvien\", tv); response.sendRedirect(\"gv\\\\gdchinhgv.jsp\"); }else{ response.sendRedirect(\"gddangnhap.", "order_start": 0, "order_end": 733, "word_count": 44}
{"parent_id": "7edc19b0-8b8b-4bd1-9518-b66ce368f879", "subject": "Phantichthietkehttt", "section": "Trang doDangnhap.jsp", "title_path": "Trang doDangnhap.jsp", "content": "[Phantichthietkehttt / Trang doDangnhap.jsp] f(kq &&(tv.getVaitro().equalsIgnoreCase(\"giangvien\"))){ session.setAttribute(\"giangvien\", tv); response.sendRedirect(\"gv\\\\gdchinhgv.jsp\"); }else{ response.sendRedirect(\"gddangnhap.jsp?err=fail\"); }", "order_start": 733, "order_end": 930, "word_count": 8}
{"parent_id": "e7bb852f-4de0-4af6-8787-450013fad9f3", "subject": "Phantichthietkehttt", "section": "Trang gdChinhSV.jsp", "title_path": "Trang gdChinhSV.jsp", "content": "[Phantichthietkehttt / Trang gdChinhSV.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <%@include file =\"../header.jsp\" %> <title>Trang chu sinh vien</title> </head> <body> <% Thanhvien sv = (Thanhvien)session.getAttribute(\"sinhvien\"); if(sv==null){ response.sendRedirect(\"dangnhap.jsp?err=timeout\"); } %> <h2> Trang chủ sinh viên </h2> <button onclick=\"openPage('gdchonnganh.jsp')\">Đăng kí học</button> </body> </html>", "order_start": 0, "order_end": 621, "word_count": 52}
{"parent_id": "c46ef38b-94b0-4abd-bcdd-5d40489c76f3", "subject": "Phantichthietkehttt", "section": "Trang gdChonnganh.jsp", "title_path": "Trang gdChonnganh.jsp", "content": "[Phantichthietkehttt / Trang gdChonnganh.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> </tr> <tr> <td></td> <td><input type=\"submit\" value=\"Vào đăng kí\" /></td> </tr> </table> </form> </body> </html>", "order_start": 0, "order_end": 344, "word_count": 30}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <%@include file =\"../header.jsp\" %> <title>Dang ki hoc</title> </head> <% //lay id sinh vien Thanhvien sv = (Thanhvien)session.getAttribute(\"sinhvien\"); if(sv==null){ response.sendRedirect(\"dangnhap.jsp?err=timeout\"); } ArrayList<Dangkihoc> listDK = null; SinhvienKhoa svk = null; //kiem tra cach trang nay bi goi String action = request.getParameter(\"action\"); if ((action == null)||(action.trim().length() ==0)) {//goi tu trang chon nganh //lay du lieu nganh hoc va ki hoc int idSVK = Integer.parseInt(request.getParameter(\"nganh\")); int idKihoc = Integer.parseInt(request.getParameter(\"kihoc\")); session.setAttribute(\"idSVK\", idSVK); session.setAttribute(\"idKihoc\", idKihoc); //lay thong tin sinh vien + nganh hoc ArrayList<SinhvienKhoa> listSVK = (ArrayList<SinhvienKhoa>)session.", "order_start": 0, "order_end": 1091, "word_count": 102}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] on.setAttribute(\"idSVK\", idSVK); session.setAttribute(\"idKihoc\", idKihoc); //lay thong tin sinh vien + nganh hoc ArrayList<SinhvienKhoa> listSVK = (ArrayList<SinhvienKhoa>)session.getAttribute(\"listSVK\"); for(SinhvienKhoa tmp:listSVK) if(tmp.getId() == idSVK){ svk = tmp; } //lay danh sach dang ki cua sinh vien, neu co listDK = (new DangkihocDAO()).getDKcuaSV(idSVK, idKihoc); else if (action.equalsIgnoreCase(\"them\")) {// goi tu trang chon lop hoc phan listDK = (ArrayList<Dangkihoc>)session.getAttribute(\"dangkihoc\"); if(listDK == null) listDK = new ArrayList<Dangkihoc>(); svk = (SinhvienKhoa)session.getAttribute(\"sinhvienkhoa\"); ArrayList<Lophocphan> listLHP = (ArrayList<Lophocphan>)session.getAttribute(\"listLHP\"); int idLHP = Integer.parseInt(request.getParameter(\"idlhp\")); boolean daTontaiLHP = false; for(Dangkihoc dk:listDK){ if(dk.getLophocphan().getId() == idLHP){ daTontaiLHP = true; break; } } if(!daTontaiLHP){ //tao dang ki moi Dangkihoc dkMoi = null; for (Lophocphan lhp : listLHP) if (lhp.getId() == idLHP) { dkMoi = new Dangkihoc(); dkMoi.setLophocphan(lhp); dkMoi.", "order_start": 1091, "order_end": 2178, "word_count": 112}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] } } if(!daTontaiLHP){ //tao dang ki moi Dangkihoc dkMoi = null; for (Lophocphan lhp : listLHP) if (lhp.getId() == idLHP) { dkMoi = new Dangkihoc(); dkMoi.setLophocphan(lhp); dkMoi.setSinhvienKhoa(svk); } //kiem tra co phai sua dang ki cu khong boolean daTontaiMHKH = false; int index = 0; for (Dangkihoc dk : listDK) { if (dk.getLophocphan().getMonhocKihoc().getId() == dkMoi .getLophocphan().getMonhocKihoc().getId()) { listDK.remove(dk); break; } index++; } //them dang ki moi vao danh sach listDK.add(index, dkMoi); } } else if (action.equalsIgnoreCase(\"xoa\")) {// goi tu trang dang ki, de xoa listDK = (ArrayList<Dangkihoc>)session.getAttribute(\"dangkihoc\"); if (listDK == null) listDK = new ArrayList<Dangkihoc>(); svk = (SinhvienKhoa)session.getAttribute(\"sinhvienkhoa\"); int idLHP = Integer.parseInt(request.getParameter(\"idlhp\")); for (Dangkihoc dk : listDK) if (dk.getLophocphan().getId() == idLHP) { listDK.remove(dk); break; } } session.setAttribute(\"sinhvienkhoa\", svk); session.", "order_start": 2178, "order_end": 3169, "word_count": 119}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] est.getParameter(\"idlhp\")); for (Dangkihoc dk : listDK) if (dk.getLophocphan().getId() == idLHP) { listDK.remove(dk); break; } } session.setAttribute(\"sinhvienkhoa\", svk); session.setAttribute(\"dangkihoc\", listDK); %> <body> <h2> Đăng kí học </h2> <table border=\"0\"> <tr> <td> <%if(svk != null){ %> <p/>Họ tên: <%=svk.getSinhvien().getHoten().getHodem() %> < %=svk.getSinhvien().getHoten().getTen() %> <p/>Mã: <%=svk.getSinhvien().getMasv() %> <p/>Ngành: <%=svk.getKhoa().getTen() %> <%} %> </td> </tr> <tr><td> <h3> Các môn đã đăng kí: </h3> </td> </tr> <tr> <td> <table style=\"border: 1px solid black;border-collapse: collapse;\" > <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.", "order_start": 3169, "order_end": 3871, "word_count": 79}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] ôn đã đăng kí: </h3> </td> </tr> <tr> <td> <table style=\"border: 1px solid black;border-collapse: collapse;\" > <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.T</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Mã môn học</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Tên môn học</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Tên lớp học phần</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Xem lịch</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Sửa</td> <td style=\"border: 1px solid black;padding:0 15px 0 15px;\">Xóa</td> </thead> <% int soTC =0; if(listDK != null) for(int i=0; i<listDK.size(); i++){ soTC += listDK.get(i).getLophocphan().getMonhocKihoc().getMonhoc().getSoTC(); %> <tr> <td style=\"text-align:center; padding:0 15px 0 15px;\"><%=(i+1) %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listDK.get(i).getLophocphan().getMonhocKihoc().getMonhoc().getId() %></td> <td style=\"padding:0 15px 0 15px;\">< %=listDK.get(i).getLophocphan().getMonhocKihoc().", "order_start": 3871, "order_end": 4960, "word_count": 124}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] 15px 0 15px;\">< %=listDK.get(i).getLophocphan().getMonhocKihoc().getMonhoc().getId() %></td> <td style=\"padding:0 15px 0 15px;\">< %=listDK.get(i).getLophocphan().getMonhocKihoc().getMonhoc().getTen() %></td> <td style=\"padding:0 15px 0 15px;\"><%=listDK.get(i).getLophocphan().getTen() %></t <td style=\"text-align:center; padding:0 15px 0 15px;\"> <a href=\"gdxemlich.jsp?idlhp=<%=listDK.get(i).getLophocphan().getId()%>\">Xem lịch</a></td> <td style=\"text-align:center; padding:0 15px 0 15px;\"> <a href=\"gdchonlhp.jsp?idmhkh=< %=listDK.get(i).getLophocphan().getMonhocKihoc().getId()%>\">Sửa</a></td> <td style=\"text-align:center; padding:0 15px 0 15px;\"> <a href=\"gddangki.jsp?action=xoa&&idlhp=<%=listDK.get(i).getLophocphan().getId()%>\" onclick=\"return confirm('Bạn muốn xóa lớp học phần khỏi danh sách đăng kí?');\">Xóa</a></td> </tr> <%} %> </table> <p/>Tổng số tín chỉ: <%=soTC%> </td> </tr> <tr> <td> <button onclick=\"openPage('gdchinhsv.jsp')\">Về trang chính</button> <button onclick=\"openPage('gdchonmh.jsp')\">Chọn tiếp</button> <button onclick=\"openPage('doluudk.", "order_start": 4960, "order_end": 6028, "word_count": 78}
{"parent_id": "fd08b781-cc6d-4605-9b27-49862b8958d9", "subject": "Phantichthietkehttt", "section": "Trang gdDangki.jsp", "title_path": "Trang gdDangki.jsp", "content": "[Phantichthietkehttt / Trang gdDangki.jsp] /tr> <tr> <td> <button onclick=\"openPage('gdchinhsv.jsp')\">Về trang chính</button> <button onclick=\"openPage('gdchonmh.jsp')\">Chọn tiếp</button> <button onclick=\"openPage('doluudk.jsp')\">Lưu đăng kí</button> </td> </tr> </table> </body> </html>", "order_start": 6028, "order_end": 6272, "word_count": 19}
{"parent_id": "4848000f-a51d-4c90-adc2-7bc3b6683497", "subject": "Phantichthietkehttt", "section": "Trang gdChonMH.jsp", "title_path": "Trang gdChonMH.jsp", "content": "[Phantichthietkehttt / Trang gdChonMH.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <title>Chon mon hoc</title> </head> <% //lay id sinh vien Thanhvien sv = (Thanhvien)session.getAttribute(\"sinhvien\"); if(sv==null){ response.sendRedirect(\"dangnhap.jsp?err=timeout\"); } //lay du lieu nganh hoc va ki hoc int idSVK = (int)session.getAttribute(\"idSVK\"); int idKihoc = (int)session.getAttribute(\"idKihoc\"); //lay danh sach mon hoc duoc dang ki ArrayList<MonhocKihoc> listMHKH = (new MonhocKihocDAO()).getMHcuaSV(idSVK, idKihoc); //loai bo cac mon hoc da dang ki ArrayList<Dangkihoc> listDK = (ArrayList<Dangkihoc>)session.getAttribute(\"dangkihoc\"); if(listDK != null) for(int i=0; i<listMHKH.size(); i++){ boolean daDK = false; for(Dangkihoc dk:listDK) if(dk.getLophocphan().getMonhocKihoc().getId() == listMHKH.get(i).getId()){ daDK = true; break; } if(daDK){ listMHKH.", "order_start": 0, "order_end": 1089, "word_count": 102}
{"parent_id": "4848000f-a51d-4c90-adc2-7bc3b6683497", "subject": "Phantichthietkehttt", "section": "Trang gdChonMH.jsp", "title_path": "Trang gdChonMH.jsp", "content": "[Phantichthietkehttt / Trang gdChonMH.jsp] H.size(); i++){ boolean daDK = false; for(Dangkihoc dk:listDK) if(dk.getLophocphan().getMonhocKihoc().getId() == listMHKH.get(i).getId()){ daDK = true; break; } if(daDK){ listMHKH.remove(i); //if(i>0) i--; } } session.setAttribute(\"listMHKH\", listMHKH); %> <body> <h2> Chọn môn học </h2> <table style=\"border: 1px solid black;border-collapse: collapse;\"> <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.T</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Mã môn học</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Tên môn học</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Số tín chỉ</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Chọn</td> </thead> <% if(listMHKH != null) for(int i=0; i<listMHKH.size(); i++){ %> <tr> <td style=\"text-align:center; padding:0 15px 0 15px;\"><%=(i+1) %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listMHKH.get(i).getMonhoc().getId() %></td> <td style=\"padding:0 15px 0 15px;\"><%=listMHKH.get(i).getMonhoc().", "order_start": 1089, "order_end": 2137, "word_count": 119}
{"parent_id": "4848000f-a51d-4c90-adc2-7bc3b6683497", "subject": "Phantichthietkehttt", "section": "Trang gdChonMH.jsp", "title_path": "Trang gdChonMH.jsp", "content": "[Phantichthietkehttt / Trang gdChonMH.jsp] +1) %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listMHKH.get(i).getMonhoc().getId() %></td> <td style=\"padding:0 15px 0 15px;\"><%=listMHKH.get(i).getMonhoc().getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listMHKH.get(i).getMonhoc().getSoTC() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\"> <a href=\"gdchonlhp.jsp?idmhkh=<%=listMHKH.get(i).getId()%>\">Chọn</a></td> </tr> <%} %> </table> <br/> <button type=\"button\" name=\"back\" onclick=\"history.back()\">Quay lại</button> </body>", "order_start": 2137, "order_end": 2679, "word_count": 43}
{"parent_id": "2f2d3a54-1084-49b9-b8e8-108f81ee76d7", "subject": "Phantichthietkehttt", "section": "Trang gdChonLHP.jsp", "title_path": "Trang gdChonLHP.jsp", "content": "[Phantichthietkehttt / Trang gdChonLHP.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <title>Chon lop hoc phan</title> </head> <% //lay id sinh vien Thanhvien sv = (Thanhvien)session.getAttribute(\"sinhvien\"); if(sv==null){ response.sendRedirect(\"dangnhap.jsp?err=timeout\"); } //lay du lieu nganh hoc va ki hoc int idSVK = (int)session.getAttribute(\"idSVK\"); int idMHKH = Integer.parseInt(request.getParameter(\"idmhkh\")); //lay danh sach mon hoc duoc dang ki ArrayList<Lophocphan> listLHP = (new LophocphanDAO()).getLHPchoSVdangki(idSVK, idMHKH); //loai cac LHP trung lich voi cac lop da hoc ArrayList<Dangkihoc> listDK = (ArrayList<Dangkihoc>)session.getAttribute(\"dangkihoc\"); if((listDK !=null) && (listLHP !=null)){ ArrayList<Lichhoc> lichdachon = new ArrayList<Lichhoc>(); LichhocDAO lhdao = new LichhocDAO(); for(Dangkihoc dk:listDK){ lichdachon.addAll(lhdao.getLHcuaLHP(dk.", "order_start": 0, "order_end": 1100, "word_count": 100}
{"parent_id": "2f2d3a54-1084-49b9-b8e8-108f81ee76d7", "subject": "Phantichthietkehttt", "section": "Trang gdChonLHP.jsp", "title_path": "Trang gdChonLHP.jsp", "content": "[Phantichthietkehttt / Trang gdChonLHP.jsp] (listLHP !=null)){ ArrayList<Lichhoc> lichdachon = new ArrayList<Lichhoc>(); LichhocDAO lhdao = new LichhocDAO(); for(Dangkihoc dk:listDK){ lichdachon.addAll(lhdao.getLHcuaLHP(dk.getLophocphan().getId())); } for(int i=0; i<listLHP.size(); i++){ ArrayList<Lichhoc> listLH = lhdao.getLHcuaLHP(listLHP.get(i).getId()); boolean ok = true; for(Lichhoc lhmoi:listLH){ for(Lichhoc lhdk:lichdachon) if(lhmoi.getTuanhoc().equals(lhdk.getTuanhoc()) && lhmoi.getNgayhoc().equals(lhdk.getNgayhoc()) && lhmoi.getKiphoc().equals(lhdk.getKiphoc())){ ok = false; break; } if(!ok) break; } if(!ok){ listLHP.remove(i); i--; } } } session.setAttribute(\"listLHP\", listLHP); %> <body> <%if(listLHP != null){ %> <h2> Chọn lớp học phần </h2> <table style=\"border: 1px solid black;border-collapse: collapse;\"> <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.", "order_start": 1100, "order_end": 1955, "word_count": 80}
{"parent_id": "2f2d3a54-1084-49b9-b8e8-108f81ee76d7", "subject": "Phantichthietkehttt", "section": "Trang gdChonLHP.jsp", "title_path": "Trang gdChonLHP.jsp", "content": "[Phantichthietkehttt / Trang gdChonLHP.jsp] P != null){ %> <h2> Chọn lớp học phần </h2> <table style=\"border: 1px solid black;border-collapse: collapse;\"> <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.T</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Mã lớp học phần</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Tên lớp học phần</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Sĩ số tối đa</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Sĩ số thực</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Lịch học</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Chọn</td> </thead> <% for(int i=0; i<listLHP.size(); i++){ %> <tr> <td style=\"text-align:center; padding:0 15px 0 15px;\"><%=(i+1) %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\"><%=listLHP.get(i).getId() %></td> <td style=\"padding:0 15px 0 15px;\"><%=listLHP.get(i).getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLHP.get(i).getSisotoida() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLHP.", "order_start": 1955, "order_end": 3051, "word_count": 134}
{"parent_id": "2f2d3a54-1084-49b9-b8e8-108f81ee76d7", "subject": "Phantichthietkehttt", "section": "Trang gdChonLHP.jsp", "title_path": "Trang gdChonLHP.jsp", "content": "[Phantichthietkehttt / Trang gdChonLHP.jsp] .getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLHP.get(i).getSisotoida() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLHP.get(i).getSisothucte() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\"> <a href=\"gdxemlich.jsp?idlhp=<%=listLHP.get(i).getId()%>\">Xem lịch</a></td> <td style=\"text-align:center; padding:0 15px 0 15px;\"> <a href=\"gddangki.jsp?action=them&&idlhp=<%=listLHP.get(i).getId()%>\">Chọn</a></td> </tr> <%} %> </table> <% }else{%> <h4> Không có lớp học phần nào trống lịch và còn chỗ</h4> <%} %> <br/> <button type=\"button\" name=\"back\" onclick=\"history.back()\">Quay lại</button> </body> </html>", "order_start": 3051, "order_end": 3729, "word_count": 63}
{"parent_id": "bcef2636-8ecf-4c61-a242-4205506fb633", "subject": "Phantichthietkehttt", "section": "Trang gdxemlich.jsp", "title_path": "Trang gdxemlich.jsp", "content": "[Phantichthietkehttt / Trang gdxemlich.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> <title>Xem lich hoc</title> </head> <% //lay id sinh vien Thanhvien sv = (Thanhvien)session.getAttribute(\"sinhvien\"); if(sv==null){ response.sendRedirect(\"dangnhap.jsp?err=timeout\"); } int idLHP = Integer.parseInt(request.getParameter(\"idlhp\")); //lay danh sach mon hoc duoc dang ki ArrayList<Lichhoc> listLH = (new LichhocDAO()).getLHcuaLHP(idLHP); %> <body> <h2> Lịch học </h2> <table style=\"border: 1px solid black;border-collapse: collapse;\"> <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.", "order_start": 0, "order_end": 823, "word_count": 75}
{"parent_id": "bcef2636-8ecf-4c61-a242-4205506fb633", "subject": "Phantichthietkehttt", "section": "Trang gdxemlich.jsp", "title_path": "Trang gdxemlich.jsp", "content": "[Phantichthietkehttt / Trang gdxemlich.jsp] uaLHP(idLHP); %> <body> <h2> Lịch học </h2> <table style=\"border: 1px solid black;border-collapse: collapse;\"> <thead><td style=\"border: 1px solid black; padding:0 15px 0 15px;\">T.T</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Tuần</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Thứ</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Kip</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Phòng học</td> <td style=\"border: 1px solid black; padding:0 15px 0 15px;\">Giảng viên</td> </thead> <% if(listLH != null) for(int i=0; i<listLH.size(); i++){ %> <tr> <td style=\"text-align:center; padding:0 15px 0 15px;\"><%=(i+1) %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLH.get(i).getTuanhoc().getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLH.get(i).getNgayhoc().getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLH.get(i).getKiphoc().getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLH.get(i).getPhonghoc().", "order_start": 823, "order_end": 1906, "word_count": 118}
{"parent_id": "bcef2636-8ecf-4c61-a242-4205506fb633", "subject": "Phantichthietkehttt", "section": "Trang gdxemlich.jsp", "title_path": "Trang gdxemlich.jsp", "content": "[Phantichthietkehttt / Trang gdxemlich.jsp] le=\"text-align:center; padding:0 15px 0 15px;\">< %=listLH.get(i).getKiphoc().getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=listLH.get(i).getPhonghoc().getTen() %></td> <td style=\"text-align:center; padding:0 15px 0 15px;\">< %=(listLH.get(i).getGiangvien().getHoten().getHodem()+\" \"+ listLH.get(i).getGiangvien().getHoten().getTen()) %></td> </tr> <%} %> </table> <br/> <button type=\"button\" name=\"back\" onclick=\"history.back()\">Quay lại</button> </body> </html>", "order_start": 1906, "order_end": 2396, "word_count": 37}
{"parent_id": "f44a9f6c-1363-40c2-bf3d-6da87383de97", "subject": "Phantichthietkehttt", "section": "Trang doluudk.jsp", "title_path": "Trang doluudk.jsp", "content": "[Phantichthietkehttt / Trang doluudk.jsp] <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*,dao.*,model.*\"%> <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> //lay id sinh vien Thanhvien sv = (Thanhvien)session.getAttribute(\"sinhvien\"); if(sv==null){ response.sendRedirect(\"dangnhap.jsp?err=timeout\"); } //lay thong tin dang ki va luu ArrayList<Dangkihoc> listDK = (ArrayList<Dangkihoc>)session.getAttribute(\"dangkihoc\"); if((new DangkihocDAO()).luuDKcuaSV(listDK)){ %> <script type=\"text/javascript\"> alert(\"Đăng kí thành công!\"); </script> <% response.sendRedirect(\"gdchinhsv.jsp\"); }else{ %> <script type=\"text/javascript\"> alert(\"Lỗi đăng kí!\"); history.", "order_start": 0, "order_end": 807, "word_count": 63}
{"parent_id": "f44a9f6c-1363-40c2-bf3d-6da87383de97", "subject": "Phantichthietkehttt", "section": "Trang doluudk.jsp", "title_path": "Trang doluudk.jsp", "content": "[Phantichthietkehttt / Trang doluudk.jsp] type=\"text/javascript\"> alert(\"Đăng kí thành công!\"); </script> <% response.sendRedirect(\"gdchinhsv.jsp\"); }else{ %> <script type=\"text/javascript\"> alert(\"Lỗi đăng kí!\"); history.back(); </script> <% }%>", "order_start": 807, "order_end": 1011, "word_count": 19}
{"parent_id": "2f18a2fe-d210-42fa-bb17-db144ee8ea44", "subject": "Phantichthietkehttt", "section": "Lớp KihocDAO.java", "title_path": "Lớp KihocDAO.java", "content": "[Phantichthietkehttt / Lớp KihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Hocki; import model.Kihoc; import model.Namhoc; public class KihocDAO extends DAO{ public KihocDAO() { super(); // TODO Auto-generated constructor stub } /** * Lay danh sach cac hoc ki dang hoc * @return danh sach ki hoc dang hoc */ public ArrayList<Kihoc> getKidanghoc(){ ArrayList<Kihoc> kq=null; String sql = \"{call kiDanghoc()}\"; //su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); ResultSet rs = cs.executeQuery(); while(rs.next()){ if(kq == null) kq = new ArrayList<Kihoc>(); Kihoc kh = new Kihoc(); kh.setId(rs.getInt(\"idkihoc\")); //nam hoc Namhoc nh = new Namhoc(); nh.setId(rs.getInt(\"idnamhoc\")); nh.setTen(rs.getString(\"namhoc\")); kh.setNamhoc(nh); //hoc ki Hocki hk = new Hocki(); hk.setId(rs.getInt(\"idhocki\")); hk.setTen(rs.getString(\"hocki\")); kh.setHocki(hk); kq.", "order_start": 0, "order_end": 920, "word_count": 106}
{"parent_id": "2f18a2fe-d210-42fa-bb17-db144ee8ea44", "subject": "Phantichthietkehttt", "section": "Lớp KihocDAO.java", "title_path": "Lớp KihocDAO.java", "content": "[Phantichthietkehttt / Lớp KihocDAO.java] hoc\")); nh.setTen(rs.getString(\"namhoc\")); kh.setNamhoc(nh); //hoc ki Hocki hk = new Hocki(); hk.setId(rs.getInt(\"idhocki\")); hk.setTen(rs.getString(\"hocki\")); kh.setHocki(hk); kq.add(kh); }", "order_start": 920, "order_end": 1110, "word_count": 15}
{"parent_id": "53299d4b-4a76-4ac7-b539-11f64e6ea392", "subject": "Phantichthietkehttt", "section": "Lớp MonhocKihocDAO.java", "title_path": "Lớp MonhocKihocDAO.java", "content": "[Phantichthietkehttt / Lớp MonhocKihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Kihoc; import model.Monhoc; import model.MonhocKihoc; public class MonhocKihocDAO extends DAO{ public MonhocKihocDAO() { super(); // TODO Auto-generated constructor stub } /** * lay danh sach cac mon hoc ma giang vien @idGV da dang ki day * @param idGV: id giang vien * @param idKihoc: id ki hoc * @return danh sach monhockihoc */ public ArrayList<MonhocKihoc> getMHcuaGV(int idGV, int idKihoc){ ArrayList<MonhocKihoc> kq = null; String sql = \"{call MHmaGVday(?,?)}\";// su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); cs.setInt(1, idGV); cs.setInt(2, idKihoc); ResultSet rs = cs.executeQuery(); while(rs.", "order_start": 0, "order_end": 747, "word_count": 96}
{"parent_id": "53299d4b-4a76-4ac7-b539-11f64e6ea392", "subject": "Phantichthietkehttt", "section": "Lớp MonhocKihocDAO.java", "title_path": "Lớp MonhocKihocDAO.java", "content": "[Phantichthietkehttt / Lớp MonhocKihocDAO.java] HmaGVday(?,?)}\";// su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); cs.setInt(1, idGV); cs.setInt(2, idKihoc); ResultSet rs = cs.executeQuery(); while(rs.next()){", "order_start": 747, "order_end": 935, "word_count": 19}
{"parent_id": "bc916bb6-0ebf-4da0-96e7-f7a7b48feb76", "subject": "Phantichthietkehttt", "section": "Lớp LophocphanDAO.java", "title_path": "Lớp LophocphanDAO.java", "content": "[Phantichthietkehttt / Lớp LophocphanDAO.java] /** * lay danh sach lop hoc phan ma giang vien @idGV day cua mon hoc @idMHKH * @param idMHKH id cua monhoc kihoc * @param idGV id cua giang vien * @return dang sach lop hoc phan */ public ArrayList<Lophocphan> getLHPmaGVday(int idGV, int idMHKH){ ArrayList<Lophocphan> kq = null; String sql = \"{call LHPmaGVday(?,?)}\";// su dung stored procedure try{ CallableStatement cs = con.prepareCall(sql); cs.setInt(1, idGV); cs.setInt(2, idMHKH); ResultSet rs = cs.executeQuery(); while(rs.next()){ if(kq == null) kq = new ArrayList<Lophocphan>(); Lophocphan lhp = new Lophocphan(); lhp.setId(rs.getInt(\"id\")); lhp.setTen(rs.getString(\"ten\")); lhp.setSisotoida(rs.getInt(\"sisotoida\")); //monhockihoc MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(idMHKH); lhp.setMonhocKihoc(mhkh); kq.add(lhp); } }catch(Exception e){ e.printStackTrace(); kq = null; } return kq; } } CREATE DEFINER=`root`@`localhost` PROCEDURE `LHPmaGVday`(IN idGV int, IN idMHKH int) BEGIN SELECT distinctrow a.* FROM tbllophocphan a, tbllichhoc b WHERE a.idmonhockihoc = idMHKH AND b.idlophocphan = a.id AND b.", "order_start": 0, "order_end": 1072, "word_count": 136}
{"parent_id": "bc916bb6-0ebf-4da0-96e7-f7a7b48feb76", "subject": "Phantichthietkehttt", "section": "Lớp LophocphanDAO.java", "title_path": "Lớp LophocphanDAO.java", "content": "[Phantichthietkehttt / Lớp LophocphanDAO.java] ` PROCEDURE `LHPmaGVday`(IN idGV int, IN idMHKH int) BEGIN SELECT distinctrow a.* FROM tbllophocphan a, tbllichhoc b WHERE a.idmonhockihoc = idMHKH AND b.idlophocphan = a.id AND b.idgiangvien = idGV; END", "order_start": 1072, "order_end": 1275, "word_count": 30}
{"parent_id": "59978b3e-4a1a-4140-aafc-c83feb672fdd", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Dangkihoc; import model.Daudiem; import model.Hoten; import model.Ketqua; import model.Khoa; import model.Kihoc; import model.Lophocphan; import model.Monhoc; import model.MonhocDaudiem; import model.MonhocKihoc; import model.Sinhvien; import model.SinhvienKhoa; public class DangkihocDAO extends DAO{ public DangkihocDAO() { super(); // TODO Auto-generated constructor stub } /** * lay danh sach diem cua cac sinh vien da dang ki vao lop hoc phan @idLHP * @param idLHP id cua lop hoc phan * @return danh sach cac doi tuong dang ki hoc, trong co cac dau diem */ public ArrayList<Dangkihoc> getDiemcuaLHP(int idLHP){ ArrayList<Dangkihoc> kq = null; String sqlDK = \"{call DKcuaLHP(?)}\";// su dung stored procedure String sqlDiem = \"{call DiemcuaDK(?)}\";// su dung stored procedure LichhocDAO ld = new LichhocDAO(); try{ CallableStatement cs = con.prepareCall(sqlDK); cs.setInt(1, idLHP); ResultSet rs = cs.executeQuery(); while(rs.", "order_start": 0, "order_end": 1080, "word_count": 134}
{"parent_id": "59978b3e-4a1a-4140-aafc-c83feb672fdd", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] \";// su dung stored procedure LichhocDAO ld = new LichhocDAO(); try{ CallableStatement cs = con.prepareCall(sqlDK); cs.setInt(1, idLHP); ResultSet rs = cs.executeQuery(); while(rs.next()){ if(kq == null) kq = new ArrayList<Dangkihoc>(); Dangkihoc dk = new Dangkihoc(); dk.setId(rs.getInt(\"id\")); //lop hoc phan Lophocphan lhp = new Lophocphan(); lhp.setId(idLHP); dk.setLophocphan(lhp); //sinhvien SinhvienKhoa sv = new SinhvienKhoa(); sv.setId(rs.getInt(\"idsinhvienkhoa\")); dk.setSinhvienKhoa(sv); //diem CallableStatement csDiem = con.prepareCall(sqlDiem); cs.setInt(1, dk.getId()); ResultSet rsDiem = csDiem.executeQuery(); while(rsDiem.next()){ Ketqua diem = new Ketqua(); if(rsDiem.getObject(\"idkq\")==null){//chua co diem diem.setId(-1); diem.setDiem(0); }else{ diem.setId(rsDiem.getInt(\"idkq\")); diem.setDiem(rsDiem.getFloat(\"diem\")); } //monhoc dau diem MonhocDaudiem mhdd = new MonhocDaudiem(); mhdd.setId(rsDiem.getInt(\"id\")); mhdd.setTiLe(rsDiem.getFloat(\"tile\")); //Daudiem Daudiem dd = new Daudiem(); dd.setId(rsDiem.getInt(\"iddd\")); dd.setTen(rsDiem.getString(\"tendd\")); mhdd.", "order_start": 1080, "order_end": 2169, "word_count": 98}
{"parent_id": "59978b3e-4a1a-4140-aafc-c83feb672fdd", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] etId(rsDiem.getInt(\"id\")); mhdd.setTiLe(rsDiem.getFloat(\"tile\")); //Daudiem Daudiem dd = new Daudiem(); dd.setId(rsDiem.getInt(\"iddd\")); dd.setTen(rsDiem.getString(\"tendd\")); mhdd.setDauDiem(dd); diem.setDiemTP(mhdd); dk.getDsDiemTP().add(diem); } kq.add(dk); } }catch(Exception e){ e.printStackTrace(); kq = null; } return kq; } /** * luu hoac cap nhat diem cua cac sinh vien trong lop hoc phan * @param listDiem danh sach diem cua sinh vien trong lop hoc phan * @return thanh cong hay co loi */ public boolean luuDiemcuaLHP(ArrayList<Dangkihoc> listDiem){ boolean kq = false; String sqlKiemtra = \"SELECT id FROM tblKetqua WHERE iddangkihoc = ? AND idmonhocdaudiem =?\"; String sqlThem = \"INSERT INTO tblKetqua(diem, ghichu, iddangkihoc, idmonhocdaudiem) VALUES(?,?,?,?)\"; String sqlSua = \"UPDATE tblKetqua SET diem=?, ghichu=? WHERE id=?\"; try{ this.con.setAutoCommit(false); for(Dangkihoc dk:listDiem){ for(Ketqua diem: dk.getDsDiemTP()){ PreparedStatement ps = eStatement(sqlKiemtra); ps.setInt(1, dk.getId()); ps.setInt(2, diem.getDiemTP().getId()); ResultSet rs = ps.executeQuery(); if(rs.", "order_start": 2169, "order_end": 3263, "word_count": 124}
{"parent_id": "59978b3e-4a1a-4140-aafc-c83feb672fdd", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] a diem: dk.getDsDiemTP()){ PreparedStatement ps = eStatement(sqlKiemtra); ps.setInt(1, dk.getId()); ps.setInt(2, diem.getDiemTP().getId()); ResultSet rs = ps.executeQuery(); if(rs.next()){// da ton tai, nen chi cap nhat PreparedStatement psSua = con.prepareStatement(sqlSua); psSua.setFloat(1, diem.getDiem()); psSua.setString(2, diem.getGhichu()); psSua.setInt(3, rs.getInt(\"id\")); psSua.executeUpdate(); }else{// chua ton tai nen them moi PreparedStatement psThem = con.prepareStatement(sqlThem); psThem.setFloat(1, diem.getDiem()); psThem.setString(2, diem.getGhichu()); psThem.setInt(3, dk.getId()); psThem.setInt(4, diem.getDiemTP().getId()); psThem.executeUpdate(); } } } this.con.commit(); kq=true; }catch(Exception e){ try{ this.con.rollback(); }catch(Exception ex){ kq=false; ex.printStackTrace(); } kq=false; e.printStackTrace(); }finally{ try{ this.con.setAutoCommit(true); }catch(Exception ex){ kq=false; ex.", "order_start": 3263, "order_end": 4183, "word_count": 77}
{"parent_id": "59978b3e-4a1a-4140-aafc-c83feb672fdd", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] .rollback(); }catch(Exception ex){ kq=false; ex.printStackTrace(); } kq=false; e.printStackTrace(); }finally{ try{ this.con.setAutoCommit(true); }catch(Exception ex){ kq=false; ex.printStackTrace(); } }", "order_start": 4183, "order_end": 4385, "word_count": 17}
{"parent_id": "d1a2ceda-8c49-4069-bc39-9a3c821b855f", "subject": "Phantichthietkehttt", "section": "Lớp KihocDAO.java", "title_path": "Lớp KihocDAO.java", "content": "[Phantichthietkehttt / Lớp KihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Hocki; import model.Kihoc; import model.Namhoc; public class KihocDAO extends DAO{ public KihocDAO() { super(); // TODO Auto-generated constructor stub } /** * lay tat ca cac ki da hoc va dang hoc de chon xem thong ke * @return danh sach cacs doi tuong kihoc */ public ArrayList<Kihoc> getTatcaKihoc(){ ArrayList<Kihoc> kq=null; String sql = \"{call tatcaKihoc()}\"; //su dung stored procedure", "order_start": 0, "order_end": 507, "word_count": 69}
{"parent_id": "71612b58-f4dc-4ea6-b615-40c80bf612bc", "subject": "Phantichthietkehttt", "section": "Lớp TKHoclucDAO.java", "title_path": "Lớp TKHoclucDAO.java", "content": "[Phantichthietkehttt / Lớp TKHoclucDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.TKLoaihocluc; public class TKHoclucDAO extends DAO{ public TKHoclucDAO() { super(); -- chuyen diem tu he 10 sang he 4 DROP TEMPORARY TABLE IF EXISTS diemsvmhhe4; CREATE TEMPORARY TABLE diemsvmhhe4 AS SELECT *, (SELECT diem FROM tblDiemhechu WHERE tbmon >= diemhe10toithieu AND tbmon < diemhe10toida) as tbmonhe4 FROM diemsvmh; -- bang tam tinh diem trung binh ca hoc ki cua sinh vien DROP TEMPORARY TABLE IF EXISTS diemsvhk; CREATE TEMPORARY TABLE diemsvhk AS SELECT idsinhvienkhoa, SUM(sotc) as tongtc, SUM(sotc*tbmonhe4)/SUM(sotc) as tbki FROM diemsvmhhe4 GROUP BY idsinhvienkhoa; -- tinh so luong DROP TEMPORARY TABLE IF EXISTS tksoluong; -- tinh diem trung binh DROP TEMPORARY TABLE IF EXISTS tkdiemtb; CREATE TEMPORARY TABLE tkdiemtb AS SELECT a.id, (SELECT AVG(tbki) FROM diemsvhk WHERE tbki>=a.diemtoithieu AND tbki < a.diemtoida) as tb FROM tblloaihocluc a; -- tlay ket qua day du SELECT a.*, b.soluong, c.tb FROM tblloaihocluc a, tksoluong b, tkdiemtb c WHERE b.id=a.", "order_start": 0, "order_end": 1092, "word_count": 156}
{"parent_id": "71612b58-f4dc-4ea6-b615-40c80bf612bc", "subject": "Phantichthietkehttt", "section": "Lớp TKHoclucDAO.java", "title_path": "Lớp TKHoclucDAO.java", "content": "[Phantichthietkehttt / Lớp TKHoclucDAO.java] i>=a.diemtoithieu AND tbki < a.diemtoida) as tb FROM tblloaihocluc a; -- tlay ket qua day du SELECT a.*, b.soluong, c.tb FROM tblloaihocluc a, tksoluong b, tkdiemtb c WHERE b.id=a.id AND c.id=a.id;", "order_start": 1092, "order_end": 1289, "word_count": 31}
{"parent_id": "8673d4ed-b4f3-4f13-a470-e2d1d8e12a44", "subject": "Phantichthietkehttt", "section": "Lớp TKSinhvienDAO.java", "title_path": "Lớp TKSinhvienDAO.java", "content": "[Phantichthietkehttt / Lớp TKSinhvienDAO.java] package dao; import java.sql.CallableStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Hoten; import model.Khoa; import model.Sinhvien; import model.TKSinhvien; tblKhoa d, diemsvhk e WHERE c.id = e.idsinhvienkhoa AND a.id = c.idsinhvien AND b.idthanhvien = a.id AND d.id= c.idkhoa; END", "order_start": 0, "order_end": 314, "word_count": 36}
{"parent_id": "31103ddf-8e6f-489d-93cd-98b1411a08a2", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] package dao; import java.sql.CallableStatement; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import model.Dangkihoc; import model.Daudiem; import model.Hoten; import model.Ketqua; import model.Khoa; import model.Kihoc; import model.Lophocphan; import model.Monhoc; import model.MonhocDaudiem; import model.MonhocKihoc; import model.Sinhvien; import model.SinhvienKhoa; public class DangkihocDAO extends DAO{ public DangkihocDAO() { super(); // TODO Auto-generated constructor stub } /** * lay diem trung binh cua tat ca cac mon cua sinh vien @idSVK trong hoc ki * @param idSVK ma sinh vien khoa * @param idKihoc ma ki hoc * @return danh sach doi tuong Dangkihoc */ public ArrayList<Dangkihoc> getDiemSVtheoHK(int idSVK, int idKihoc){ ArrayList<Dangkihoc> kq = null; String sqlDK = \"{call DKcuaSVtheoKi(?,?)}\";// su dung stored procedure String sqlDiem = \"{call DiemcuaDK(?)}\";// su dung stored procedure LichhocDAO ld = new LichhocDAO(); try{ CallableStatement cs = con.prepareCall(sqlDK); cs.setInt(1, idSVK); cs.setInt(2, idKihoc); ResultSet rs = cs.", "order_start": 0, "order_end": 1097, "word_count": 134}
{"parent_id": "31103ddf-8e6f-489d-93cd-98b1411a08a2", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] )}\";// su dung stored procedure LichhocDAO ld = new LichhocDAO(); try{ CallableStatement cs = con.prepareCall(sqlDK); cs.setInt(1, idSVK); cs.setInt(2, idKihoc); ResultSet rs = cs.executeQuery(); while(rs.next()){ if(kq == null) kq = new ArrayList<Dangkihoc>(); Dangkihoc dk = new Dangkihoc(); dk.setId(rs.getInt(\"id\")); //lop hoc phan Lophocphan lhp = new Lophocphan(); lhp.setId(rs.getInt(\"idlhp\")); dk.setLophocphan(lhp); //sinhvienkhoa SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(rs.getInt(\"idsinhvienkhoa\")); svk.setNienkhoa(rs.getString(\"nienkhoa\")); //sinhvien Sinhvien sv = new Sinhvien(); sv.setId(rs.getInt(\"idsinhvien\")); sv.setMasv(rs.getString(\"masv\")); //Hoten Hoten hoten = new Hoten(); hoten.setHodem(rs.getString(\"hodem\")); hoten.setTen(rs.getString(\"tensv\")); sv.setHoten(hoten); svk.setSinhvien(sv); dk.", "order_start": 1097, "order_end": 1924, "word_count": 74}
{"parent_id": "31103ddf-8e6f-489d-93cd-98b1411a08a2", "subject": "Phantichthietkehttt", "section": "Lớp DangkihocDAO.java", "title_path": "Lớp DangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp DangkihocDAO.java] v(rs.getString(\"masv\")); //Hoten Hoten hoten = new Hoten(); hoten.setHodem(rs.getString(\"hodem\")); hoten.setTen(rs.getString(\"tensv\")); sv.setHoten(hoten); svk.setSinhvien(sv); dk.setSinhvienKhoa(svk);", "order_start": 1924, "order_end": 2125, "word_count": 12}
{"parent_id": "662e7c4a-674e-41b1-af5a-61e45c9635cd", "subject": "Phantichthietkehttt", "section": "//diem", "title_path": "//diem", "content": "[Phantichthietkehttt / //diem] CallableStatement csDiem = con.prepareCall(sqlDiem); cs.setInt(1, dk.getId()); ResultSet rsDiem = csDiem.executeQuery(); while(rsDiem.next()){ Ketqua diem = new Ketqua(); if(rsDiem.getObject(\"idkq\")==null){//chua co diem diem.setId(-1); diem.setDiem(0); }else{ diem.setId(rsDiem.getInt(\"idkq\")); diem.setDiem(rsDiem.getFloat(\"diem\")); } //monhoc dau diem MonhocDaudiem mhdd = new MonhocDaudiem(); mhdd.setId(rsDiem.getInt(\"id\")); mhdd.setTiLe(rsDiem.getFloat(\"tile\")); //Daudiem Daudiem dd = new Daudiem(); dd.setId(rsDiem.getInt(\"iddd\")); dd.setTen(rsDiem.getString(\"tendd\")); mhdd.setDauDiem(dd); diem.setDiemTP(mhdd);", "order_start": 0, "order_end": 620, "word_count": 45}
{"parent_id": "7e4e554c-ee67-4fba-af99-b213c63263a0", "subject": "Phantichthietkehttt", "section": "5.3 KIỂM THỬ ĐƠN VỊ", "title_path": "5.3 KIỂM THỬ ĐƠN VỊ", "content": "[Phantichthietkehttt / 5.3 KIỂM THỬ ĐƠN VỊ] Nội dung phần này sẽ trình bày kế hoạch kiểm thử đơn vị, các ca kiểm thử đơn vị cho lớp DangkihocDAO. Kế hoạch kiểm thử và các ca kiểm thử cho các lớp DAO còn lại coi như là bài tập cho người đọc.", "order_start": 0, "order_end": 196, "word_count": 45}
{"parent_id": "9afcb65e-cb9e-4bd8-adb9-cf2c2bab5217", "subject": "Phantichthietkehttt", "section": "5.3.Xây dựng bộ test case cho kiểm thử đơn vị", "title_path": "5.3.Xây dựng bộ test case cho kiểm thử đơn vị", "content": "[Phantichthietkehttt / 5.3.Xây dựng bộ test case cho kiểm thử đơn vị] Bộ test case cho kiểm thử đơn vị được xây dựng theo bảng sau:", "order_start": 0, "order_end": 61, "word_count": 14}
{"parent_id": "6e05c64a-41f5-438e-8b10-ffb7654ff6c9", "subject": "Phantichthietkehttt", "section": "5.3.2 Cài đặt kiểm thử đơn vị", "title_path": "5.3.2 Cài đặt kiểm thử đơn vị", "content": "[Phantichthietkehttt / 5.3.2 Cài đặt kiểm thử đơn vị] Việc thực hiện test đơn vị sẽ sử dụng Junit. Ngoại trừ các class interface, các class còn lại cần được thực hiện unit test. Mục tiêu của unit test là để đảm bảo từng unit (method, class) thực hiện đúng như trong thiết kế. Quy trình tiến hành các bước như sau: Bước 1: Với mỗi method/class, xây dựng test cases với lưu ý lựa chọn các input sao cho đạt mức phủ cấp 2 (phủ hết các nhánh trong source code), expected output thì cần căn cứ vào thiết kế, đặc tả để xác định, không căn cứ vào source code. Bước 2: Viết script Junit ◦ Với mỗi test cases, khai báo biến để lưu input/expected result ◦ Gọi method cần test với test input ở trên. ◦ Kiểm tra kết quả thực method với expected output ◦ Kiểm tra DB xem đã thay đổi như mong muốn chưa? • Bước 3: Báo cáo kết quả test, số lượng pass/false và mô tả chi tiết trường hợp false. Lưu ý là cần thực hiện chuẩn bị môi trường (kết nối DB, dữ liệu mẫu) và cần Rollback sau khi thực hiện test để đảm bảo việc thực hiện các test cases khác, và sau này test lại sẽ không bi lỗi. .", "order_start": 0, "order_end": 1017, "word_count": 215}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] package unittest; import java.util.ArrayList; import junit.framework.Assert; import model.Dangkihoc; import model.Kihoc; import model.Lophocphan; import model.MonhocKihoc; import model.SinhvienKhoa; import org.junit.Test; import dao.DAO; import dao.DangkihocDAO; public void getDKcuaSV_testChuan1(){ // sinh vien da dang ki dung 1 LHP int idSVK = 2; int idKihoc = 4; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.assertNotNull(listDK); Assert.assertEquals(1, listDK.size()); Assert.assertEquals(idSVK, listDK.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(idKihoc, listDK.get(0).getLophocphan().getMonhocKihoc().getKihoc().getId()); } @Test public void getDKcuaSV_testChuan2(){ // sinh vien dang ki nhieu hon 1 LHP int idSVK = 1; int idKihoc = 4; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.assertNotNull(listDK); Assert.assertEquals(3, listDK.size()); for(int i=0; i<listDK.size(); i++){ Assert.assertEquals(idSVK, listDK.get(i).getSinhvienKhoa().getId()); Assert.assertEquals(idKihoc, listDK.get(i).getLophocphan().getMonhocKihoc().", "order_start": 0, "order_end": 1096, "word_count": 92}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] or(int i=0; i<listDK.size(); i++){ Assert.assertEquals(idSVK, listDK.get(i).getSinhvienKhoa().getId()); Assert.assertEquals(idKihoc, listDK.get(i).getLophocphan().getMonhocKihoc().getKihoc().getId()); } } @Test public void getDKcuaSV_testNgoaile1(){ //ki hoc ton tai, SV khong ton tai int idSVK = 1000; int idKihoc = 4; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.assertNull(listDK); } @Test public void getDKcuaSV_testNgoaile2(){ //ki hoc khong ton tai, SV ton tai int idSVK = 1; int idKihoc = 1000; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.assertNull(listDK); } @Test public void getDKcuaSV_testNgoaile3(){ //ki hoc khong ton tai, SV khong ton tai int idSVK = 1000; int idKihoc = 1000; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.assertNull(listDK); } @Test public void getDKcuaSV_testNgoaile4(){ //SV co dang ki o ki hoc khac, khong co dang ki o ki hoc nay int idSVK = 1; int idKihoc = 5; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.", "order_start": 1096, "order_end": 2147, "word_count": 126}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] estNgoaile4(){ //SV co dang ki o ki hoc khac, khong co dang ki o ki hoc nay int idSVK = 1; int idKihoc = 5; ArrayList<Dangkihoc> listDK = dkhdao.getDKcuaSV(idSVK, idKihoc); Assert.assertNull(listDK); } @Test public void luuDKcuaSV_testChuan1(){ //dang ki 1LHP, chua co dang ki cu ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(3); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(1); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(3); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk); try{ DAO.con.setAutoCommit(false); boolean ok = dkhdao.luuDKcuaSV(listDK); Assert.assertTrue(ok); //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(1, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).", "order_start": 2147, "order_end": 3241, "word_count": 112}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] stDKnew); Assert.assertEquals(1, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } @Test public void luuDKcuaSV_testChuan2(){ //dang ki nhieu LHP, chua co dang ki cu ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(3); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(1); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(3); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk); //tao dang ki hoc thu hai MonhocKihoc mhkh2 = new MonhocKihoc(); mhkh2.setId(2); mhkh2.setKihoc(kh); Lophocphan lhp2 = new Lophocphan(); lhp2.setId(9); lhp2.setMonhocKihoc(mhkh2); Dangkihoc dk2 = new Dangkihoc(); dk2.", "order_start": 3241, "order_end": 4321, "word_count": 104}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] mhkh2 = new MonhocKihoc(); mhkh2.setId(2); mhkh2.setKihoc(kh); Lophocphan lhp2 = new Lophocphan(); lhp2.setId(9); lhp2.setMonhocKihoc(mhkh2); Dangkihoc dk2 = new Dangkihoc(); dk2.setSinhvienKhoa(svk); dk2.setLophocphan(lhp2); listDK.add(dk2); try{ DAO.con.setAutoCommit(false); boolean ok = dkhdao.luuDKcuaSV(listDK); Assert.assertTrue(ok); //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(2, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); Assert.assertEquals(svk.getId(), listDKnew.get(1).getSinhvienKhoa().getId()); Assert.assertEquals(lhp2.getId(), listDKnew.get(1).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.", "order_start": 4321, "order_end": 5272, "word_count": 58}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] Id(), listDKnew.get(1).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } @Test public void luuDKcuaSV_testChuan3(){ // dang ki 1LHP, cung MH voi dang ki cu, dang ki cu cung chi co 1LHP ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(2); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(4); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(27); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk); try{ DAO.con.setAutoCommit(false); boolean ok = dkhdao.luuDKcuaSV(listDK); Assert.assertTrue(ok); //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(1, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.", "order_start": 5272, "order_end": 6361, "word_count": 103}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] tId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(1, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } @Test public void luuDKcuaSV_testChuan4(){ // dang ki 1LHP, khac MH voi dang ki cu, dang ki cu cung chi co 1LHP ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(2); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(2); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(10); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.", "order_start": 6361, "order_end": 7288, "word_count": 88}
{"parent_id": "5c4e5f1e-f396-4812-90dd-86a97398e6c0", "subject": "Phantichthietkehttt", "section": "Lớp TestDangkihocDAO.java", "title_path": "Lớp TestDangkihocDAO.java", "content": "[Phantichthietkehttt / Lớp TestDangkihocDAO.java] kh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(10); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk);", "order_start": 7288, "order_end": 7476, "word_count": 16}
{"parent_id": "c5d3ecb7-46ec-495d-9738-bbdf17637f6d", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(1, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } @Test public void luuDKcuaSV_testChuan5(){ // dang ki > 1LHP, dang ki cu it LHP hon ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(2); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(1); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(3); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk); //tao dang ki hoc thu hai MonhocKihoc mhkh2 = new MonhocKihoc(); mhkh2.setId(2); mhkh2.", "order_start": 0, "order_end": 1069, "word_count": 102}
{"parent_id": "c5d3ecb7-46ec-495d-9738-bbdf17637f6d", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] gkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk); //tao dang ki hoc thu hai MonhocKihoc mhkh2 = new MonhocKihoc(); mhkh2.setId(2); mhkh2.setKihoc(kh); Lophocphan lhp2 = new Lophocphan(); lhp2.setId(9); lhp2.setMonhocKihoc(mhkh2); Dangkihoc dk2 = new Dangkihoc(); dk2.setSinhvienKhoa(svk); dk2.setLophocphan(lhp2); listDK.add(dk2);", "order_start": 1069, "order_end": 1442, "word_count": 36}
{"parent_id": "3365150f-deb7-4e12-a8fe-4d0d6fd1f18c", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(2, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); Assert.assertEquals(svk.getId(), listDKnew.get(1).getSinhvienKhoa().getId()); Assert.assertEquals(lhp2.getId(), listDKnew.get(1).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } @Test public void luuDKcuaSV_testChuan6(){ // dang ki > 1LHP, dang ki cu nhieu LHP hon ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(1); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(1); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(3); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.", "order_start": 0, "order_end": 1079, "word_count": 91}
{"parent_id": "3365150f-deb7-4e12-a8fe-4d0d6fd1f18c", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] nhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(1); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(3); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk); //tao dang ki hoc thu hai MonhocKihoc mhkh2 = new MonhocKihoc(); mhkh2.setId(2); mhkh2.setKihoc(kh); Lophocphan lhp2 = new Lophocphan(); lhp2.setId(9); lhp2.setMonhocKihoc(mhkh2); Dangkihoc dk2 = new Dangkihoc(); dk2.setSinhvienKhoa(svk); dk2.setLophocphan(lhp2); listDK.add(dk2);", "order_start": 1079, "order_end": 1600, "word_count": 50}
{"parent_id": "b19e9639-7169-4953-8c73-20542c72f065", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] DAO.con.setAutoCommit(false); boolean ok = dkhdao.luuDKcuaSV(listDK); Assert.assertTrue(ok); //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(2, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); Assert.assertEquals(svk.getId(), listDKnew.get(1).getSinhvienKhoa().getId()); Assert.assertEquals(lhp2.getId(), listDKnew.get(1).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } @Test public void luuDKcuaSV_testNgoaile1(){ //dang ki moi trung hoan toan voi dang ki cu ArrayList<Dangkihoc> listDK = new ArrayList<Dangkihoc>(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(2); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(4); mhkh.", "order_start": 0, "order_end": 1049, "word_count": 82}
{"parent_id": "b19e9639-7169-4953-8c73-20542c72f065", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] >(); //tao dang ki hoc thu nhat SinhvienKhoa svk = new SinhvienKhoa(); svk.setId(2); Kihoc kh = new Kihoc(); kh.setId(4); MonhocKihoc mhkh = new MonhocKihoc(); mhkh.setId(4); mhkh.setKihoc(kh); Lophocphan lhp = new Lophocphan(); lhp.setId(28); lhp.setMonhocKihoc(mhkh); Dangkihoc dk = new Dangkihoc(); dk.setSinhvienKhoa(svk); dk.setLophocphan(lhp); listDK.add(dk);", "order_start": 1049, "order_end": 1414, "word_count": 41}
{"parent_id": "6d3f0adf-7424-4ac3-aac9-56f041716e0b", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] DAO.con.setAutoCommit(false); boolean ok = dkhdao.luuDKcuaSV(listDK); Assert.assertTrue(ok); //lay ra kiem tra ArrayList<Dangkihoc> listDKnew = dkhdao.getDKcuaSV(svk.getId(), kh.getId()); Assert.assertNotNull(listDKnew); Assert.assertEquals(1, listDKnew.size()); Assert.assertEquals(svk.getId(), listDKnew.get(0).getSinhvienKhoa().getId()); Assert.assertEquals(lhp.getId(), listDKnew.get(0).getLophocphan().getId()); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } @Test public void luuDKcuaSV_testNgoaile2(){ //dang ki moi khong co LHP nao ArrayList<Dangkihoc> listDK = null; try{ DAO.con.setAutoCommit(false); boolean ok = dkhdao.luuDKcuaSV(listDK); Assert.assertFalse(ok); //test 2 listDK = new ArrayList<Dangkihoc>(); ok = dkhdao.luuDKcuaSV(listDK); Assert.assertFalse(ok); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.", "order_start": 0, "order_end": 1017, "word_count": 77}
{"parent_id": "6d3f0adf-7424-4ac3-aac9-56f041716e0b", "subject": "Phantichthietkehttt", "section": "try{", "title_path": "try{", "content": "[Phantichthietkehttt / try{] hdao.luuDKcuaSV(listDK); Assert.assertFalse(ok); }catch(Exception e){ e.printStackTrace(); }finally{ try{ DAO.con.rollback(); DAO.con.setAutoCommit(true); }catch(Exception ex){ ex.printStackTrace(); } } } }", "order_start": 1017, "order_end": 1223, "word_count": 16}
{"parent_id": "f7195639-4f43-428d-9429-e0284802ee88", "subject": "Phantichthietkehttt", "section": "5.4 CÂU HỎI ÔN TẬP", "title_path": "5.4 CÂU HỎI ÔN TẬP", "content": "[Phantichthietkehttt / 5.4 CÂU HỎI ÔN TẬP] 1. Hoàn thiện các phần giao diện cho 2 modul còn lại 2. Bổ sung các modul chức năng khác vào hệ thống", "order_start": 0, "order_end": 101, "word_count": 23}
{"parent_id": "4b7bdb0e-5943-476b-93e0-32edf784d719", "subject": "Phantichthietkehttt", "section": "6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT", "title_path": "6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT", "content": "[Phantichthietkehttt / 6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT] Việc thực hiện rà soát sẽ đảm bảo các tài liệu (đặc tả, phân tích, thiết kế…) không bị sai sót. Thông thường, chúng ta sẽ rà soát dựa trên các checklist tương ứng. Quy trình tiến hành các bước như sau: • Bước 1: Lựa chọn và xây dựng checklist phù hợp với loại rà soát. • Bước 2: Thực hiện rà soát theo các câu hỏi trong checklist, trường hợp có lỗi, có vấn đề cần mô tả rõ lỗi và yêu cầu chỉnh sửa. Các phần tiếp theo giới thiệu các checklist tiêu biểu cho đặc tả, phân tích, thiết kế. Một lưu ý khác là phần tài liệu đặc tả, phân tích, thiết kế về case study Hệ thống quản lí đăng kí tín chỉ tập trung vào các yêu cầu chức năng, kĩ thuật của hệ thống mà chưa đề cập tới các yêu cầu phi chức năng, thủ tục… vì vậy việc rà soát cũng sẽ tạm bỏ qua yêu cầu phi chức năng. Bên cạnh đó, nhằm cung cấp cho người học các checklist thông dụng và áp dụng được cho nhiều dự án, vì vậy có một số câu hỏi sẽ không cần thiết hoặc không liên quan tới Hệ thống quản lí đăng kí tín chỉ. Do vậy, một số câu hỏi trong checklist sẽ có trả lời là NA.", "order_start": 0, "order_end": 1030, "word_count": 229}
{"parent_id": "4b7bdb0e-5943-476b-93e0-32edf784d719", "subject": "Phantichthietkehttt", "section": "6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT", "title_path": "6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT", "content": "[Phantichthietkehttt / 6.1 THỰC HIỆN CÁC HOẠT ĐỘNG RÀ SOÁT] cho nhiều dự án, vì vậy có một số câu hỏi sẽ không cần thiết hoặc không liên quan tới Hệ thống quản lí đăng kí tín chỉ. Do vậy, một số câu hỏi trong checklist sẽ có trả lời là NA. Lưu ý cột Y/N/NA là kết quả rà soát tương ứng với Y (không có lỗi), N (có lỗi), NA (không liên quan tới hệ thống hoặc không xác định).", "order_start": 1030, "order_end": 1344, "word_count": 72}
{"parent_id": "dff70ac7-c269-40ff-8dc7-04f03e2ce468", "subject": "Phantichthietkehttt", "section": "6.1.1 Rà soát đặc tả", "title_path": "6.1.1 Rà soát đặc tả", "content": "[Phantichthietkehttt / 6.1.1 Rà soát đặc tả] Để rà soát đặc tả, ta sử dụng checklist sau. Bên cạnh đó, một số vấn đề và câu hỏi chi tiết liên quan tới chức năng của hệ thống cần trao đổi như sau: 1. Tổng số tín chỉ được đăng kí có ngưỡng giá trị tối đa/tối thiểu là bao nhiêu? Có cần thiết lập không? 2. Các môn học đã học ở kỳ trước, các môn có thể cải thiện, các môn phải học lại...có được chú thích hay không? 3. Một sinh viên học 2 khoa, có một số môn học trùng thì bảng đăng kí hiển thị như nào? Đã xử lý chưa? 4. Việc thực hiện mở chế độ đăng ký cho sinh viên vào đăng ký như nào? Có cần chức năng riêng không? 5. Có yêu cầu về thiết kế giao diện ( màu nền, bố cục, phông chữ, cỡ chữ...) không?", "order_start": 0, "order_end": 655, "word_count": 150}
{"parent_id": "8c49278a-59db-4636-b83b-4dfed0f56f6d", "subject": "Phantichthietkehttt", "section": "6.1.2 Rà soát phân tích", "title_path": "6.1.2 Rà soát phân tích", "content": "[Phantichthietkehttt / 6.1.2 Rà soát phân tích] Phần này giới thiệu một checklist mẫu có thể dùng để rà soát tài liệu phân tích. Việc rà soát cần thực hiện với toàn tài liệu phân tích, 2 ví dụ dưới đây minh hoạ cách rà soát và phát hiện các vấn đề trong pha phân tích.", "order_start": 0, "order_end": 220, "word_count": 49}
{"parent_id": "ee2646df-aaf5-4287-9635-dd0d78240a19", "subject": "Phantichthietkehttt", "section": "Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:", "title_path": "Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:", "content": "[Phantichthietkehttt / Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:] 6. Giao diện các lớp học phần hiện ra: Với kịch bản như trên, một số vấn đề và câu hỏi chi tiết liên quan tới chức năng của hệ thống cần trao đổi như sau: - chưa thực hiện chọn ngành học (nhất là trường hợp học 2 ngành) , cần bổ sung các ngoại lệ liên quan tới học nhiều ngành, đăng kí ít/nhiều hơn số tín chỉ cho phép, học lại, học nâng điểm trường hợp 1 lớp học phần học vào nhiều buổi, mỗi buổi liên quan đến 1 tuần khác nhau, 1 ngày khác nhau, 1 kíp khác nhau, 1 phòng khác nhau, 1 giảng viên khác nhau thì hiển thị giao diện Chọn lớp học phần hiển thị thế nào? Kịch chính bản 2. Giao diện chọn môn học hiện lên: có ô chọn kì học đang active nhưng chưa chọn kì nào, danh sách các môn học do giảng viện dạy trong kì tương ứng đang trống. 3. Giàng viên chọn kì 2, năm học 2020-2021 4. Vẫn giao diện chọn môn học: danh sách các môn học do giảng viên dạy kì tương ứng được cập nhật: 5. Giảng viên click chọn môn Lập trình hướng đối tượng. 6. Giao diện các lớp học phần do giảng viên dạy hiện lên: 7. Giảng viên click vào nhóm số 1 8.", "order_start": 0, "order_end": 1033, "word_count": 228}
{"parent_id": "ee2646df-aaf5-4287-9635-dd0d78240a19", "subject": "Phantichthietkehttt", "section": "Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:", "title_path": "Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:", "content": "[Phantichthietkehttt / Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:] y kì tương ứng được cập nhật: 5. Giảng viên click chọn môn Lập trình hướng đối tượng. 6. Giao diện các lớp học phần do giảng viên dạy hiện lên: 7. Giảng viên click vào nhóm số 1 8. Giao diện nhập điểm chi tiết cho nhóm số 1 hiện lên: có thông tin nhóm số 1, môn học lập trình hướng đối tượng, và danh sách điểm sinh viên, dưới cùng là nút lưu: 9. Giảng viên nhập đầu điểm thi: A: 5, C:6, D:7, S:8, V:9 và click lưu 10. Hệ thống báo thành công và quay về giao diện chính của giảng viên. Với kịch bản như trên, một số vấn đề và câu hỏi chi tiết liên quan tới chức năng của hệ thống cần trao đổi như sau: trường hợp có 2 giáo viên cùng dạy 1 môn, có cần kiểm soát ai là người nhập điểm không? Bổ sung ngoại lệ liên quan tới việc nhập điểm chưa hết danh sách lớp, nhập điểm sai định dạng (<0, >10, nhập chữ…), 2 giáo viên cùng dạy, trường hợp xin hoãn học.", "order_start": 1033, "order_end": 1885, "word_count": 188}
{"parent_id": "ee2646df-aaf5-4287-9635-dd0d78240a19", "subject": "Phantichthietkehttt", "section": "Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:", "title_path": "Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:", "content": "[Phantichthietkehttt / Ví dụ 1: với kịch bản cho modul đăng ký học được viết như sau:] nhập điểm không? Bổ sung ngoại lệ liên quan tới việc nhập điểm chưa hết danh sách lớp, nhập điểm sai định dạng (<0, >10, nhập chữ…), 2 giáo viên cùng dạy, trường hợp xin hoãn học. trường hợp 1 lớp học phần học vào nhiều buổi, mỗi buổi liên quan đến 1 tuần khác nhau, 1 ngày khác nhau, 1 kíp khác nhau, 1 phòng khác nhau, 1 giảng viên khác nhau thì hiển thị giao diện Chọn Lớp học phần hiển thị như thế nào? Nên bổ sung chức năng confirm cho nhập điểm hoặc giới hạn thời gian nhập điểm để đảm bảo giáo viên không chỉnh sửa điểm của các môn ở kì trước.", "order_start": 1885, "order_end": 2435, "word_count": 118}
{"parent_id": "a69a22d9-47a1-4064-9168-9677df233a48", "subject": "Phantichthietkehttt", "section": "6.1.3 Rà soát thiết kế", "title_path": "6.1.3 Rà soát thiết kế", "content": "[Phantichthietkehttt / 6.1.3 Rà soát thiết kế] Để rà soát tài liệu thiết kế, chúng ta sử dụng checklist sau Việc rà soát cần thực hiện với toàn tài liệu thiết kế, 2 ví dụ dưới đây minh hoạ cách rà soát và phát hiện các vấn đề trong pha thiết kế. Ví dụ 1: trường hợp giao diện cho module đăng ký học được thiết kế như dưới đây Một số vấn đề và câu hỏi chi tiết cần trao đổi như sau: 1. Thiết kế giao diện Đăng kí học: So với đặc tả, thiếu: chọn thông tin kì học muốn đăng kí, cột sĩ số tối đa, cột sĩ số hiện tại. Nên bổ sung button đóng màn hình hoặc quay về màn hình chính. 2. Thiết kế giao diện Chọn môn học: So với đặc tả, thiếu cột mô tả. Nên bổ sung button đóng màn hình hoặc quay về màn hình chính. 3. Thiết kế Giao diện Chọn lớp học phần: So với đặc tả, thiếu cột sĩ số tôi đa, sĩ số hiện tại. Nên bổ sung button đóng màn hình hoặc quay về màn hình chính. 4. Thiết kế giao diện Chọn môn học: so với đặc tả, thiếu thông tin chọn học kì, thiếu cột mô tả. Nên bổ sung button đóng màn hình hoặc quay về màn hình chính. 5. Thiết kế giao diện Chọn lớp học phần: so với đặc tả, thiếu cột sĩ số thực, phòng học, ngày học, kíp học.", "order_start": 0, "order_end": 1082, "word_count": 245}
{"parent_id": "a69a22d9-47a1-4064-9168-9677df233a48", "subject": "Phantichthietkehttt", "section": "6.1.3 Rà soát thiết kế", "title_path": "6.1.3 Rà soát thiết kế", "content": "[Phantichthietkehttt / 6.1.3 Rà soát thiết kế] cột mô tả. Nên bổ sung button đóng màn hình hoặc quay về màn hình chính. 5. Thiết kế giao diện Chọn lớp học phần: so với đặc tả, thiếu cột sĩ số thực, phòng học, ngày học, kíp học. Nên bổ sung button đóng màn hình hoặc quay về màn hình chính, bổ sung thông tin về môn học. Ví dụ 2: trường hợp giao diện modul nhập điểm được thiết kế như dưới đây Với thiết kế như trên, một số vấn đề cần trao đổi như sau: 1. Thiết kế giao diện Nhập điểm: o Nên bổ sung button đóng màn hình hoặc quay về màn hình chính, bổ sung thông tin học kì. o Nút “Tái thiết lập” chưa được mô tả về chức năng, tái thiết lập lại toàn bộ về chưa nhập hay chỉ những sinh viên vừa nhập ở lần này? 2. Thiết kế giao diện Điểm môn học của sinh viên: so với phân tích, thiếu dòng TB Môn, Điểm chữ, Điểm hệ 4.", "order_start": 1082, "order_end": 1852, "word_count": 172}
{"parent_id": "acc2c9fd-7368-4815-9775-367fcc69cd7a", "subject": "Phantichthietkehttt", "section": "6.1.4 Rà soát code", "title_path": "6.1.4 Rà soát code", "content": "[Phantichthietkehttt / 6.1.4 Rà soát code] Bảng dưới là một Checklist code mẫu sử dụng khi rà soát code.", "order_start": 0, "order_end": 61, "word_count": 13}
{"parent_id": "2afcad70-6091-48bc-acce-3a0e1d707d66", "subject": "Phantichthietkehttt", "section": "6.2. THỰC HIỆN TEST CHỨC NĂNG", "title_path": "6.2. THỰC HIỆN TEST CHỨC NĂNG", "content": "[Phantichthietkehttt / 6.2. THỰC HIỆN TEST CHỨC NĂNG] Việc thực hiện test chức năng nhằm đảm bảo các chức năng của hệ thống hoạt động theo đúng yêu cầu của đặc tả. Quy trình tiến hành các bước như sau: • Bước 1: Xây dựng checklist các nội dung cần test cho từng chức năng (tuỳ chọn). • Bước 2: Thực hiện viết test cases ◦ GUI (giao diện) ◦ chức năng ◦ luồng, nghiệp vụ ◦ khác • Bước 3: Thực hiện chuẩn bị data test (nếu cần) Bước 4: thực hiện test và ghi nhận kết quả pass/false. Trường hợp false cần mô tả rõ lỗi và trao đổi với Lập trình viên để sửa. Ta áp dụng với hệ thống Quản lí đăng kí tín chỉ với các bước 1,2,3. Riêng Bước 4, ta cần có hệ thống chạy được thì mới thực hiện được. Các nội dung chính của Test case bao gồm mô tả input (mục đích kiểm thử, các bước thực hiện, test data) và kết quả mong muốn. Một lưu ý là một số test cases bên dưới không yêu data test (ví dụ: test giao diện, test hành động…), nhưng một số test case cần có data test (ví dụ: test case về chức năng…). Bản test case bên dưới đã mô tả các ràng buộc về data test ở cột Các bước thực hiện (Bảng 6.7…).", "order_start": 0, "order_end": 1032, "word_count": 227}
{"parent_id": "2afcad70-6091-48bc-acce-3a0e1d707d66", "subject": "Phantichthietkehttt", "section": "6.2. THỰC HIỆN TEST CHỨC NĂNG", "title_path": "6.2. THỰC HIỆN TEST CHỨC NĂNG", "content": "[Phantichthietkehttt / 6.2. THỰC HIỆN TEST CHỨC NĂNG] h động…), nhưng một số test case cần có data test (ví dụ: test case về chức năng…). Bản test case bên dưới đã mô tả các ràng buộc về data test ở cột Các bước thực hiện (Bảng 6.7…). Trong phạm vi case study ở tài liệu này, các ràng buộc khá đơn giản, việc xây dựng test data cụ thể có thể dễ dàng thực hiện theo mô tả ở Cột các bước thực hiện. Vì vậy, bảng Test case bên dưới sẽ không trình bày chi tiết test data, dành cho người học tự thực hiện.", "order_start": 1032, "order_end": 1478, "word_count": 99}
{"parent_id": "02b171ce-5f04-4954-b58d-ce243b0ed449", "subject": "Phantichthietkehttt", "section": "Module Đăng kí tín chỉ:", "title_path": "Module Đăng kí tín chỉ:", "content": "[Phantichthietkehttt / Module Đăng kí tín chỉ:] Bảng 6. 7: Hướng dẫn xây dựng Test case chức năng cho module Đăng kí tín chỉ", "order_start": 0, "order_end": 76, "word_count": 17}
{"parent_id": "e9e25a6c-1014-4cae-8817-e81864f4c81b", "subject": "Phantichthietkehttt", "section": "Yêu cầu xây dựng test data cho chức năng thông kê:", "title_path": "Yêu cầu xây dựng test data cho chức năng thông kê:", "content": "[Phantichthietkehttt / Yêu cầu xây dựng test data cho chức năng thông kê:] Do chức năng thống kê cần có dữ liệu đầy đủ trong các bảng thì mới thống kê được, do vậy việc xây dựng test data cho chức năng thống kê là quan trọng và cần thiết để phủ hết các tình huống xảy ra. Ví dụ về yêu cầu xây dựng test data cho chức năng thống kê:", "order_start": 0, "order_end": 256, "word_count": 59}
{"parent_id": "dcc6edc2-bbdf-474b-a4b2-28820bcafe8a", "subject": "Phantichthietkehttt", "section": "6.3 CÂU HỎI ÔN TẬP", "title_path": "6.3 CÂU HỎI ÔN TẬP", "content": "[Phantichthietkehttt / 6.3 CÂU HỎI ÔN TẬP] 1. Thực hiện các hoạt động rà soát cho module 2. Thực hiện test chức năng cho module", "order_start": 0, "order_end": 84, "word_count": 18}
{"parent_id": "fd213986-b121-4fd1-8d35-8fe02c666f52", "subject": "tutuonghcm", "section": "Đề ôn tập Tư Tưởng HCM", "title_path": "Đề ôn tập Tư Tưởng HCM", "content": "[tutuonghcm / Đề ôn tập Tư Tưởng HCM] Tư Tưởng Hồ Chí Minh (Học viện Công nghệ Bưu chính Viễn thông)", "order_start": 0, "order_end": 62, "word_count": 13}
{"parent_id": "06a1982f-b74b-416d-ba16-8e8a9a42406f", "subject": "tutuonghcm", "section": "Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.", "title_path": "Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.", "content": "[tutuonghcm / Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.] Khái niệm: “Tư tưởng Hồ Chí Minh là một hệ thống quan điểm toàn diện và sâu sắc về những vấn đề cơ bản của cách mạng Việt Nam, kết quả của sự vận dụng và phát triển sáng tạo chủ nghĩa Mác - Lênin vào điều kiện cụ thể của nước ta, kế thừa và phát triển các giá trị truyền thống tốt đẹp của dân tộc, tiếp thu tinh hoa văn hóa nhân loại; là tài sản tinh thần vô cùng to lớn và quý giá của Đảng và dân tộc ta, mãi mãi soi đường cho sự nghiệp cách mạng của nhân dân ta giành thắng lợi”. Khái niệm trên chỉ rõ: “Bản chất cách mạng, khoa học của tư tưởng Hồ Chí Minh” Đó là hệ thống các quan điểm lý luận, phản ánh những vấn đề có tính quy luật của cách mạng Việt nam. Tư tưởng Hồ Chí Minh là hệ thống các quan điểm toàn diện và sâu sắc về mục tiêu xây dựng một nước Việt Nam hòa bình, thống nhất, độc lập, dân chủ và giàu mạnh, góp phần xứng đáng vào sự nghiệp cách mạng thế giới. Con đường để đạt được mục tiêu đó là độc lập dân tộc gắn liền với chủ nghĩa xã hội.", "order_start": 0, "order_end": 958, "word_count": 217}
{"parent_id": "06a1982f-b74b-416d-ba16-8e8a9a42406f", "subject": "tutuonghcm", "section": "Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.", "title_path": "Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.", "content": "[tutuonghcm / Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.] thống nhất, độc lập, dân chủ và giàu mạnh, góp phần xứng đáng vào sự nghiệp cách mạng thế giới. Con đường để đạt được mục tiêu đó là độc lập dân tộc gắn liền với chủ nghĩa xã hội. Mục tiêu và con đường cách mạng của ta dựa trên nền tảng chủ nghĩa Mác-Lenin để xây dựng các hệ thống quan điểm cơ bản về chính trị, kinh tế,văn hóa, xây dựng con người xã hội chủ nghĩa… Nguồn gốc, cơ sở hình thành tư tưởng HCM: Là những giá trị căn bản bền vững của chủ nghĩa Mác-Leenin, các tinh hoa văn hóa của nhân loại khác, đồng thời tư tưởng HCM cũng kế thừa và phất triển các giá trị truyền thống tốt đẹp của dân tộc ta. Ý nghĩa và giá trị tư tưởng HCM: Là nền tảng lý luận và định hướng cho Đảng ta xây dựng các đường lối đúng đắn, tổ chức lực lượng cách mạng và dẫn dắt nhân dân ta di từ thắng lợi này đến thắng lợi khác trong quá trình cách mạng của nước ta. Tư tưởng HCM và Chủ nghĩa Mác-Lenin là bộ phận cấu thành nên nền tảng tư tưởng, là hướng dẫn quan trọng cho hành động cách mạng VN.", "order_start": 958, "order_end": 1939, "word_count": 215}
{"parent_id": "06a1982f-b74b-416d-ba16-8e8a9a42406f", "subject": "tutuonghcm", "section": "Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.", "title_path": "Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.", "content": "[tutuonghcm / Chương 1: Khái niệm, ý nghĩa học tập môn Tư tưởng HCM.] lợi khác trong quá trình cách mạng của nước ta. Tư tưởng HCM và Chủ nghĩa Mác-Lenin là bộ phận cấu thành nên nền tảng tư tưởng, là hướng dẫn quan trọng cho hành động cách mạng VN.  Ý nghĩa học tập môn Tư tưởng HCM", "order_start": 1939, "order_end": 2153, "word_count": 47}
{"parent_id": "da23d0c5-c16b-4f13-8cbf-d7775f69a577", "subject": "tutuonghcm", "section": "1. Góp phần nâng cao năng lực tư duy lý luận", "title_path": "1. Góp phần nâng cao năng lực tư duy lý luận", "content": "[tutuonghcm / 1. Góp phần nâng cao năng lực tư duy lý luận] Cùng với Chủ nghĩa Mác - Lênin, tư tưởng Hồ Chí Minh trở thành nền tảng tư tưởng, kim chỉ nam cho hành động của cách mạng Việt Nam. Chính vì vậy, môn học tư tưởng Hồ Chí Minh có vai trò quan trọng trong việc củng cố, tăng cường thế giới quan, phương pháp luận cách mạng cho người học. Môn học tư tưởng Hồ Chí Minh góp phần trang bị cho sinh viên hệ thống tri thức khoa học và toàn diện về những vấn đề cơ bản của cách mạng Việt Nam. Thông qua đó hình thành năng lực, phương pháp giải quyết những vấn đề do cuộc sống đặt ra. Học tập, nghiên cứu tư tưởng Hồ Chí Minh nhằm bồi dưỡng, củng cố cho sinh viên, thanh niên lập trường, quan điểm cách mạng trên nền tảng chủ nghĩa Mác - Lênin, tư tưởng Hồ Chí Minh; kiên định mục tiêu độc lập dân tộc gắn liền với chủ nghĩa xã hội; tích cực, chủ động đấu tranh phê phán các quan điểm sai trái, bảo vệ chủ nghĩa Mác - Lênin, tư tưởng Hồ Chí Minh, đường lối, chủ trương, chính sách của Đảng, Nhà nước ta. 2. Giáo dục và thực hành đạo đức cách mạng, củng cố niềm tin khoa học gắn liền với trau dồi tình cảm cách mạng, bồi dưỡng lòng yêu nước.", "order_start": 0, "order_end": 1079, "word_count": 233}
{"parent_id": "da23d0c5-c16b-4f13-8cbf-d7775f69a577", "subject": "tutuonghcm", "section": "1. Góp phần nâng cao năng lực tư duy lý luận", "title_path": "1. Góp phần nâng cao năng lực tư duy lý luận", "content": "[tutuonghcm / 1. Góp phần nâng cao năng lực tư duy lý luận] ủ trương, chính sách của Đảng, Nhà nước ta. 2. Giáo dục và thực hành đạo đức cách mạng, củng cố niềm tin khoa học gắn liền với trau dồi tình cảm cách mạng, bồi dưỡng lòng yêu nước. Học tập tư tưởng Hồ Chí Minh, người học không những có những hiểu biết về tri thức khoa học, nâng cao trình độ tư duy lý luận mà còn hiểu biết sâu sắc và toàn diện về cuộc đời, sự nghiệp cách mạng của Hồ Chí Minh, Anh hùng giải phóng dân tộc, Nhà văn hóa kiệt xuất của thế giới. Qua những tri thức đó, người học nhận thức sâu hơn về vai trò của đạo đức đối với xã hội, những phẩm chất đạo đức cần có của con người, đặc biệt là con người cách mạng. Từ nhận thức đó, người học có điều kiện tốt để thực hành đạọ đức cách cách mạng, chống lại những nhận thức và hành vi đạo đức đi ngược lại những giá trị nhân văn mà cách mạng hướng tới. Thông qua những nhận thức mà môn học mang lại, góp phần nâng cao bản lĩnh chính trị, kiên định với mục tiêu dân giàu, nước mạnh, xã hội công bằng dân chủ văn minh mà Đảng, Hồ Chủ tịch và nhân dân ta đã lựa chọn.", "order_start": 1079, "order_end": 2105, "word_count": 227}
{"parent_id": "da23d0c5-c16b-4f13-8cbf-d7775f69a577", "subject": "tutuonghcm", "section": "1. Góp phần nâng cao năng lực tư duy lý luận", "title_path": "1. Góp phần nâng cao năng lực tư duy lý luận", "content": "[tutuonghcm / 1. Góp phần nâng cao năng lực tư duy lý luận] n học mang lại, góp phần nâng cao bản lĩnh chính trị, kiên định với mục tiêu dân giàu, nước mạnh, xã hội công bằng dân chủ văn minh mà Đảng, Hồ Chủ tịch và nhân dân ta đã lựa chọn. Trên cơ sở kiến thức đã học, sinh viên vận dụng vào cuộc sống, tu dưỡng, rèn luyện bản thân, hoàn thành tốt chức trách của mình, đóng góp thiết thực và hiệu quả cho sự thắng lợi của cách mạng Việt Nam.", "order_start": 2105, "order_end": 2487, "word_count": 84}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] Nghiên cứu môn học tư tưởng Hồ Chí Minh, người học có thể vận dụng để xây dựng phong cách tư, phong cách diễn đạt một vấn đề trong nhận thức. Đặc biệt, người học có thể xây dựng cho mình một phương pháp làm việc khoa học, phương pháp sinh hoạt phù hợp với điều kiện cụ thể của mình. Hơn nữa, người học có thể từng bước xây dựng, hoàn thiện phương pháp đối nhân xử thế theo phong cách Hồ Chí Minh trên tinh thần: Dĩ bất biến ứng vạn biến. Đặc biệt, nó giúp sinh viên hiểu rõ hơn và xây dựng kế hoạch và rèn luyện tư tưởng HCM để có thể áp dụng trong cuộc sống và giúp ích cho nước nhà. Chương 2: Cơ sở, quá trình hình thành và phát triển TTHCM Quá trình hình thành và phát triển TTHCM Gồm 5 giai đoạn: 1. Thời kỳ hình thành tư tưởng yêu nước và chí hướng cứu nước, trước năm 1911 – Hồ Chí Minh tiếp thu truyền thống tốt đẹp của quê hương, gia đình và của dân tộc.", "order_start": 0, "order_end": 862, "word_count": 188}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] M Gồm 5 giai đoạn: 1. Thời kỳ hình thành tư tưởng yêu nước và chí hướng cứu nước, trước năm 1911 – Hồ Chí Minh tiếp thu truyền thống tốt đẹp của quê hương, gia đình và của dân tộc. Sinh ra lớn lên trong một gia đình nho giáo tiến bộ, Người đã tiếp thu những truyền thông tốt đẹp của gia đinh: nhân cách, ý chí nghị lực phi thường của người cha; lòng độ lượng bao dung, nhân hậu của người mẹ; tinh thần yêu nước quật cường chống ngoại xâm cũng như tinh thầm hiếu học của vùng quê nghèo xứ Nghệ. – Tiếp thu các nền giáo dục nho học, quốc học và tân học. Bên cạnh học Khổng giáo Người đã tiếp xúc với nhiều loại sách báo tiến bộ ở các trường, lớp tại Vinh, tại kinh đô Huế, hiểu rõ tình cảnh nước nhà bị giặc ngoại xâm đô hộ, Hồ Chí Minh sớm có tư tưởng yêu nước và thể hiện rõ tư tưởng yêu nước trong hành động. – Hồ Chí Minh đã tham gia phong trào chống thuế ở Trung Kỳ. Là thày giáo ở Trường Dục Thanh, Phan Thiết, khi dạy học cũng như trong trong sinh hoạt, Hồ Chí Minh thường đem hết nhiệt tình truyền thụ cho học sinh lòng yêu nước và những suy nghĩ về vận mệnh nước nhà.", "order_start": 862, "order_end": 1936, "word_count": 236}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] c Thanh, Phan Thiết, khi dạy học cũng như trong trong sinh hoạt, Hồ Chí Minh thường đem hết nhiệt tình truyền thụ cho học sinh lòng yêu nước và những suy nghĩ về vận mệnh nước nhà. – Điểm đặc biệt của tuổi trẻ Hồ Chí Minh là suy ngẫm sâu sắc về Tổ quốc và thời cuộc. Tuy rất khâm phục tinh thần yêu nước của các vị tiền bối cách mạng nổi tiếng như Phan Bội Châu, Phan Châu Trinh, Hoàng Hoa Thám, v.v. nhưng Người sáng suốt phê phán, không tán thành, không đi theo con đường, phương pháp, khuynh hướng cứu nước của các vị đó. Hồ Chí Minh muốn tìm hiểu những gì ẩn giấu sau sức mạnh của kẻ thù và học hỏi kinh nghiệm cách mạng trên thế giới. Ngày 5-6-1911, Hồ Chí Minh đi ra nước ngoài tìm con đường cứu nước, cứu dân. 2. Thời kỳ tìm kiếm và xác định con đường cứu nước, giải phóng dân tộc (1911 -1920) – Hồ Chí Minh đến nhiều nước trên thế giới để tìm hiểu, khảo sát, lựa chọn con đường cứu nước.", "order_start": 1936, "order_end": 2831, "word_count": 192}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] . 2. Thời kỳ tìm kiếm và xác định con đường cứu nước, giải phóng dân tộc (1911 -1920) – Hồ Chí Minh đến nhiều nước trên thế giới để tìm hiểu, khảo sát, lựa chọn con đường cứu nước. Qua cuộc hành trình này, ở Người hình thành một nhận thức mới: Nhân dân lao động các nước, trong đó có giai cấp công nhân, đều bị bóc lột có thể là bạn của nhau; còn chủ nghĩa đế quốc, bọn thực dân ở đâu cũng là kẻ bóc lột, là kẻ thù của nhân dân lao động. – Năm 1919, Người thay mặt những người Việt Nam yêu nước ở Pháp, lấy tên là Nguyễn Ái Quốc, gửi Yêu sách của nhân dân An Nam tới Hội nghị Vécxây, đòi quyền tự do, dân chủ cho nhân dân Việt Đây là tiếng nói chính nghĩa đầu tiên của đại biểu phong trào giải phóng dân tộc Việt Nam trên diễn đàn quốc tế. Tiếng nói chính nghĩa đó có ảnh hưởng lớn tới các phong trào yêu nước ở Việt Nam. – Hồ Chí Minh đã tìm thấy và xác định rõ phương hướng đấu tranh giải phóng dân tộc Việt Nam theo con đường cách mạng vô sản qua nghiên cứu “Sơ thảo lần thứ nhất những luận cương về vấn đề dân tộc và vấn đề thuộc địa vào tháng 7-1920.", "order_start": 2831, "order_end": 3886, "word_count": 235}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] đấu tranh giải phóng dân tộc Việt Nam theo con đường cách mạng vô sản qua nghiên cứu “Sơ thảo lần thứ nhất những luận cương về vấn đề dân tộc và vấn đề thuộc địa vào tháng 7-1920. – Cuối năm 1020, Hồ Chí Minh cùng những người phái tả trong Đảng Xã hội Pháp tại Đại hội ở thành phố Tua, bỏ phiếu tán thành Quốc tế Cộng sản, tham gia sáng lập Đảng Cộng sản Pháp, trở thành người cộng sản Việt Nam đầu tiên. Đây là bước ngoặt quan trọng trong cuộc đời của Hồ Chí Minh, bước ngoặt chủ nghĩa yêu nước kết hợp chặt chẽ với lập trường cách mạng vô sản. 3. Thời kỳ hình thành những nội dung cơ bản tư tưởng về cách mạng Việt Nam (1920 -1930) – Đây là thời kỳ Hồ Chí Minh hoạt động lý luận và thực tiễn sôi nổi, phong phú ở nhiều nơi trên thế giới: Pháp (1921-1923), Liên Xô (1923-1924), Trung Quốc(1924-1927), Thái Lan (1928- 1929),đẩy mạnh hoạt động lý luận chính trị, tổ chức, chuẩn bị cho việc thành lập Đảng Cộng sản Việt Nam để lãnh đạo cách mạng Việt – Thông qua báo chí và các hoạt động thực tiễn Người tích cực truyền bá chủ nghĩa Mác – Lênin vào phong trào công nhân và phong trào yêu nước Việt Nam", "order_start": 3886, "order_end": 4985, "word_count": 232}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] am để lãnh đạo cách mạng Việt – Thông qua báo chí và các hoạt động thực tiễn Người tích cực truyền bá chủ nghĩa Mác – Lênin vào phong trào công nhân và phong trào yêu nước Việt Nam. Các tác phẩm như Bản án chế độ thực dân Pháp (1925), Đường Kách mệnh (1927) và nhiều bài viết của Hồ Chí Minhtrong thời kỳ này thể hiện những quan điểm độc đáo, sáng tạo của Người về con đường cách mạng Việt Nam. – Cũng trong thời kỳ này, Hồ Chí Minh sáng lập tổ chức tiền thân của Đảng Cộng sản: Hội Việt Nam Thanh niên Cách mạng (tháng 6- 1925), ra báo Thanh niên bằng tiếng Việt, từng bước truyền bá chủ nghĩa Mác – Lênin và lý luận cách mạng trong những người yêu nước và công nhân. – Hồ Chí Minh chủ trì Hội nghị hợp nhất các tổ chức cộng sản Việt Nam thành Đảng Cộng sản Việt Nam, thông qua các văn kiện do Người khởi thảo (đầu năm 1930). Các văn kiện này là Cương lĩnh chính trị đầu tiên của Đảng Cộng sản Việt Nam, trong đó chính thức khẳng định rõ những quan điểm cơ bản về đường lối, phương pháp cách mạng Việt Nam, việc tổ chức, xây dựng Đảng Cộng sản Việt Nam thành một tổ chức lãnh đạo cách mạng Việt Nam.", "order_start": 4985, "order_end": 6085, "word_count": 236}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] thức khẳng định rõ những quan điểm cơ bản về đường lối, phương pháp cách mạng Việt Nam, việc tổ chức, xây dựng Đảng Cộng sản Việt Nam thành một tổ chức lãnh đạo cách mạng Việt Nam. – Hồ Chí Minh thành lập Đảng Cộng sản Việt Nam với Cương lĩnh chính trị đúng đắn và sáng tạo đã chấm dứt cuộc khủng hoảng về đường lối và tổ chức lãnh đạo cách mạng Việt Nam kéo dài suốt từ cuối thế kỷ XIX sang đầu năm 1930. 4. Thời kỳ vượt qua thử thách, giữ vững đường lối cách mạng đúng đắn, sáng tạo (1930 -1941) – Do chịu ảnh hưởng quan điểm giáo điều tả khuynh và không nắm vững tình hình các dân tộc thuộc địa, Quốc tế Cộng sản và Đảng Cộng sản Đông Dương có những nhìn nhận sai lầm về Hồ Chí Minh. Những tư tưởng mới mẻ, đúng đắn, sáng tạo của Hồ Chí Minh trong Cương lĩnh chính trị đầu tiên chẳng những không được hiểu và chấp nhận mà còn bị phê phán, bị coi là “hữu khuynh”, “dân tộc chủ nghĩa”.", "order_start": 6085, "order_end": 6971, "word_count": 192}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] mẻ, đúng đắn, sáng tạo của Hồ Chí Minh trong Cương lĩnh chính trị đầu tiên chẳng những không được hiểu và chấp nhận mà còn bị phê phán, bị coi là “hữu khuynh”, “dân tộc chủ nghĩa”. – Hội nghị Trung ương Đảng họp tháng 10-1930 ra nghị quyết cho rằng: Hội nghị hợp nhất Đảng do Nguyễn Ái Quốc chủ trì có nhiều sai lầm, “chỉ lo đến việc phản đế mà quên mất lợi ích giai cấp tranh đấu, ấy là một sự rất nguy hiểm”, việc phân chia thành trung, tiểu, đại địa chủ trong sách lược của Đảng là không đúng. Hội nghị ra án nghị quyết: “Thủ tiêu chánh cương, sách lược và điều lệ Đảng”; đổi tên Đảng Cộng sản Việt Nam thành Đảng Cộng sản Đông Dương, hoạt động theo như chỉ thị của Quốc tế Cộng sản, v.v – Thoát khỏi nhà tù của thực dân Anh ở Hồng Kông, cuối năm 1932, Hồ Chí Minh trở lại Liên Xô, vào học Trường Quốc tế Lênin. Sau đó, Người làm nghiên cứu sinh tại Ban Sử của Viện Nghiên cứu các vấn đề dân tộc và thuộc địa của Quốc tế Cộng sản. Trong quãng thời gian từ năm 1932 đến năm 1938, Hồ Chí Minh vẫn còn bị hiểu lầm về một số hoạt động thực tế và quan điểm cách mạng.", "order_start": 6971, "order_end": 8036, "word_count": 232}
{"parent_id": "01a4faf4-9139-4d05-ac44-62875f1c8a7f", "subject": "tutuonghcm", "section": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "title_path": "3. Xây dựng, rèn luyện phương pháp và phong cách công tác", "content": "[tutuonghcm / 3. Xây dựng, rèn luyện phương pháp và phong cách công tác] ấn đề dân tộc và thuộc địa của Quốc tế Cộng sản. Trong quãng thời gian từ năm 1932 đến năm 1938, Hồ Chí Minh vẫn còn bị hiểu lầm về một số hoạt động thực tế và quan điểm cách mạng. Người kiên trì giữ vững con đường cách mạng, viết thư cho Quốc tế cộng sản đề nghị được tiếp tục hoạt động cách mạng. – Đầu năm 1941, Hồ Chí Minh về nước tại Pác Bó- Cao Bằng, với tư cách cán bộ Quốc tế Cộng sản, Người chủ trì Hội nghị Ban Chấp hành Trung ương Đảng. Hội nghị này đã đặt nhiệm vụ giải phóng dân tộc lên hàng đầu. Người khẳng định rõ: “Trong lúc này quyền lợi dân tộc giải phóng cao hơn hết thảy. Chúng ta phải đoàn kết lại đánh đổ bọn đế quốc và bọn Việt gian đặng cứu giống nòi ra khỏi nước sôi lửa nóng”. – Trải qua sóng gió, thử thách, những quan điểm cơ bản nhất về đường lối cách mạng giải phóng dân tộc Việt Nam của Hồ Chí Minh được Đảng khẳng định đưa vào thực tiễn tổ chức nhân dân biến thành các phong trào cách mạng để dẫn tới thắng lợi của cuộc Cách mạng Tháng Tám năm 1945.", "order_start": 8036, "order_end": 9018, "word_count": 217}
{"parent_id": "fdb156bf-3c6d-4ba9-9fe7-ed52d209a5b8", "subject": "tutuonghcm", "section": "5. Thời kỳ tư tưởng Hồ Chí Minh phát triển và thắng lợi (1941 -1969)", "title_path": "5. Thời kỳ tư tưởng Hồ Chí Minh phát triển và thắng lợi (1941 -1969)", "content": "[tutuonghcm / 5. Thời kỳ tư tưởng Hồ Chí Minh phát triển và thắng lợi (1941 -1969)] – Trong thời kỳ này, tư tưởng Hồ Chí Minh và đường lối của Đảng cơ bản là thống nhất, lãnh đạo cách mạng Việt Nam chuẩn bị lực lượng, đón thời cơ khởi nghĩa, giành chính quyền. Cách mạng Tháng Tám năm 1945 thành công, giành lại độc lập dân tộc. Đây là thắng lợi to lớn của chủ nghĩa Mác – Lênin và tư tưởng Hồ Chí Minh ở Việt – Ngày 2-9-1945, Hồ Chí Minh đọc Tuyên ngôn Độc lập. Nước Việt Nam Dân chủ Cộng hoà ra đời, mở ra một kỷ nguyên mới trong lịch sử dân tộc Việt Nam – kỷ nguyên độc lập dân tộc gắn liền với chủ nghĩa xã hội. – Từ 1945 -1969, Hồ Chí Minh với cương vị đứng đầu Đảng và Nhà nước ta, trực tiếp lãnh đạo hai cuộc kháng chiến và xây dựng CNXH ở miền Bắc, tư tưởng Hồ Chí Minh được bổ sung phát triển hệ thống quan điểm cơ bản của cách mạng Việt Nam trên tất cả các lĩnh vực chính trị, kinh tế, quân sự, văn hoá, đạo đức, đối ngoại, v,v…nhằm hướng tới mục tiêu nước ta được hoàn toàn độc lập, dân ta được hoàn toàn tự do, dân chủ, xây dựng thành công chủ nghĩa xã hội.", "order_start": 0, "order_end": 985, "word_count": 219}
{"parent_id": "fdb156bf-3c6d-4ba9-9fe7-ed52d209a5b8", "subject": "tutuonghcm", "section": "5. Thời kỳ tư tưởng Hồ Chí Minh phát triển và thắng lợi (1941 -1969)", "title_path": "5. Thời kỳ tư tưởng Hồ Chí Minh phát triển và thắng lợi (1941 -1969)", "content": "[tutuonghcm / 5. Thời kỳ tư tưởng Hồ Chí Minh phát triển và thắng lợi (1941 -1969)] nh tế, quân sự, văn hoá, đạo đức, đối ngoại, v,v…nhằm hướng tới mục tiêu nước ta được hoàn toàn độc lập, dân ta được hoàn toàn tự do, dân chủ, xây dựng thành công chủ nghĩa xã hội. – Trước khi đi xa, Người để lại Di chúc, một văn kiện lịch sử vô giá, kết tinh tư tưởng, trí tuệ, tâm hồn, đạo đức, phong cách của một lãnh tụ cách mạng, anh hùng dân tộc vĩ đại, nhà tư tưởng lỗi lạc, nhà văn hóa kiệt xuất, suốt đời vì dân, vì nước. Điều mong muốn cuối cùng của Hồ Chí Minh là: “Toàn Đảng, toàn dân ta đoàn kết phấn đấu, xây dựng một nước Việt Nam hoà bình, thống nhất, độc lập, dân chủ và giàu mạnh, và góp phần xứng đáng vào sự nghiệp cách mạng thế giới”. – Tư tưởng Hồ Chí Minh tiếp tục được Đảng Cộng sản Việt Nam vận dụng và phát triển trong thực tiễn cách mạng Việt Nam.", "order_start": 985, "order_end": 1759, "word_count": 170}
{"parent_id": "ad63adb9-e432-4568-ab77-c3a3e186cc39", "subject": "tutuonghcm", "section": "– Cơ sở khách quan", "title_path": "– Cơ sở khách quan", "content": "[tutuonghcm / – Cơ sở khách quan] + Hoàn cảnh lịch sử: Tình hình trong nước, chính quyền triều Nguyễn đã từng bước khuất phục trước cuộc xâm lược của thực dân Pháp, lần lượt ký kết các hiệp ước đầu hàng, thừa nhận nền bảo hộ của chúng trên toàn cõi Việt Nam. Đầu thế kỷ XX, các cuộc khai thác thuộc địa của thực dân Pháp khiến cho xã hội nước ta có sự biến chuyển và phân hóa. Tình hình quốc tế, cuối thế kỷ XIX, đầu thế kỷ XX chủ nghĩa tư bản từ giai đoạn cạnh tranh tự do chuyển sang giai đoạn độc quyền, xác lập quyền thống trị của chúng trên phạm vi toàn thế giới. – Những tiền đề tư tưởng, lý luận + Truyền thống tốt đẹp của dân tộc, trước hết là chủ nghĩa yêu nước Việt Nam Tư tưởng Hồ Chí Minh bắt nguồn từ truyền thống cần cù lao động, anh dũng chiến đấu trong dựng nước và giữ nước, truyền thống đoàn kết, sống có tình, có nghĩa, nhân ái Việt Nam. Trong những truyền thống tốt đẹp của dân tộc Việt Nam thì chủ nghĩa yêu nước là dòng chảy xuyên suốt lịch sử dân tộc. Chính truyền thống yêu nước của dân tộc đã trở thành sức mạnh động lực mạnh mẽ thúc giục Nguyễn Tất Thành (Hồ Chí Minh) đi tìm đường cứu nước vào năm 1911.", "order_start": 0, "order_end": 1096, "word_count": 236}
{"parent_id": "ad63adb9-e432-4568-ab77-c3a3e186cc39", "subject": "tutuonghcm", "section": "– Cơ sở khách quan", "title_path": "– Cơ sở khách quan", "content": "[tutuonghcm / – Cơ sở khách quan] ên suốt lịch sử dân tộc. Chính truyền thống yêu nước của dân tộc đã trở thành sức mạnh động lực mạnh mẽ thúc giục Nguyễn Tất Thành (Hồ Chí Minh) đi tìm đường cứu nước vào năm 1911. Đó là động lực chi phối mọi suy nghĩ, hành động của Người trong suốt cả cuộc đời hoạt động cách mạng. Đó cũng chính là cơ sở tư tưởng đã dẫn dắt Người đến với chủ nghĩa Mác – Lênin. Hồ Chí Minh viết: “Lúc đầu, chính là chủ nghĩa yêu nước, chứ chưa phải chủ nghĩa cộng sản đã đưa tôi tin theo Lênin, tin theo Quốc tế thứ ba”. + Tinh hoa văn hoá nhân loại Cùng với chủ nghĩa yêu nước, Hồ Chí Minh còn chịu ảnh hưởng của văn hoá phương Đông. Người cũng đã tiếp thu và kế thừa có phê phán tư tưởng dân chủ, nhân văn của văn hoá Phục hưng, thế kỷ Ánh sáng, của cách mạng tư sản phương Tây và cách mạng Trung Quốc.", "order_start": 1096, "order_end": 1885, "word_count": 174}
{"parent_id": "ad63adb9-e432-4568-ab77-c3a3e186cc39", "subject": "tutuonghcm", "section": "– Cơ sở khách quan", "title_path": "– Cơ sở khách quan", "content": "[tutuonghcm / – Cơ sở khách quan] ương Đông. Người cũng đã tiếp thu và kế thừa có phê phán tư tưởng dân chủ, nhân văn của văn hoá Phục hưng, thế kỷ Ánh sáng, của cách mạng tư sản phương Tây và cách mạng Trung Quốc. Trước khi đến với chủ nghĩa Mác – Lênin, Hồ Chí Minh đã quan tâm nghiên cứu, tìm hiểu tư tưởng dân chủ tư sản Pháp, Mỹ, đặc biệt là tư tưởng Tự do, Bình đẳng, Bác ái, chủ nghĩa Tam dân của Tôn Trung Sơn (Trung Quốc)… Người đã vận dụng và phát triển các trào lưu tư tưởng học thuyết ấy lên một trình độ mới phù hợp với dân tộc và thời đại mới. Như vậy, trong quá trình hình thành phát triển tư tưởng của mình, Hồ Chí Minh đã kế thừa có chọn lọc tinh hoa văn hoá phương Đông phương Tây, nâng lên một trình độ mới trên cơ sở phương pháp luận Mácxít – lêninnít. + Chủ nghĩa Mác – Lênin Khi ra đi tìm đường cứu nước, Hồ Chí Minh đã đến nhiều nước thuộc địa và nhiều nước tư bản đế quốc. Trong khoảng thời gian đó, Hồ Chí Minh được bổ sung thêm những nhận thức mới về những gì ẩn dấu đằng sau các từ Tự do, Bình đẳng, Bác ái.", "order_start": 1885, "order_end": 2885, "word_count": 222}
{"parent_id": "ad63adb9-e432-4568-ab77-c3a3e186cc39", "subject": "tutuonghcm", "section": "– Cơ sở khách quan", "title_path": "– Cơ sở khách quan", "content": "[tutuonghcm / – Cơ sở khách quan] ớc thuộc địa và nhiều nước tư bản đế quốc. Trong khoảng thời gian đó, Hồ Chí Minh được bổ sung thêm những nhận thức mới về những gì ẩn dấu đằng sau các từ Tự do, Bình đẳng, Bác ái. Khoảng cuối năm 1917, khi trở lại Pari, Hồ Chí Minh đã làm quen với nhiều nhà hoạt động chính trị, xã hội của nước Pháp và nhiều nước trên thế giới. Năm 1919, Hồ Chí Minh tham gia Đảng Xã hội Pháp (SFIO), một đảng tiến bộ lúc bấy giờ thuộc Quốc tế II. Việc Hồ Chí Minh tiếp thu bản Luận cương của Lênin tháng 7-1920 và trở thành người cộng sản vào cuối năm đó đã tạo nên bước ngoặt căn bản trong tư tưởng của Người. Thế giới quan và phương pháp luận Mác – Lênin đã giúp Hồ Chí Minh nhìn nhận, đánh giá phân tích tổng kết các học thuyết, tư tưởng, đường lối các cuộc cách mạng một cách khoa học; cùng với kinh nghiệm hoạt động thực tiễn của mình để đề ra con đường cách mạng giải phóng dân tộc đứng đắn. Có thể khẳng định rằng Chủ nghĩa Mác – Lênin là nguồn gốc lý luận cơ sở chủ yếu nhất của sự hình thành phát triển tư tưởng Hồ Chí Minh.", "order_start": 2885, "order_end": 3904, "word_count": 223}
{"parent_id": "ad63adb9-e432-4568-ab77-c3a3e186cc39", "subject": "tutuonghcm", "section": "– Cơ sở khách quan", "title_path": "– Cơ sở khách quan", "content": "[tutuonghcm / – Cơ sở khách quan] đường cách mạng giải phóng dân tộc đứng đắn. Có thể khẳng định rằng Chủ nghĩa Mác – Lênin là nguồn gốc lý luận cơ sở chủ yếu nhất của sự hình thành phát triển tư tưởng Hồ Chí Minh. Cách mạng Tháng Mười Nga năm 1917 thành công và sự ra đời của Quốc tế Cộng sản (tháng 3- 1919), phong trào công nhân trong các nước tư bản chủ nghĩa phương Tây và phong trào giải phóng dân tộc ở các nước thuộc địa phương Đông đã có quan hệ với nhau trong cuộc đấu tranh chống kẻ thù chung là chủ nghĩa đế quốc. Kết luận: Hoàn cảnh lịch sử ra đời tư tưởng Hồ Chí Minh chính là sự vận động, phát triển của tư tưởng yêu nước Việt Nam những năm cuối thế kỷ XIX đầu thế kỷ XX; là sự gặp gỡ giữa trí tuệ mẫn cảm, thiên tài của Hồ Chí Minh với trí tuệ thời đại - chủ nghĩa Mác - Lênin. Từ sự tiếp thu nhận thức ban đầu, trong quá trình hoạt động cách mạng, lãnh đạo cách mạng Việt Nam, Hồ Chí Minh đã vận dụng sáng tạo, bổ sung, phát triển những quan điểm mới, tạo thành hệ thống tư tưởng của Người. Chương 3: Tư tưởng HCM về độc lập dân tộc và CNXH TTHCM về cách mạng giải phóng dân tộc.", "order_start": 3904, "order_end": 4966, "word_count": 235}
{"parent_id": "ad63adb9-e432-4568-ab77-c3a3e186cc39", "subject": "tutuonghcm", "section": "– Cơ sở khách quan", "title_path": "– Cơ sở khách quan", "content": "[tutuonghcm / – Cơ sở khách quan] g sáng tạo, bổ sung, phát triển những quan điểm mới, tạo thành hệ thống tư tưởng của Người. Chương 3: Tư tưởng HCM về độc lập dân tộc và CNXH TTHCM về cách mạng giải phóng dân tộc. Tư tưởng Hồ Chí Minh về cách mạng giải phóng dân tộc ở thuộc địa có thể tóm tắt thành một hệ thống luận điểm như sau:", "order_start": 4966, "order_end": 5264, "word_count": 66}
{"parent_id": "95deeeb8-0cea-4f40-975f-253b74906010", "subject": "tutuonghcm", "section": "1) Cách mạng giải phóng dân tộc muốn thắng lợi phải đi theo con đường của cách mạng vô sản:", "title_path": "1) Cách mạng giải phóng dân tộc muốn thắng lợi phải đi theo con đường của cách mạng vô sản:", "content": "[tutuonghcm / 1) Cách mạng giải phóng dân tộc muốn thắng lợi phải đi theo con đường của cách mạng vô sản:] – Thất bại của các phong trào yêu nước cuối thế kỷ XIX, đầu thế kỷ XX ở nước ta là do chưa có đường lối và phương pháp đấu tranh đúng đắn khi chủ nghĩa đế quốc đã thành một hệ thống thế giới. Chủ nghĩa đế quốc vừa tranh giành nhau xâu xé thuộc địa vừa liên kết với nhau trong việc đàn áp phong trào đấu tranh giành độc lập của các dân tộc thuộc địa. – Các nước thuộc địa chẳng những cung cấp nguyên liệu mà còn cung cấp binh lính cho quân đội đế quốc nhằm đàn áp các phong trào đấu tranh của giai cấp công nhân ở chính quốc. – Trong cuộc đấu tranh tự giải phóng, giai cấp vô sản ở chính quốc và nhân dân các thuộc địa có chung một kẻ thù, vì vậy phải phối hợp hành động và cổ vũ lẫn nhau.", "order_start": 0, "order_end": 688, "word_count": 155}
{"parent_id": "95deeeb8-0cea-4f40-975f-253b74906010", "subject": "tutuonghcm", "section": "1) Cách mạng giải phóng dân tộc muốn thắng lợi phải đi theo con đường của cách mạng vô sản:", "title_path": "1) Cách mạng giải phóng dân tộc muốn thắng lợi phải đi theo con đường của cách mạng vô sản:", "content": "[tutuonghcm / 1) Cách mạng giải phóng dân tộc muốn thắng lợi phải đi theo con đường của cách mạng vô sản:] ân ở chính quốc. – Trong cuộc đấu tranh tự giải phóng, giai cấp vô sản ở chính quốc và nhân dân các thuộc địa có chung một kẻ thù, vì vậy phải phối hợp hành động và cổ vũ lẫn nhau. Từ đầu những năm 20 thế kỷ XX, Nguyễn Ái Quốc đã chỉ rõ: chủ nghĩa đế quốc là một con đỉa có… Từ đó phải kết hợp cách mạng vô sản ở chính quốc với cách mạng giải phóng dân tộc ở thuộc địa; phải xem cách mạng ở thuộc địa như là “một trong những cái cách của cách mạng vô sản”, phát triển nhịp với cách mạng vô sản; mặt khác cách mạng giải phóng dân tộc muốn thắng lợi phải theo con đường cách mạng vô sản, tức là phải đi theo đường lối Mác Lênin.", "order_start": 688, "order_end": 1314, "word_count": 142}
{"parent_id": "5c8383f1-5d8f-45bf-8f2f-4f8e46c881cf", "subject": "tutuonghcm", "section": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "title_path": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "content": "[tutuonghcm / 2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:] Nguyễn Ái Quốc đã sớm khẳng định: muốn giải phóng dân tộc thành công “Trước hết phải có đảng cách mệnh. Đảng có vững chắc mệnh mới thành công… Đảng muốn vững thì phải có chủ nghĩa làm cốt… Bây giờ học thuyết nhiều, chủ nghĩa nhiều, nhưng chủ nghĩa chân chính nhất, chắc chắn nhất, cách mệnh nhất là chủ nghĩa Lênin”. Như vậy Nguyễn Ái Quốc đã khẳng định: cách mạng giải phóng dân tộc muốn thắng lợi phải đặt dưới sự lãnh đạo của Đảng của giai cấp công nhân, Đảng đó phải được xây dựng theo các nguyên tắc Đảng kiểu mới của Lênin, được vũ trang bằng chủ nghĩa Mác Lênin. Các lãnh tụ yêu nước tiền bối cũng đã bước đầu nhận thức được tầm quan trọng và vai trò của chính đảng cách mạng. Phan Chu Trinh đã nói: ngày nay, muốn có độc lập, tự do, phải có đoàn thể, nhưng ông chỉ kịp nói mà không kịp làm. Phan Bội Châu đã tổ chức ra Đảng Việt Nam Quang phục hội, sau dự định cải tổ nó thành Việt Nam Quốc dân đảng theo kiểu Tôn Trung Sơn, nhưng ông chưa kịp thực hiện thì đã bị bắt, bị đưa về giam lỏng tại Huế.", "order_start": 0, "order_end": 1005, "word_count": 214}
{"parent_id": "5c8383f1-5d8f-45bf-8f2f-4f8e46c881cf", "subject": "tutuonghcm", "section": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "title_path": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "content": "[tutuonghcm / 2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:] a Đảng Việt Nam Quang phục hội, sau dự định cải tổ nó thành Việt Nam Quốc dân đảng theo kiểu Tôn Trung Sơn, nhưng ông chưa kịp thực hiện thì đã bị bắt, bị đưa về giam lỏng tại Huế. Dù đã thành lập hay chưa thì các đảng kiểu đó cũng không thể lãnh đạo cách mạng giải phóng dân tộc đi đến thành công, vì nó thiếu một đường lối chính trị đúng đắn và một đường lối tổ chức chặt chẽ; lại không có cơ sở rộng rãi trong quần chúng, nên sớm muộn cũng rơi vào tan rã và thất bại. 3) Cách mạng giải phóng dân tộc là sự nghiệp đoàn kết của toàn dân, trên cơ sở liên minh công nông: –Cách mạng giải phóng dân tộc như Nguyễn Ái Quốc viết “là việc chung cả dân chúng chứ không phải việc một hai người”, vì vậy phải đoàn kết toàn dân, “sĩ, công, nông, thương đều nhất trí chống lại cường quyền”. Nhưng trong sự tập hợp rộng rãi đó, Người nhắc nhở không được quên cái cốt của nó là công- nông. Phải nhớ: “Công nông là người chủ cách mệnh… Công nông là gốc cách mệnh”.", "order_start": 1005, "order_end": 1956, "word_count": 206}
{"parent_id": "5c8383f1-5d8f-45bf-8f2f-4f8e46c881cf", "subject": "tutuonghcm", "section": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "title_path": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "content": "[tutuonghcm / 2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:] g quyền”. Nhưng trong sự tập hợp rộng rãi đó, Người nhắc nhở không được quên cái cốt của nó là công- nông. Phải nhớ: “Công nông là người chủ cách mệnh… Công nông là gốc cách mệnh”. – Trong phạm vi của cách mạng giải phóng dân tộc mà đối tượng cần đánh đổ trước hết là bọn đế quốc và địa chủ phong kiến tay sai nhằm giành lại độc lập dân tộc và dân chủ cho nhân dân, trước hết là nông dân, nên Nguyễn Ái Quốc chủ trương cần vận động, tập hợp rộng rãi các tầng lớp nhân dân Việt Nam đang mất nước, đang bị làm nô lệ trong một mặt trận dân tộc thống nhất rộng rãi nhằm huy động sức mạnh của toàn dân tộc đấu tranh giành độc lập tự do. – Người đã viết trong Sách lược vắn tắt tại Hội nghị thành lập Đảng đầu năm 1930: “Đảng phải hết sức liên lạc với tiểu tư sản, trí thức, trung nông, thanh niên, tân Việt…, để kéo họ đi vào phe vô sản giai cấp. Còn đối với bọn phú nông, trung, tiểu địa chủ và tư bản An Nam mà chưa rõ mặt phản cách mạng thì phải lợi dụng, ít lâu mới làm cho họ đứng trung lập. Bộ phận nào đã rõ mặt phản cách mạng (Đảng Lập hiến, v.v…) thì phải đánh đổ.", "order_start": 1956, "order_end": 3024, "word_count": 238}
{"parent_id": "5c8383f1-5d8f-45bf-8f2f-4f8e46c881cf", "subject": "tutuonghcm", "section": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "title_path": "2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:", "content": "[tutuonghcm / 2)Cách mạng giải phóng dân tộc muốn thắng lợi phải do Đảng của giai cấp công nhân lãnh đạo:] và tư bản An Nam mà chưa rõ mặt phản cách mạng thì phải lợi dụng, ít lâu mới làm cho họ đứng trung lập. Bộ phận nào đã rõ mặt phản cách mạng (Đảng Lập hiến, v.v…) thì phải đánh đổ. – Do chưa phân biệt được sự khác nhau giữa yêu cầu mục tiêu của cách mạng vô sản ở các nước tư bản phát triển với cách mạng giải phóng dân tộc ở thuộc địa, lại chịu sự chi phối của quan điểm “tả” khuynh của đường lối “giai cấp chống giai cấp” đang tồn tại trong Quốc tế Cộng sản lúc bấy giờ, nên đã có ý kiến cho rằng Nguyễn Ái Quốc quá chú trọng vấn đề dân tộc, “chỉ nghĩ đến việc phản đế mà quên mất lợi ích giai cấp đấu tranh”,v.v… – Thực ra, trong khi chủ trương đoàn kết, tập hợp rộng rãi các lực lượng dân tộc chống đế quốc, Hồ Chí Minh vẫn nhắc nhở phải quán triệt quan điểm giai cấp: “Công nông là gốc cách mệnh; còn học trò, nhà buôn nhỏ, điền chủ cũng bị tư sản áp bức, song không cực khổ bằng công nông, ba hạng ấy chỉ là bầu bạn cách mệnh của công nông thôi”. Và trong khi liên lạc với các giai cấp, phải rất cẩn thận, không khi nào nhượng một chút lợi ích gì của công nông mà đi vào đường lối thỏa hiệp”.", "order_start": 3024, "order_end": 4122, "word_count": 245}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] – Đây là một điểm mới mẻ và sáng tạo của Hồ Chí Minh. Trong phong trào cộng sản quốc tế, như đã nói ở trên, đã từng tồn tại quan điểm xem thắng lợi của cách mạng thuộc địa phụ thuộc trực tiếp vào thắng lợi của cách mạng vô sản ở chính quốc. Tuyên ngôn thành lập Quốc tế Cộng sản năm 1919 có đoạn viết: “Công nhân và nông dân không những ở An Nam, Angiêri, Bengan mà cả Ba Tư hay Ácmênia chỉ có thể giành được độc lập khi mà công nhân các nước Anh và nước Pháp lật đổ được Lôiit Gioócgiơ và Clêmăngxô, giành chính quyền nhà nước vào tay mình”. Những luận cương về phong trào cách mạng trong các nước thuộc địa và nửa thuộc địa được thông qua Đại hội VI Quốc tế Cộng sản, ngày 1-9-1928 viết: “Chỉ có thể thực hiện hoàn toàn công cuộc giải phóng các thuộc địa khi giai cấp vô sản giành được thắng lợi ở các nước tư bản tiên tiến”. Quan điểm này, vô hình trung đã giảm tính chủ động, sáng tạo của các phong trào cách mạng ở thuộc địa.", "order_start": 0, "order_end": 930, "word_count": 200}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] ộc địa khi giai cấp vô sản giành được thắng lợi ở các nước tư bản tiên tiến”. Quan điểm này, vô hình trung đã giảm tính chủ động, sáng tạo của các phong trào cách mạng ở thuộc địa. – Phát biểu tại Đại hội V Quốc tế Cộng sản (1924) Nguyễn Ái Quốc đã phân tích: “Vận mệnh giai cấp vô sản thế giới và đặc biệt là vận mệnh giai cấp vô sản ở các nước đi xâm lược thuộc địa gắn chặt với vận mệnh của giai cấp bị áp bức ở các thuộc địa… nọc độc và sức sống của con rắn độc tư bản chủ nghĩa đang tập trung ở các thuộc địa”, nếu khinh thường cách mạng ở thuộc địa tức là “muốn đánh rắn đằng đuôi”. – Vận dụng công thức của Các Mác: “Sự giải phóng giai cấp công nhân phải là sự nghiệp của bản thân giai cấp công nhân”, Nguyễn Ái Quốc đã đi tới điểm: “Công cuộc giải phóng anh em (tức nhân dân thuộc địa) chỉ có thể thực hiện được bằng sự nỗ lực của bản thân anh em”.", "order_start": 930, "order_end": 1786, "word_count": 193}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] ủa bản thân giai cấp công nhân”, Nguyễn Ái Quốc đã đi tới điểm: “Công cuộc giải phóng anh em (tức nhân dân thuộc địa) chỉ có thể thực hiện được bằng sự nỗ lực của bản thân anh em”. – Do nhận thức được thuộc địa là một khâu yếu trong hệ thống của chủ nghĩa đế quốc, do đánh giá đúng đắn sức mạnh của chủ nghĩa yêu nước và tinh thần dân tộc, ngay từ năm 1924, Nguyễn Ái Quốc đã sớm cho rằng: “Cách mạng thuộc địa không những không phụ thuộc vào cách mạng vô sản ở chính quốc mà có thể giành thắng lợi trước”, và “trong khi thủ tiêu một trong những điều kiện tồn tại của chủ nghĩa tư bản là chủ nghĩa đế quốc, họ có thể giúp đỡ những người anh em mình ở phương Tây trong nhiệm vụ giải phóng hoàn toàn”. – Đây là một luận điểm sáng tạo, có giá trị lý luận và thực tiễn rất to lớn, một cống hiến rất quan trọng vào kho tàng lý luận Mác- Lênin, đã được thắng lợi của cách mạng giải phóng dân tộc Việt Nam chứng minh là hoàn toàn đúng đắn. 5) Cách mạng giải phóng dân tộc phải được thực hiện bằng con đường bạo lực, kết hợp lực lượng chính trị của quần chúng với lực lượng vũ trang trong nhân dân.", "order_start": 1786, "order_end": 2876, "word_count": 238}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] là hoàn toàn đúng đắn. 5) Cách mạng giải phóng dân tộc phải được thực hiện bằng con đường bạo lực, kết hợp lực lượng chính trị của quần chúng với lực lượng vũ trang trong nhân dân. – Từ đầu năm 1924, Nguyễn Ái Quốc đã đề cập khả năng một cuộc vũ trang khởi nghĩa ở Đông Dương. – Tháng 5-941, tại Hội nghị lần thứ tám, Người đưa ra nhận định: Cuộc cách mạng Đông Dương kết liễu bằng một cuộc khởi nghĩa vụ trang, mở đầu có thể là bằng một cuộc khởi nghĩa từng phần trong từng địa phương… mà mở đường cho một cuộc tổng khởi nghĩa. Thực tiễn cách mạng tháng Tám năm 1945, với hình thức phát động tổng khởi nghĩa của quần chúng nhân dân trong cả nước, chủ yếu dựa vào lực lượng chính trị, đấu tranh chính trị, kết hợp với đấu tranh vũ trang, cách mạng Việt Nam đã giành thắng lợi, giành chính quyền về tay nhân dân. TTHCM về đặc trưng của CNXH ở Việt Nam. 1. Tư tưởng Hồ Chí Minh về chủ nghĩa xã hội a.", "order_start": 2876, "order_end": 3774, "word_count": 192}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] đấu tranh vũ trang, cách mạng Việt Nam đã giành thắng lợi, giành chính quyền về tay nhân dân. TTHCM về đặc trưng của CNXH ở Việt Nam. 1. Tư tưởng Hồ Chí Minh về chủ nghĩa xã hội a. Quan niêm của Hồ Chí Minh về chủ nghĩa xã hội ̣ Hồ Chí Minh tiếp cận Chủ nghĩa xã hội trên nhiều phương diện khác nhau như: Hồ Chí Minh tiếp thu lý luận về chủ nghĩa xã hội khoa học của lý luận Mác - Lênin trước hết là từ khát vọng giải phóng dân tộc Việt Nam Hồ Chí Minh tiếp cận chủ nghĩa xã hội từ phương diện đạo đức. Người cho rằng: chủ nghĩa xã hội đối lập, xa lạ với chủ nghĩa cá nhân, nhưng không hề phủ nhận cá nhân, các giá trị cá nhân, phát triển mọi năng lực cá nhân vì phát triển xã hội và hạnh phúc con người. Hồ Chí Minh tiếp cận chủ nghĩa xã hội từ phương diện văn hoá. Người đã đưa văn hoá thâm nhập vào bên trong chính trị và kinh tế, tạo nên một sự thống nhất biện chứng giữa văn hoá và chính trị, kinh tế, giữa các mục tiêu phát triển xã hội.", "order_start": 3774, "order_end": 4717, "word_count": 212}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] oá. Người đã đưa văn hoá thâm nhập vào bên trong chính trị và kinh tế, tạo nên một sự thống nhất biện chứng giữa văn hoá và chính trị, kinh tế, giữa các mục tiêu phát triển xã hội. Hồ Chí Minh luận giải tính tất yếu và bản chất của chủ nghĩa xã hội trên cơ sở kế thừa và phát triển các giá trị truyền thống văn hoá của dân tộc Việt Nam, của phương Đông. Quan niệm của Hồ Chí Minh về chủ nghĩa xã hội là sự thống nhất biện chứng giữa các nhân tố kinh tế, chính trị, xã hội với các nhân tố nhân văn, đạo đức, văn hoá. Hồ Chí Minh quan niệm chủ nghĩa xã hội là giai đoạn đầu của chủ nghĩa cộng sản. Chủ nghĩa xã hội còn tồn tại những tàn dư của xã hội cũ, nhưng chủ nghĩa xã hội không còn áp bức, bóc lột, xã hội do nhân dân lao động làm chủ, trong đó con người sống ấm no, tự do, hạnh phúc, quyền lợi của cá nhân và tập thể vừa thống nhất vừa gắn bó chặt chẽ với nhau. b. Tiến lên chủ nghĩa xã hội là một tất yếu khách quan Hồ Chí Minh đã tiếp thu, vận dụng sáng tạo lý luận của chủ nghĩa Mác - Lênin về sự phát triển tất yếu của xã hội loài người theo các hình thái kinh tế xã hội.", "order_start": 4717, "order_end": 5797, "word_count": 247}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] ột tất yếu khách quan Hồ Chí Minh đã tiếp thu, vận dụng sáng tạo lý luận của chủ nghĩa Mác - Lênin về sự phát triển tất yếu của xã hội loài người theo các hình thái kinh tế xã hội. Quan điểm của Người là: Tiến lên chủ nghĩa xã hội là bước phát triển tất yếu ở Việt Nam sau khi nước nhà đã giành được độc lập theo con đường cách mạng vô sản. Nội dung cơ bản của học thuyết về hình thái kinh tế - xã hội được Hồ Chí Minh giải thích đơn giản: “Cách sản xuất và sức sản xuất phát triển và biến đổi mãi, do đó, mà tư tưởng của con người, chế độ xã hội, v. v ... cũng phát triển và biến đổi. Chúng ta đều biết từ đời xưa đến đời nay cách sản xuất từ chỗ dùng cành cây, búa đá, phát triển dần đến máy móc, sức điện, sức nguyên tử. Chế độ xã hội cũng phát triển từ cộng sản nguyên thủy, đến chế độ nô lệ, đến chế độ phong kiến, đến chế độ tư bản chủ nghĩa và ngày nay gần một nửa loài người đang tiến lên chế độ xã hội chủ nghĩa và chế độ cộng sản chủ nghĩa.", "order_start": 5797, "order_end": 6747, "word_count": 219}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] ên thủy, đến chế độ nô lệ, đến chế độ phong kiến, đến chế độ tư bản chủ nghĩa và ngày nay gần một nửa loài người đang tiến lên chế độ xã hội chủ nghĩa và chế độ cộng sản chủ nghĩa. Sự phát triển và tiến bộ đó không ai ngăn cản được” Như vậy, theo Hồ Chí Minh, tiến lên chủ nghĩa xã hội là một quá trình tất yếu, tuân theo những quy luật khách quan của quá trình sản xuất vật chất của nhân loại; song tùy theo điều kiện hoàn cảnh lịch sử của mỗi quốc gia, dân tộc mà con đường đi lên chủ nghĩa xã hội có những hình thức, phương thức khác nhau. Những nước đã trải qua giai đoạn phát triển tư bản chủ nghĩa có thể tiến thẳng lên chủ nghĩa xã hội; những nước chưa qua giai đoạn phát triển này, có thể đi lên chủ nghĩa xã hội sau khi đã “đánh đổ đế quốc và phong kiến” dưới sự lãnh đạo của Đảng vô sản và được chủ nghĩa Mác Lênin dẫn đường. Hồ Chí Minh đã chỉ rõ quy luật chung cũng như tính đặc thù trong quá trình đi lên chủ nghĩa xã hội trên thế giới. Với Việt Nam.", "order_start": 6747, "order_end": 7710, "word_count": 216}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] a Đảng vô sản và được chủ nghĩa Mác Lênin dẫn đường. Hồ Chí Minh đã chỉ rõ quy luật chung cũng như tính đặc thù trong quá trình đi lên chủ nghĩa xã hội trên thế giới. Với Việt Nam. trải qua hàng nghìn năm thống trị của chế độ phong kiến, gần 100 chịu ách thống trị của đế quốc thực dân, nhiều khuynh hướng cứu nước giải phóng dân tộc đã được thực hiện nhưng không đem lại kết quả cuối cùng mà dân tộc khao khát đạt được. “Chỉ có chủ nghĩa xã hội mới là nguồn gốc của tự do, bình đẳng, bác ái, xóa bỏ những bức tường dài ngăn cản con người yêu đoàn kết, yêu thương nhau” c. Một số đặc trưng cơ bản của xã hội xã hội chủ nghĩa Trên nền tảng của chủ nghĩa Mác - Lênin về chủ nghĩa xã hội, Hồ Chí Minh quan niệm chủ nghĩa xã hội là một xã hội có bản chất đối lập với các chế độ dựa trên sở hữu tư nhân tư liệu sản xuất trong lịch sử. Chủ nghĩa xã hội có nhiều đặc trưng căn bản - Thứ nhất, về chính trị: Xã hội xã hội chủ nghĩa là xã hội có chế độ dân chủ.", "order_start": 7710, "order_end": 8662, "word_count": 218}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] ộ dựa trên sở hữu tư nhân tư liệu sản xuất trong lịch sử. Chủ nghĩa xã hội có nhiều đặc trưng căn bản - Thứ nhất, về chính trị: Xã hội xã hội chủ nghĩa là xã hội có chế độ dân chủ. Chế độ dân chủ trong xã hội xã hội chủ nghĩa được thể hiện trước hết là xã hội do nhân dân là chủ, nhân dân làm chủ dưới sự lãnh đạo của Đảng cộng sản trên nền tảng của liên minh công - nông. Trong xã hội xã hội chủ nghĩa, địa vi cao nhất là nhân dân. Nhà nước trong xã hội xã hội chủ nghĩa là nhà nước của dân, do dân, vì dân. Mọi quyền lợi, quyền lực, quyền hạn thuộc về nhân dân và mọi hoạt động xây dựng, bảo vệ đất nước, bảo vệ chế độ xã hội cũng thuộc về nhândân . Tư tưởng cơ bản về đặc trưng chính trị trong xã hội xã hội chủ nghĩa của Hồ Chí Minh không những thể hiện tính nhân văn cao cả mà còn cho thấy nhận thức sâu sắc của Hồ Chí Minh về sức mạnh, địa vị, vai trò của nhân dân - chủ thể của tiến trình xây dựng chủ nghĩa xã hội; về điều kiện của thắng lợi trong quá trình xây dựng chủ nghĩa xã hội: Sự lãnh đạo của Đảng Cộng sản, đem tài dân, sức dân để làm lợi cho dân.", "order_start": 8662, "order_end": 9726, "word_count": 248}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] tiến trình xây dựng chủ nghĩa xã hội; về điều kiện của thắng lợi trong quá trình xây dựng chủ nghĩa xã hội: Sự lãnh đạo của Đảng Cộng sản, đem tài dân, sức dân để làm lợi cho dân. Xã hội xã hội chủ nghĩa là công trình tập thể của nhân dân lao động dưới sự lãnh đạo của Đảng. Thứ hai, về kinh tế: Xã hội xã hội chủ nghĩa là chế độ xã hội phát triển cao dựa trên lực lượng sản xuất hiên đại và chế độ công hữu về tư liê ̣ u sản xuất chủ yếu. ̣ Theo Hồ Chí Minh, chủ nghĩa xã hội là chế độ xã hội phát triển cao hơn chủ nghĩa tư bản, phải có nền kinh tế phát triển cao hơn nền kinh tế tư bản chủ nghĩa, có năng suất lao động cao hơn, đó là nền kinh tế dựa trên lực lượng sản xuất tiên tiến dựa trên chế độ công hữu về tư liệu sản xuất. Hồ Chí Minh quan niệm lực lượng sản xuất hiện đại trong chủ nghĩa xã hội biểu hiện: công cụ lao động, các phương tiện của quá trình sản xuất “đã phát triển dần đến máy móc, sức điện, sức nguyên tử”. Quan hệ sản xuất trong xã hội xã hội chủ nghĩa là: Lấy nhà máy, xe lửa, ngân hàng...v.v. làm của chung, là tư liệu sản xuất thuộc về nhân dân .", "order_start": 9726, "order_end": 10801, "word_count": 246}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] n máy móc, sức điện, sức nguyên tử”. Quan hệ sản xuất trong xã hội xã hội chủ nghĩa là: Lấy nhà máy, xe lửa, ngân hàng...v.v. làm của chung, là tư liệu sản xuất thuộc về nhân dân . Đó là quan niệm về chế độ công hữu về tư liệu sản xuất trong tư tưởng Hồ Chí Minh. Dĩ nhiên, phải hiểu xây dựng chế độ công hữu về tư liệu sản xuất là một quá trình lâu dài, gian khổ, phải trải qua nhiều bước trung gian, nhiều hình thức quá độ. Thứ ba, về văn hóa, đạo đức và các quan hê xã hội: Xã hội xã hội chủ nghĩa có trình độ ̣ phát triển cao về văn hóa, đạo đức, bảo đảm sự công bằng, hợp lý trong các quan hê xã ̣ hội. Văn hóa đạo đức phản ánh đời sống vật chất, mặc dù nó có quy luật vận động riêng. Văn hóa, đạo đức được thể hiện ở tất cả các lĩnh vực của đời sống xã hội, trước hết là ở các quan hệ xã hội. Hồ Chí Minh cho rằng sự phát triển của văn hóa và đạo đức xã hội xã hội chủ nghĩa thể hiện: xã hội không còn chế độ người bóc lột người, con người được tôn trọng, được đảm bảo đối xử công bằng, bình đẳng, các dân tộc đoàn kết, gắn bó với nhau.", "order_start": 10801, "order_end": 11843, "word_count": 241}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] i xã hội chủ nghĩa thể hiện: xã hội không còn chế độ người bóc lột người, con người được tôn trọng, được đảm bảo đối xử công bằng, bình đẳng, các dân tộc đoàn kết, gắn bó với nhau. Về quan hệ lợi ích, Hồ Chí Minh cho rằng: Chỉ có dưới chủ nghĩa xã hội mới “Chú ý xem xét những lợi ích cá nhân đúng đắn và đảm bảo cho nó được thỏa mãn”; “chỉ ở trong chế độ xã hội chủ nghĩa thì mỗi người mới có điều kiện để cải thiện đời sống riêng của minh, phát huy tính cách riêng, sở trường riêng” . Hồ Chí Minh quan niệm: Chủ nghĩa xã hội là cơ sở, là tiền đề để tiến tới chế độ xã hội hòa bình, đoàn kết, ấm no, tự do, hạnh phúc, bình đẳng, bác ái, việc làm cho mọi người và vì mọi người; không còn phân biệt chủng tộc, không còn gì có thể ngăn cản những người lao động hiểu nhau và thương yêu nhau . Trong xã hội xã hội chủ nghĩa các mối quan hệ xã hội được đảm bảo công bằng và hợp lý.", "order_start": 11843, "order_end": 12719, "word_count": 200}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] t chủng tộc, không còn gì có thể ngăn cản những người lao động hiểu nhau và thương yêu nhau . Trong xã hội xã hội chủ nghĩa các mối quan hệ xã hội được đảm bảo công bằng và hợp lý. Đó là một chế độ xã hội đem lại quyền bình đẳng trước pháp luật cho mọi công dân; các cộng đồng người đoàn kết chặt chẽ trên cở sở bính đẳng về quyền lợi và nghĩa vụ; ai cũng phải lao động và có quyền lao động , ai cũng được hưởng thành quả lao động của mình trên nguyên tắc làm nhiều thì hưởng nhiều, làm ít thì hưởng ít, không làm thì không hưởng, tất nhiên là trừ những người chưa có khả năng lao động hoặc không còn khả năng lao động Thứ tư, về chủ thể xây dựng chủ nghĩa xã hội: Chủ nghĩa xã hội là công trình tâp thể củạ nhân dân dới sự lãnh đạo của Đảng Cộng sản. Lịch sử đấu tranh giai cấp, từ xã hộ chiếm hữu nô lệ trải qua xã hội phong kiến rồi đến xã hội tư bản, những cuộc đấu tranh của nhân dân lao động diễn ra ngày càng quyết lệt nhằm thủ tiêu chế độ người bóc lột người.", "order_start": 12719, "order_end": 13686, "word_count": 218}
{"parent_id": "beda60d7-c329-4bca-ad1c-5bfc25f05951", "subject": "tutuonghcm", "section": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "title_path": "4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:", "content": "[tutuonghcm / 4) Cách mạng giải phóng dân tộc cần được tiến hành chủ động, sáng tạo và có khả năng giành thắng lợi trước cách mạng vô sản ở chính quốc:] ộ chiếm hữu nô lệ trải qua xã hội phong kiến rồi đến xã hội tư bản, những cuộc đấu tranh của nhân dân lao động diễn ra ngày càng quyết lệt nhằm thủ tiêu chế độ người bóc lột người. Trong chế độ xã hội chủ nghĩa - chế độ dân chủ nhân dân, do nhân dân làm chủ, lợi ích của cá nhân gắn liền với lợi ích của chế độ xã hội nên chính nhân dân là chủ thể, là lực lượng quyết định tốc độ xây dựng và sự vững mạnh của chủ nghĩa xã hội . Trong sự nghiệp xây dựng chủ nghĩa xã hội, Hồ Chí Minh khẳng định “Cần có sự lãnh đạo của một đảng lãnh đạo chân chính của giai cấp công nhân, toàn tâm, toàn ý phục vụ nhân dân. Chỉ có sự lãnh đạo của một đảng biết vận dụng một cách sáng tạo chủ nghĩa Mác -Lênin vào điều kiện cụ thể của nước mình thì mới có thể đưa cách mạng giải phóng dân tộc và cách mạng xã hội chủ nghĩa đến thành công” Chương 4: Tư tưởng HCM về Đảng cộng sản Việt Nam và Nhà nước của nhân dân, do nhân dân,vì dân :", "order_start": 13686, "order_end": 14601, "word_count": 210}
{"parent_id": "f458db0a-dab6-4d6e-a994-3ccacd150e3c", "subject": "tutuonghcm", "section": "1. TT HCM về những nguyên tắc xây dựng Đảng.", "title_path": "1. TT HCM về những nguyên tắc xây dựng Đảng.", "content": "[tutuonghcm / 1. TT HCM về những nguyên tắc xây dựng Đảng.] Đảng lấy chủ nghĩa Mác -Lênin làm nền tảng tư tưởng và kim chỉ nam cho hành động (nền tảng tư tưởng của Đảng Cộng sản Viêt Nam). ̣ o Để huy động được sức mạnh toàn dân thực hiện mục tiêu cách mạng: Đảng phải vững, muốn vững phải có chủ nghĩa làm cốt. o Hồ Chí Minh đã khẳng định rõ: Chủ nghĩa Mác-Lênin là lực lượng tư tưởng hùng mạnh chỉ đạo Đảng Cộng Sản Việt Nam, làm cho Đảng trở thành hình thức tổ chức cao nhất của quần chúng lao động, hiện thân của trí tuệ, danh dự và lương tâm của dân tộc Việt Nam.", "order_start": 0, "order_end": 507, "word_count": 111}
{"parent_id": "2a6e98a9-8884-40ed-b216-0a1679c1d3b7", "subject": "tutuonghcm", "section": "Nguyên tắc tâp trung dân chủ ̣", "title_path": "Nguyên tắc tâp trung dân chủ ̣", "content": "[tutuonghcm / Nguyên tắc tâp trung dân chủ ̣] o Hồ Chí Minh khẳng định đây là nguyên tắc cơ bản, xuyên suốt, bao trùm quá trình tồn tại và phát triển của Đảng. o Tập trung: Đảng phải thống nhất về tư tưởng, tổ chức và hành động.Đảng ta tuy nhiều người nhưng khi tiến đánh thì chỉ như một người.", "order_start": 0, "order_end": 248, "word_count": 53}
{"parent_id": "a1a94786-da6f-4f8a-9b0b-7485624d78b0", "subject": "tutuonghcm", "section": "- Nguyên tắc tự phê bình và phê bình", "title_path": "- Nguyên tắc tự phê bình và phê bình", "content": "[tutuonghcm / - Nguyên tắc tự phê bình và phê bình] o Hồ Chí Minh gọi đây là luật phát triển của đảng o Người đã chỉ rõ: “Muốn đoàn kết chặt chẽ trong Đảng, ắt phải thống nhất tư tưởng, mở rộng dân chủ nội bộ, mở rộng tự phê bình và phê bình” Mục đích của phê bình và tự phê bình là làm cho Đảng mạnh về chính trị - tư tưởng – tổ chức. o Hồ Chí Minh cũng chỉ rõ : Phải được tiến hành thường xuyên như người ta rửa mặt hàng ngày, phải kiên quyết, thẳng thắn, không nể nang, phải trung thực, thành khẩn, phải có tình đồng chí thương yêu lẫn nhau.", "order_start": 0, "order_end": 492, "word_count": 110}
{"parent_id": "04ab9843-5513-4825-a44b-612b70981252", "subject": "tutuonghcm", "section": "Nguyên tắc kỷ luât nghiêm minh, tự giác. ̣", "title_path": "Nguyên tắc kỷ luât nghiêm minh, tự giác. ̣", "content": "[tutuonghcm / Nguyên tắc kỷ luât nghiêm minh, tự giác. ̣] o Sức mạnh vô địch của Đảng là tinh thần kỷ luật tự giác, ý thức nghiêm minh của cán bộ, đảng viên. o Nghiêm minh là thuộc về tổ chức Đảng vì: đó là kỷ luật đối với mọi cán bộ, đảng viên, không phân biệt cán bộ lãnh đạo cao hay thấp, hay là cán bộ, đảng viên thường o Tự giác là thuộc về mỗi cán bộ, đảng viên: tuân thủ kỷ luật Đảng cũng phải tự giác, tự giác về nhiệm vụ của họ đối với Đảng. o Yêu cầu cao nhất của kỷ luật Đảng là chấp hành các chủ trương, chính sách của Đảng, các nguyên tắc tổ chức, lãnh đạo và sinh hoạt của Đảng", "order_start": 0, "order_end": 533, "word_count": 122}
{"parent_id": "d190ea09-2337-4e1b-a230-30d33f99c554", "subject": "tutuonghcm", "section": "Nguyên tắc đoàn kết, thống nhất trong Đảng.", "title_path": "Nguyên tắc đoàn kết, thống nhất trong Đảng.", "content": "[tutuonghcm / Nguyên tắc đoàn kết, thống nhất trong Đảng.] o Đoàn kết thống nhất trong Đảng không những tăng cường sức mạnh của Đảng mà còn là cơ sở đoàn kết thống nhất trong toàn dân o Đảng viên phải tu dưỡng đạo đức thường xuyên, chống chủ nghĩa cá nhân", "order_start": 0, "order_end": 196, "word_count": 42}
{"parent_id": "9b8524ac-1211-4923-a2d2-9f91f0a0d4cc", "subject": "tutuonghcm", "section": "Đảng phải liên hê mâ ̣ t thiết với nhân dân ̣", "title_path": "Đảng phải liên hê mâ ̣ t thiết với nhân dân ̣", "content": "[tutuonghcm / Đảng phải liên hê mâ ̣ t thiết với nhân dân ̣] o Đảng Cộng sản Việt Nam là một bộ phận của dân tộc Việt Nam. Mối quan hệ giữa Đảng với giai cấp và dân tộc là mối quan hệ khăng khít, gắn bó thống nhất hữu cơ với nhau. o Đảng Cộng sản Việt Nam hoạt động với mục đích: giành độc lập cho dân tộc, hạnh phúc cho nhân dân và xây dựng chủ nghĩa xã hội. o Đảng Cộng Sản Việt Nam là đội tiên phong chiến đấu không những của giai cấp công nhân mà còn là đội tiên phong chiến đấu của nhân dân lao động và của cả dân tộc", "order_start": 0, "order_end": 461, "word_count": 106}
{"parent_id": "0148fda5-9164-49d3-99c2-fc4aabd5797b", "subject": "tutuonghcm", "section": "-Đảng phải thường xuyên tự chỉnh đốn", "title_path": "-Đảng phải thường xuyên tự chỉnh đốn", "content": "[tutuonghcm / -Đảng phải thường xuyên tự chỉnh đốn] Quyền lực của Đảng do giai cấp công nhân, nhân dân lao động và toàn dân tộc giao phó.Đảng muốn vươn lên ngang tầm với nhiệm vụ lịch sử thì Đảng phải thường xuyên tự chỉnh đốn, đổi mới.", "order_start": 0, "order_end": 184, "word_count": 39}
{"parent_id": "b46cdf0b-b923-4982-9eb0-d54e57b2c7fb", "subject": "tutuonghcm", "section": "- Đoàn kết quốc tế.", "title_path": "- Đoàn kết quốc tế.", "content": "[tutuonghcm / - Đoàn kết quốc tế.] Đảng phải chú trọng giữ vững và tăng cường mối quan hệ quốc tế trong sáng Trong Di chúc, Người mong Đảng ta “sẽ ra sức hoạt động, góp phần đắc lực vào việc khôi phục lại khối đoàn kết thống nhất giữa các đảng anh em trên nền tảng của chủ nghĩa Mác - Lênin và chủ nghĩa quốc tế vô sản, có lý có tình. TTHCM về Nhà nước (Nhà nước của dân, do dân, vì dân) Thể hiện ở ba khía cạnh : 1. Nhà nước dân chủ", "order_start": 0, "order_end": 398, "word_count": 91}
{"parent_id": "14c3c77e-d634-499a-aa49-5e676f9dbe1f", "subject": "tutuonghcm", "section": "a. Bản chất giai cấp của Nhà nước", "title_path": "a. Bản chất giai cấp của Nhà nước", "content": "[tutuonghcm / a. Bản chất giai cấp của Nhà nước] Bản chất của Nhà nước ta là nhà nước dân chủ nhân dân trên nền tảng công - nông liên minh do giai cấp công nhân lãnh đạo. Bản chất giai cấp công nhân của Nhà nước ta được biểu hiện trước hết ở chỗ: Một là, Đảng Cộng sản Viêt Nam giữ vị trí và vai trò cầm quyền .Minh chứng rõ nhất ̣ .Hiến pháp năm 1959 khẳng định: “Nhà nước của ta là Nhà nước dân chủ nhân dân, dựa trên nền tảng liên minh công nông do giai cấp công nhân lãnh đạo”. Hai là, bản chất giai cấp công nhân của Nhà nước ta thể hiên ở tính định hướng xã hội ̣ chủ nghĩa của sự phát triển đất nước. Ba là, bản chất giai cấp công nhân của Nhà nước ta thể hiên ở nguyên tắc tổ chức và hoạt ̣ động cơ bản của nó là nguyên tắc tâp trung dân chủ. Các cơ quan từ Quốc hội, Chính ̣ phủ, Hội đồng nhân dân đều hoạt động theo nguyên tắc tập trung dân chủ,tất cả quyền lực thuộc về nhân dân.", "order_start": 0, "order_end": 841, "word_count": 190}
{"parent_id": "14c3c77e-d634-499a-aa49-5e676f9dbe1f", "subject": "tutuonghcm", "section": "a. Bản chất giai cấp của Nhà nước", "title_path": "a. Bản chất giai cấp của Nhà nước", "content": "[tutuonghcm / a. Bản chất giai cấp của Nhà nước] của nó là nguyên tắc tâp trung dân chủ. Các cơ quan từ Quốc hội, Chính ̣ phủ, Hội đồng nhân dân đều hoạt động theo nguyên tắc tập trung dân chủ,tất cả quyền lực thuộc về nhân dân. Bản chất giai cấp công nhân thống nhất với tính nhân dân, tính dân tộc được thể hiện ở các quan điểm sau: Một là, Nhà nước dân chủ mới của ta là kết quả đấu tranh gian khổ, lâu dài với sự hy sinh của nhiều thế hê người Viê ̣ t Nam yêu nước ̣ Hai là, Nhà nước ta bảo vê lợi ích của nhân dân, lấy lợi ích dân tộc làm nền tảng..̣ Ba là, Nhà nước mới vừa ra đời đã đảm nhân nhiê ̣ m vụ lịch sử giao phó ̣", "order_start": 841, "order_end": 1421, "word_count": 136}
{"parent_id": "07a411bb-bdc7-4283-b680-84fddb7dd4d9", "subject": "tutuonghcm", "section": "b. Nhà nước của nhân dân", "title_path": "b. Nhà nước của nhân dân", "content": "[tutuonghcm / b. Nhà nước của nhân dân] .Hồ Chí Minh đã khẳng định: “Trong nhà nước Việt Nam dân chủ cộng hòa của chúng ta, tất cả mọi quyền lực đều là của nhân dân”1 Trong Điều 1 Hiến pháp 1946 khẳng định: “Nước Viêt Nam là một nước dân chủ cộng hoà, tất cả ̣ quyền bính trong nước là của toàn thể nhân dân Viêt Nam, không phân biê ̣ t nòi giống, gái trai, ̣ giàu nghèo, giai cấp, tôn giáo”. . Nhân dân thực thi quyền lực của mình thông qua hai hình thức dân chủ :dân chủ trực tiếp và dân chủ gián tiếp. Nhân dân có quyền kiểm soát, phê bình nhà nước, có quyền bãi miễn những đại biểu mà họ đã lựa chọn, bầu ra và có quyền giải tán những thiết chế quyền lực mà họ đã lâp nên ̣ . . Hồ Chí Minh chỉ rõ: Một nhà nước thật sự của dân, là một nhà nước, luôn “mong đồng bào giúp đõ, đôn đốc, kiểm soát và phê bình để làm tròn nhiệm vụ của mình là người đầy tớ thật trung thành và tận tụy của nhân dân”1 , thậm chí “nếu Chính phủ làm hại dân thì dân có quyền đuổi Chính phủ”. Luât pháp dân chủ và là công cụ quyền lực của nhân dân ̣ .", "order_start": 0, "order_end": 988, "word_count": 224}
{"parent_id": "07a411bb-bdc7-4283-b680-84fddb7dd4d9", "subject": "tutuonghcm", "section": "b. Nhà nước của nhân dân", "title_path": "b. Nhà nước của nhân dân", "content": "[tutuonghcm / b. Nhà nước của nhân dân] đầy tớ thật trung thành và tận tụy của nhân dân”1 , thậm chí “nếu Chính phủ làm hại dân thì dân có quyền đuổi Chính phủ”. Luât pháp dân chủ và là công cụ quyền lực của nhân dân ̣ .Trong nhà nước của nhân dân thì dân là chủ, người dân được hưởng mọi quyền dân chủ, nghĩa là có quyền làm bất cứ việc gì mà pháp luật không cấm và có nghĩa vụ tuân theo pháp luật.", "order_start": 988, "order_end": 1347, "word_count": 81}
{"parent_id": "0e472327-6942-4836-897e-2f5c9517ff96", "subject": "tutuonghcm", "section": "c. Nhà nước do nhân dân", "title_path": "c. Nhà nước do nhân dân", "content": "[tutuonghcm / c. Nhà nước do nhân dân] Đó là nhà nước do dân lựa chọn, bầu ra những đại biểu của mình,nhà nước đó do dân ủng hộ, giúp đỡ, đóng thuế để nhà nước chi tiêu, hoạt động; nhà nước đó lại do dân phê bình, xây dựng Nhà nước do dân, nhân dân tham gia quản lý được thể hiện trên các nội dung sau : Công dân tham gia bầu cử ra Quốc hội- cơ quan quyền lực cao nhất của xã hội, cơ quan lập pháp Mọi công việc của bộ máy nhà nước trong việc quản lý xã hội đều thực hiện ý chí của nhân dân. d. Nhà nước vì nhân dân Đó là nhà nước phục vụ cho lợi ích và nguyện vọng chính đáng của nhân dân, ngoài ra không vì bất cứ một lợi ích nào khác. Đó là một nhà nước không có đặc quyền, đặc lợi, thực sự trong sạch, cần, kiệm, liêm, chính: Trong Di chúc, Bác Hồ nhắc nhở cán bộ, Đảng viên phải làm thế nào để xứng đáng: .Là người đầy tớ trung thành, tận tụy, cần, kiệm, liêm, chính, chí công vô tư, lo trước thiên hạ, vui sau thiên hạ.", "order_start": 0, "order_end": 886, "word_count": 200}
{"parent_id": "0e472327-6942-4836-897e-2f5c9517ff96", "subject": "tutuonghcm", "section": "c. Nhà nước do nhân dân", "title_path": "c. Nhà nước do nhân dân", "content": "[tutuonghcm / c. Nhà nước do nhân dân] Bác Hồ nhắc nhở cán bộ, Đảng viên phải làm thế nào để xứng đáng: .Là người đầy tớ trung thành, tận tụy, cần, kiệm, liêm, chính, chí công vô tư, lo trước thiên hạ, vui sau thiên hạ. Là người lãnh đạo thì phải có trí tuệ hơn người, minh mẫn sáng suốt, nhìn xa trông rộng, gần gũi nhân dân, trọng dụng hiền tài", "order_start": 886, "order_end": 1193, "word_count": 66}
{"parent_id": "3e3486de-506a-4819-82b2-4ae60f916c29", "subject": "tutuonghcm", "section": "a. Nhà nước hợp pháp, hợp hiến", "title_path": "a. Nhà nước hợp pháp, hợp hiến", "content": "[tutuonghcm / a. Nhà nước hợp pháp, hợp hiến] HCM Người đã sớm nhận thức tầm quan trọng của Hiến pháp và pháp luật trong đời sống chính trị xã hội.Vì vậy ngay sau khi giành được chính quyền , Hồ Chí Minh đã thay mặt Chính phủ lâm thời đọc bản Tuyên ngôn độc lập, tuyên bố với quốc dân đồng bào và thế giới về sự khai sinh của nước Việt Nam dân chủ cộng hoà mới, qua đó biểu dương lực lượng và ý chí của toàn thể dân tộc Việt Nam quyết tâm giữ vững nền tự do, độc lập của mình. Trong phiên họp đầu tiên của chính phủ . Người đã đề nghị Chính phủ tổ chức càng sớm càng hay cuộc Tổng tuyển cử với chế độ phổ thông đầu phiếu.Sau đó là lập ra các tổ chức, bộ máy, phê chuẩn các chức vụ chính thức của nhà nước Từ đó Chính phủ nước Việt Nam dân chủ cộng hòa là chính phủ có đầy đủ tư cách pháp lý để giải quyết những vấn đề đối nội, đối ngoại của nhà nước Việt Nam dân chủ cộng hòa.", "order_start": 0, "order_end": 830, "word_count": 188}
{"parent_id": "0644101c-cda0-4462-a880-34db1be14896", "subject": "tutuonghcm", "section": "b. Nhà nước thượng tôn pháp luâṭ", "title_path": "b. Nhà nước thượng tôn pháp luâṭ", "content": "[tutuonghcm / b. Nhà nước thượng tôn pháp luâṭ] Trong tư tưởng Hồ Chí Minh, nhà nước quản lý xã hội bằng Hiến pháp và Pháp luật. Vì vậy:  Hồ Chí Minh chú trọng đưa pháp luật vào trong đời sống, đảm bảo cho pháp luật được thi hành và có cơ chế giám sát việc thi hành pháp luật. Nêu cao tính nghiêm minh của pháp luật.", "order_start": 0, "order_end": 269, "word_count": 60}
{"parent_id": "e3388415-b8ba-4d34-b1be-6c2756e3cb74", "subject": "tutuonghcm", "section": "c. Pháp quyền nhân nghĩa", "title_path": "c. Pháp quyền nhân nghĩa", "content": "[tutuonghcm / c. Pháp quyền nhân nghĩa] Pháp quyền nhân nghĩa trước hết theo Hồ Chí Minh là Nhà nước phải tôn trọng, bảo đảm thực hiện đầy đủ các quyền con người, chăm lo đến lợi ích của mọi người. Pháp quyền nhân nghĩa còn được thể hiện ở tính nhân văn, khuyến thiện: oNgay khi Chính phủ nước Việt Nam dân chủ cộng hòa ra đời, đã lập tức tuyên bố xóa bỏ mọi luật pháp hà khắc của chính quyền thực dân phản động, bảo vệ những quyền cơ bản của con người. oLuật pháp của Nhà nước mới ra đời đã ghi nhận đầy đủ và bảo vệ quyền con người; thể hiện ở tính nghiêm minh nhưng khách quan và công bằng trong việc thực thi pháp luật, chống đối xử một cách dã man với con người. oTính nhân văn còn thể hiện ngay trong cách đối xử với những kẻ phản bội Tổ quốc, phản bội nhân dân. 3.", "order_start": 0, "order_end": 731, "word_count": 159}
{"parent_id": "e3388415-b8ba-4d34-b1be-6c2756e3cb74", "subject": "tutuonghcm", "section": "c. Pháp quyền nhân nghĩa", "title_path": "c. Pháp quyền nhân nghĩa", "content": "[tutuonghcm / c. Pháp quyền nhân nghĩa] g trong việc thực thi pháp luật, chống đối xử một cách dã man với con người. oTính nhân văn còn thể hiện ngay trong cách đối xử với những kẻ phản bội Tổ quốc, phản bội nhân dân. 3. Nhà nước trong sạch, vững mạnh", "order_start": 731, "order_end": 942, "word_count": 46}
{"parent_id": "641cf4f1-f400-4161-8160-ea9f08c10eb2", "subject": "tutuonghcm", "section": "a.Kiểm soát quyền lực nhà nước", "title_path": "a.Kiểm soát quyền lực nhà nước", "content": "[tutuonghcm / a.Kiểm soát quyền lực nhà nước] Giữ vững bản chất Nhà nước, đảm bảo nhà nước hoạt động có hiệu, thực hiện quyền lực thuộc về nhân dân. Nhân dân có quyền kiểm soát quyền lực nhà nước.", "order_start": 0, "order_end": 150, "word_count": 32}
{"parent_id": "41367d9f-f8c9-49ce-b332-2ca225a4a322", "subject": "tutuonghcm", "section": "b. Phòng chống tiêu cực trong nhà nước", "title_path": "b. Phòng chống tiêu cực trong nhà nước", "content": "[tutuonghcm / b. Phòng chống tiêu cực trong nhà nước] Đặc quyền, đặc lợi  Tham ô, lãng phí, quan liêu Tư túng, chia rẽ, kiêu ngạo - Phòng, chống tiêu cực trong bộ máy nhà nước là rất khó khăn, nó là công việc phải tiến hành thường xuyên, lâu dài.Hồ Chí Minh đã nêu lên những biện pháp khác nhau, trong những thời điểm khác nhau. Khái quát lại, có thể thấy một số biện pháp nổi bật sau: .Nâng cao trình độ làm chủ trong xã hội, thực hành dân chủ rộng rãi, phát huy quyền làm chủ của nhân dân. Đây là biện pháp căn bản có ý ngĩa lâu dài. Pháp luật của Nhà nước, kỷ luật của Đảng phải nghiêm minh. Công tác kiểm tra phải thường xuyên. Cán bộ, đảng viên phải nghiêm túc và tự giác tuân thủ pháp luật, kỷ luật. Phạt nghiêm minh, nghiêm khắc, đúng người, đúng tội cần thiết, song việc gì cũng xử phạt lại không đúng. Cần coi trọng giáo dục, lấy giáo dục cảm hóa làm chủ yếu. Cán bộ phải đi trước làm gương, cán bộ giữ chức vụ càng cao, trách nhiệm nêu gương càng lớn. Cán bộ, người đứng đầu có ý thức nêu gương tu dưỡng đạo đức, chống tiêu cực, sẽ có tác động rất mạnh mẽ đến cấp dưới, đến nhân dân, góp phần gây nên những đức tính tốt trong nhâ dân.", "order_start": 0, "order_end": 1091, "word_count": 234}
{"parent_id": "41367d9f-f8c9-49ce-b332-2ca225a4a322", "subject": "tutuonghcm", "section": "b. Phòng chống tiêu cực trong nhà nước", "title_path": "b. Phòng chống tiêu cực trong nhà nước", "content": "[tutuonghcm / b. Phòng chống tiêu cực trong nhà nước] n bộ, người đứng đầu có ý thức nêu gương tu dưỡng đạo đức, chống tiêu cực, sẽ có tác động rất mạnh mẽ đến cấp dưới, đến nhân dân, góp phần gây nên những đức tính tốt trong nhâ dân. Đây chính là nét đức sức trong văn hóa chính trị Việt Nam .Phải huy động sức mạnh chủ nghĩa yêu nước vào cuộc chiến chống lại tiêu cực trong con người, trong xã hội và trong bộ máy nhà nước. Bất kể người Việt Nam nào có lòng yêu nước đều phải có trách nhiệm tư dưỡng và tực hành đạo đức cách mạng, góp phần xây dựng nhà nước trong sạch, vững mạnh. iChương 5: Tư tưởng HCM về đoàn kết dân tộc và đoàn kết quốc tế TTHCM về đoàn kết dân tộc (hình thức, nguyên tắc tổ chức của khối đại đoàn kết toàn dân tộc - Mặt trận Dân tộc thống nhất) và vận dụng trong giai đoạn hiện nay. Hình thức của khối đại đoàn kết toàn dân tộc - Mặt trận Dân tộc thống nhất •Đại đoàn kết dân tộc phải biến thành sức mạnh vật chất, trở thành lực lượng vật chất có tổ chức Tổ chức đó là mặt trận dân tộc thống nhất.", "order_start": 1091, "order_end": 2059, "word_count": 214}
{"parent_id": "41367d9f-f8c9-49ce-b332-2ca225a4a322", "subject": "tutuonghcm", "section": "b. Phòng chống tiêu cực trong nhà nước", "title_path": "b. Phòng chống tiêu cực trong nhà nước", "content": "[tutuonghcm / b. Phòng chống tiêu cực trong nhà nước] àn dân tộc - Mặt trận Dân tộc thống nhất •Đại đoàn kết dân tộc phải biến thành sức mạnh vật chất, trở thành lực lượng vật chất có tổ chức Tổ chức đó là mặt trận dân tộc thống nhất. •Sức mạnh của toàn dân tộc chỉ có được khi được tập hợp, tổ chức thành một khối vững chắc được giác ngộ về mục tiêu chiến đấu chung và hoạt động theo đường lối chính trị đúng đắn trong mặt trận dân tộc thống nhất.. •Mặt trận dân tộc thống nhất có các tên gọi qua các thời kỳ như sau:  1930 Hội phản đế đồng minh  1936 : Mặt trận Dân chủ  1939 : Mặt trận nhân dân phản đế 1941 : Mặt trận Việt Minh 1951 : Mặt trận Liên Việt  1960: Mặt trận dân tộc giải phóng miền Nam Việt Nam √✓ 1955,1976 : Mặt trận Tổ quốc Việt Nam Nguyên tắc xây dựng và hoạt động của Mặt trân dân tộc thống nhất ̣ 1.Mặt trân dân tộc thống nhất phải được xây dựng trên nền tảng khối liên minh công - ̣ nông - trí thức, đặt dưới sự lãnh đạo của Đảng.", "order_start": 2059, "order_end": 2962, "word_count": 204}
{"parent_id": "41367d9f-f8c9-49ce-b332-2ca225a4a322", "subject": "tutuonghcm", "section": "b. Phòng chống tiêu cực trong nhà nước", "title_path": "b. Phòng chống tiêu cực trong nhà nước", "content": "[tutuonghcm / b. Phòng chống tiêu cực trong nhà nước] à hoạt động của Mặt trân dân tộc thống nhất ̣ 1.Mặt trân dân tộc thống nhất phải được xây dựng trên nền tảng khối liên minh công - ̣ nông - trí thức, đặt dưới sự lãnh đạo của Đảng. • Lấy liên minh công nông làm nền tảng Phải thấy vai trò và sự cần thiết phải liên minh với các giai cấp khác, nhất là với đội ngũ trí thức Đặt dưới sự lãnh đạo của Đảng Đảng Cộng sản Việt Nam vừa là thành viên, vừa là lực lượng lãnh đạo, Đảng không có lợi ích riêng, mà gắn liền với lợi ích toàn xã hội, toàn dân tộc. Đảng lãnh đạo đối với mặt trận thể hiện ở khả năng nắm bắt thực tiễn, phát hiện ra quy luật khách quan sự vận động của lịch sử để vạch đường lối và phương pháp Cách mạng phù hợp.", "order_start": 2962, "order_end": 3640, "word_count": 153}
{"parent_id": "41367d9f-f8c9-49ce-b332-2ca225a4a322", "subject": "tutuonghcm", "section": "b. Phòng chống tiêu cực trong nhà nước", "title_path": "b. Phòng chống tiêu cực trong nhà nước", "content": "[tutuonghcm / b. Phòng chống tiêu cực trong nhà nước] . Đảng lãnh đạo đối với mặt trận thể hiện ở khả năng nắm bắt thực tiễn, phát hiện ra quy luật khách quan sự vận động của lịch sử để vạch đường lối và phương pháp Cách mạng phù hợp. Lãnh đạo Mặt trận hoàn thành nhiệm vụ của mình là đấu tranh giải phóng dân tộc và giả phóng giai cấp, kết hợp độc lập dân tộc với chủ nghĩa xã hội", "order_start": 3640, "order_end": 3967, "word_count": 74}
{"parent_id": "53b7bddd-0d3d-4e2c-b0c9-d6bbb93004e9", "subject": "tutuonghcm", "section": "2. Mặt trân dân tộc thống nhất hoạt động theo nguyên tắc hiê ̣ p thương dân chủ, bảo đảm ̣ đoàn kết ngày càng rộng rãi và bền vững", "title_path": "2. Mặt trân dân tộc thống nhất hoạt động theo nguyên tắc hiê ̣ p thương dân chủ, bảo đảm ̣ đoàn kết ngày càng rộng rãi và bền vững", "content": "[tutuonghcm / 2. Mặt trân dân tộc thống nhất hoạt động theo nguyên tắc hiê ̣ p thương dân chủ, bảo đảm ̣ đoàn kết ngày càng rộng rãi và bền vững] Mặt trận dân tộc thống nhất là tổ chức chính trị - xã hội rộng lớn của cả dân tộc, bao gồm nhiều giai cấp, tầng lớp, dân tộc, tôn giáo khác nhau. Hoạt động của Mặt trận phải dựa trên nguyên tắc hiệp thương dân chủ Mọi vấn đề của Mặt trận đều phải được đem ra để tất cả các thành viên cùng nhau bàn bạc công khai, để đi đến nhất trí, loại trừ mọi sự áp đặt hoặc dân chủ hình thức Những lợi ích riêng chính đáng, phù hợp với lợi ích chung cần được tôn trọng, riêng biệt, không phù hợp sẽ giải quyết bằng lợi ích chung, bằng sự nhận thức ngày càng đúng đắn hơn về mối quan hệ giữa lợi ích chung và lợi ích riêng", "order_start": 0, "order_end": 608, "word_count": 135}
{"parent_id": "7b2ef834-333b-4bfb-96f5-2b6a8ac1ba91", "subject": "tutuonghcm", "section": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "title_path": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "content": "[tutuonghcm / 3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.] Trong Mặt trận, các thành viên có những điểm tương đồng nhưng cũng có những điểm khác biệt, nên cần có sự bàn bạc để đi đến nhất trí. • Đoàn kết thực sự nghĩa là vừa đoàn kết, vừa đấu tranh, học cái tốt của nhau, phê bình cái sai của nhau và phê bình trên lập trường thân ái, vì nước, vì dân TTHCM về đoàn kết dân tộc vận dụng trong giai đoạn hiện nay. a) Quán triệt tư tưởng Hồ Chí Minh về đại đoàn kết toàn dân tộc và đoàn kết quốc tế trong hoạch định chủ trương, đường lối của Đảng. Về đại đoàn kết toàn dân tộc, Đảng Cộng sản Việt Nam nhận thức tầm quan trọng của vấn đề đại đoàn kết toàn dân tộc qua các văn bản: • Nghị quyết 07/NQ-TW Đại hội Đảng lần thứ VIII (1996), IX (2001), X (2006), XI (2011) Đại hội Đảng lần thứ XII (2016) • Đại hội Đảng lần thứ XIII (2021) Về đoàn kết quốc tế, Đảng ta vận dụng sáng tạo tư tưởng đoàn kết quốc tế của chủ tịch HCM trong việc hoạch định chủ trương, đường lối: • Đại hội VII: Tuyên bố “muốn là bạn” • Đại hội VII: “Sẵn sàng là bạn” • Đại hội IX: “Là bạn và đối tác tin cậy” Đại hội XII: “Quan hệ đối ngoại, hội nhập quốc tế ngày càng sâu rộng, có hiệu qu", "order_start": 0, "order_end": 1100, "word_count": 244}
{"parent_id": "7b2ef834-333b-4bfb-96f5-2b6a8ac1ba91", "subject": "tutuonghcm", "section": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "title_path": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "content": "[tutuonghcm / 3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.] : Tuyên bố “muốn là bạn” • Đại hội VII: “Sẵn sàng là bạn” • Đại hội IX: “Là bạn và đối tác tin cậy” Đại hội XII: “Quan hệ đối ngoại, hội nhập quốc tế ngày càng sâu rộng, có hiệu quả. Vị thế, uy tín quốc tế của nước ta tiếp tục được nâng cao” Qua hơn 35 năm đổi mới, tư tưởng Hồ Chí Minh về đại đoàn kết dân tộc được Đảng Cộng sản Việt Nam vận dụng một cách sáng tạo trong quá trình xây dựng khối đại đoàn kết toàn dân tộc.Từ tuyên bố “muốn làm bạn” (Đại hội XII) đến “sẵn sàng làm bạn” (Đại hội XIII). Từ quan điểm “là bạn và đối tác tin cậy” của Đại hội IX đến khẳng định của Đại hội XII; “Quan hệ đối ngoại, hội nhập quốc tế ngày càng sâu rộng, có hiệu quả. Vị thế, uy tín của nước ta tiếp tục được nâng cao”.2 Tinh thần đoàn kết quốc tế, huy động tối đa sức mạnh đoàn kết toàn dân tộc kết hợp với sức mạnh thời đại để đảm bảo lợi ích quốc gia, giữ vững độc lập, tự chủ, vì hòa bình, hữu nghị, hợp tác và phát triển.", "order_start": 1100, "order_end": 2018, "word_count": 209}
{"parent_id": "7b2ef834-333b-4bfb-96f5-2b6a8ac1ba91", "subject": "tutuonghcm", "section": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "title_path": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "content": "[tutuonghcm / 3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.] ế, huy động tối đa sức mạnh đoàn kết toàn dân tộc kết hợp với sức mạnh thời đại để đảm bảo lợi ích quốc gia, giữ vững độc lập, tự chủ, vì hòa bình, hữu nghị, hợp tác và phát triển. b) Xây dựng khối đại đoàn kết toàn dân tộc trên nền tảng liên minh công - nông - trí dưới sự lãnh đạo của Đảng Tư tưởng đại đoàn kết toàn dân tộc → trở thành quan điểm xuyên suốt đường lối chiến lược của Đảng Cộng sản Việt Nam . Thực tiễn lịch sử cũng chứng minh rằng, Mặt trận dân tộc thống nhất càng rộng rãi thì sức mạnh của khối liên minh công - nông - trí càng tăng, sự lãnh đạo của Đảng càng vững chắc, đồng thời khối liên minh giai cấp, tầng lớp càng được củng cố, sự lãnh đạo của Đảng càng được tăng cường thì Mặt trận dân tộc thống nhất càng được mở rộng và sức mạnh khối đại đoàn kết dân tộc càng được nhân lên gấp bội Theo Người, đoàn kết làm nên sức mạnh và là cội nguồn của mọi thành công: “Đoàn kết là một lực lượng vô địch của chúng ta để khắc phục khó khăn, giành lấy thắng lợi”; “Đoàn kết, đoàn kết, đại đoàn kết; Thành công, thành công, đại thành công” Đại hội XIII của Đảng nhận định “Mặt trận Tổ quố", "order_start": 2018, "order_end": 3118, "word_count": 242}
{"parent_id": "7b2ef834-333b-4bfb-96f5-2b6a8ac1ba91", "subject": "tutuonghcm", "section": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "title_path": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "content": "[tutuonghcm / 3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.] ủa chúng ta để khắc phục khó khăn, giành lấy thắng lợi”; “Đoàn kết, đoàn kết, đại đoàn kết; Thành công, thành công, đại thành công” Đại hội XIII của Đảng nhận định “Mặt trận Tổ quốc Việt Nam và các đoàn thể nhân dân có đổi mới cả về nội dung và phương thức hoạt động; phát huy ngày càng tốt hơn vai trò tập hợp, xây dựng khối đại đoàn kết toàn dân tộc; cùng Đảng, Nhà nước chăm lo, bảo vệ quyền và lợi ích hợp pháp, chính đáng của nhân dân; tham gia xây dựng Đảng, quản lý nhà nước, quản lý xã hội; thường xuyên tổ chức các cuộc vận động, phong trào thi đua yêu nước, góp phần tích cực vào những thành tựu chung của đất nước”.  Để tăng cường sức mạnh khối đại đoàn kết toàn dân tộc cần tập trung các vấn đề: Đẩy mạnh tuyên truyền để các cấp, ngành, lực lượng nhận thức về sự cần thiết phải tăng cường khối đại đoàn kết toàn dân tộc. Tăng cường sự lãnh đạo của Đảng, quản lý nhà nước và thể chế hóa đường lối chính sách của Đảng về đại đoàn kết toàn dân tộc.  Giải quyết tốt quan hệ lợi ích giữa các giai cấp; kết hợp lợi ích cá nhân, lợi ích tập thể và lợi ích toàn xã hội.", "order_start": 3118, "order_end": 4193, "word_count": 235}
{"parent_id": "7b2ef834-333b-4bfb-96f5-2b6a8ac1ba91", "subject": "tutuonghcm", "section": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "title_path": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "content": "[tutuonghcm / 3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.] hóa đường lối chính sách của Đảng về đại đoàn kết toàn dân tộc.  Giải quyết tốt quan hệ lợi ích giữa các giai cấp; kết hợp lợi ích cá nhân, lợi ích tập thể và lợi ích toàn xã hội. Tăng cường mối quan hệ giữa nhân dân với Đảng, Nhà nước. Kiên quyết đấu tranh với quan điểm sai trái, thù địch, phá hoại, chia rẽ. c) Đại đoàn kết toàn dân tộc phải kết hợp với đoàn kết quốc tế. Trong bối cảnh quốc tế hiện nay, phải tiếp tục phát triển tư tưởng Hồ Chí Minh để tăng cường sức mạnh nội lực. • Coi cách mạng Việt Nam là một bộ phận của cách mạng thế giới. • Ủng hội đoàn kết, ủng hộ các phong trào cách mạng, các xu hướng và trào lưu tiến bộ của thời đại. Các chủ trương nhằm nâng cao hiệu quả hợp tác quốc tế, chủ động hội nhập kinh tế: Nêu cao nguyên tắc độc lập, tự chủ, tự cường Phát huy mạnh mẽ sức mạnh dân tộc, sức mạnh của khối đại doàn kết dân tộc • Tranh thủ sự đồng tình ủng hộ rộng rãi của các lực lượng bên ngoài.", "order_start": 4193, "order_end": 5114, "word_count": 207}
{"parent_id": "7b2ef834-333b-4bfb-96f5-2b6a8ac1ba91", "subject": "tutuonghcm", "section": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "title_path": "3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.", "content": "[tutuonghcm / 3. Mặt trân dân tộc thống nhất là khối đoàn kết chặt ch攃̀, lâu dài, đoàn kết thâ ̣ t sự, châṇ thành, thân ái giúp nhau cùng tiến bộ.] nguyên tắc độc lập, tự chủ, tự cường Phát huy mạnh mẽ sức mạnh dân tộc, sức mạnh của khối đại doàn kết dân tộc • Tranh thủ sự đồng tình ủng hộ rộng rãi của các lực lượng bên ngoài. Để nâng cao hiệu quả kết hợp sức mạnh dân tốc và sức mạnh thời đại: • Xác định rõ mục tiêu của đoàn kết là để thực hiện mục tiêu dân giàu, nước mạnh, dân chủ, công bằng, văn minh. • Mở cửa, hội nhập quốc tế, tham gia những vấn đề toàn cầu. • Nêu cao tinh thần độc lập, tự chủ, tự cường, kết hợp sức mạnh dân tốc với sức mạnh thời đại. Xây dựng Đảng trong sạch, vững mạnh; đổi mới và chỉnh đốn Đảng, nâng cao năng lực lãnh đạo và sức chiến đấu của Đảng. Chương 6: Tư tưởng HCM về văn hóa, đạo đức và con người TTHCM về khái niệm văn hóa và vai trò của văn hóa 1.Một số nhận thức chung về văn hóa và quan hệ giữa văn hóa với các lĩnh vực khác.", "order_start": 5114, "order_end": 5936, "word_count": 187}
{"parent_id": "0f4d5306-5d02-4180-a5b8-6cac7efbba1e", "subject": "tutuonghcm", "section": "a. Quan niêm của Hồ Chí Minh về văn hóa ̣", "title_path": "a. Quan niêm của Hồ Chí Minh về văn hóa ̣", "content": "[tutuonghcm / a. Quan niêm của Hồ Chí Minh về văn hóa ̣] Hồ chí Minh đưa ra định nghĩa về văn hóa: “Vì lẽ sinh tồn cũng như mục đích của cuộc sống, loài người mới phát minh ra ngôn ngữ, chữ viết, đạo đức, pháp luật,khoa học, tôn giáo, văn học, nghệ thuật, những công cụ cho sinh hoạt hẵng ngày về mặc,ăn, ở và các phương thức sử dụng. Toàn bộ những sáng tạo và phát minh đó tức là văn hóa. Văn hóa là tổng hợp mọi phương thức sinh hoạt cùng với biểu hiện của nó mà loài người đã sản sinh ra nhằm thích ứng những nhu cầu đời sống và đòi hỏi của sự sinh tồn”", "order_start": 0, "order_end": 499, "word_count": 110}
{"parent_id": "3288b8c3-c77a-4b47-a0b8-a34d11b6312b", "subject": "tutuonghcm", "section": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "title_path": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "content": "[tutuonghcm / b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣] Quan hê giữa văn hóa với xã hội ̣ : Hồ Chí Minh cho rằng xã hội nào thì văn hóa ấy. Xã hội bị nô lệ thì văn hóa cũng bị nô dịch, xã hội được giải phóng thì văn hóa được mở đường phát triển. Khi cách mạng giải phóng dân tộc thành công, nước nhà độc lập thì văn hóa được giải phóng Quan hê giữa văn hóa với chính tri: ̣ Hồ Chí Minh quan niệm trong xã hội có bốn lĩnh vực có mối quan hệ mật thiết với nhau là kinh tế, chính trị, văn hóa, xã hội. Chính trị chưa được giải phóng, thì văn hóa còn bị nô dịch. Ngược lại, văn hoá phải ở trong chính trị, có nghĩa là văn hoá phải tham gia thực hiện những nhiệm vụ chính trị, góp phần giành độc lập dân tộc, củng cố, bảo vệ vai trò của chính quyền nhà nước trong quá trình thực hiện nhiệm vụ chính trị. Quan hê giữa văn hóa với kinh tê: ̣ kinh tế thuộc về cơ sở hạ tầng , Văn hóa thuộc kiến trúc thượng tầng. Cơ sở hạ tầng quyết định kiến trúc thượng tầng, đời sống vật chất quyết định đời sống văn hóa . Văn hoá phải ở trong kinh tế và chính trị, có nghĩa là văn hoá phải tham gia thực hiện những nhiệm vụ chính trị, thúc đẩy xây dựng, phát triển kinh tế.", "order_start": 0, "order_end": 1096, "word_count": 247}
{"parent_id": "3288b8c3-c77a-4b47-a0b8-a34d11b6312b", "subject": "tutuonghcm", "section": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "title_path": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "content": "[tutuonghcm / b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣] uyết định đời sống văn hóa . Văn hoá phải ở trong kinh tế và chính trị, có nghĩa là văn hoá phải tham gia thực hiện những nhiệm vụ chính trị, thúc đẩy xây dựng, phát triển kinh tế. Văn hoá phải ở trong kinh tế và chính trị, điều đó cũng có nghĩa kinh tế và chính trị cũng phải có tính văn hoá, điều mà chủ nghĩa xã hội và thời đại đang đòi hỏi. Về giữ gìn bản sắc văn hóa dân tộc, tiếp thu văn hóa nhân loại: Bản sắc văn hóa dân tộc là những giá trị văn hóa bền vững tồn tại trong suốt quá trình lịch sử của cộng đồng dân tộc Việt Nam. :theo người “dân ta phải biết sử ta, cho tường gốc tích nước nhà Việt Nam”, Muốn giữ gìn bản sắc văn hóa dân tộc thì cũng phải vận dụng quy luật của văn hóa, Hồ Chí Minh có chủ đích tiếp thu tinh hoa văn hóa nhân loại là để làm giàu văn hóa Việt Nam, xây dựng nền văn hóa phù hợp với tinh thần dân chủ, cái gì tốt thì học để bổ xung vào cái gốc của giá trị văn hóa dân tộc. 2. Quan điểm của Hồ Chí Minh về vai trò của văn hóa. a.", "order_start": 1096, "order_end": 2061, "word_count": 223}
{"parent_id": "3288b8c3-c77a-4b47-a0b8-a34d11b6312b", "subject": "tutuonghcm", "section": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "title_path": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "content": "[tutuonghcm / b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣] , xây dựng nền văn hóa phù hợp với tinh thần dân chủ, cái gì tốt thì học để bổ xung vào cái gốc của giá trị văn hóa dân tộc. 2. Quan điểm của Hồ Chí Minh về vai trò của văn hóa. a. Văn hóa là mục tiêu, động lực của sự nghiêp cách mạng ̣ Văn hoá là mục tiêu : Hồ Chí Minh xác định mục tiêu của cách mạng Việt Nam là đấu tranh giành độc lập dân tộc và đi lên chủ nghĩa xã hội . Chủ nghĩa xã hội được xây dựng trên các lĩnh vực kinh tế, chính trị, văn hóa, xã hội => Văn hoá là một trong các mục tiêu chung của tiến trình cách mạng Việt Nam. Văn hoá là động lực : Trong tư tưởng Hồ Chí Minh động lực thúc đẩy phát triển đất nước bao gồm động lực vật chất và động lực tinh thần.... tiếp cận động lực phát triển đất nước dưới góc độ văn hóa có thể tiếp cận trên những phương diện sau đây: Văn hóa chính trị là yếu tố có ý nghĩa soi đường cho quốc dân đi, lãnh đạo quốc dân thực hiện độc lập, tự chủ, tự cường. Văn hóa giáo dục diệt giặc dốt, giúp con người hiểu biết những quy luật của tự nhiên, xã hội và tư duy, vương lên làm chủ tự nhiên xã hội và bản thân mình .", "order_start": 2061, "order_end": 3122, "word_count": 246}
{"parent_id": "3288b8c3-c77a-4b47-a0b8-a34d11b6312b", "subject": "tutuonghcm", "section": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "title_path": "b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣", "content": "[tutuonghcm / b. Quan điểm của Hồ Chí Minh về mối quan hê giữa văn hóa với các lĩnh vực khác ̣] lập, tự chủ, tự cường. Văn hóa giáo dục diệt giặc dốt, giúp con người hiểu biết những quy luật của tự nhiên, xã hội và tư duy, vương lên làm chủ tự nhiên xã hội và bản thân mình .Xây dựng nguồn nhân lực chất lượng cao, đội ngũ cán bộ phục vụ sự nghiệp xây dựng và bảo vệ Tổ quốc. Văn hóa văn nghệ góp phần giáo dục lòng yêu nước, lý tưởng cách mạng, sự lạc quan, ý chí, quyết tâm và niềm tin vào sự thắng lợi của sự nghiệp cách mạng. Văn hóa đạo đức, lối sống nâng cao phẩm giá, phong cách lành mạnh cho con người, hướng con người tới các giá trị vĩnh hằng của nhân loại: chân - thiện – mỹ. Hồ Chí Minh quan niệm đạo đức là gốc của con người, của người cách mạng Văn hóa pháp luật bảo đảm cho xã hội thượng tôn pháp luật, dân chủ được phát huy, trật tự, kỷ cương phép nước được giữ vững. => để đi đến khẳng định văn hóa là động lực thúc đẩy sự phát triển của cách mạng đi đến những thành công trong sự nghiệp cách mạng.", "order_start": 3122, "order_end": 4041, "word_count": 203}
{"parent_id": "16e0ae40-0e93-4226-98bd-b5eb96e6fb8b", "subject": "tutuonghcm", "section": "b. Văn hóa là một mặt trâṇ", "title_path": "b. Văn hóa là một mặt trâṇ", "content": "[tutuonghcm / b. Văn hóa là một mặt trâṇ]  Văn hoá là một lĩnh vực có tính độc lập, có mối liên hệ mật thiết với các lĩnh vực khác Văn hóa là mặt trận vì vậy, nghệ sỹ là chiến sỹ trên mặt trận văn hóa . Nghệ sỹ phải bám sát cuộc sống thực tiễn, phê bình các hiện tượng tiêu cực như tham ô, lãng phí, quan liêu, lười biếng... đồng thời phát hiện và ca tụng chân thật những người tốt, việc tốt để làm gương mẫu cho chúng ta hôm nay và con cháu mai sau, đó là chất thép của văn nghệ sỹ trong sự nghiệp cách mạng.", "order_start": 0, "order_end": 468, "word_count": 106}
{"parent_id": "c5537dd4-ab35-4601-af21-051aa81dc4ac", "subject": "tutuonghcm", "section": "c.Văn hóa phục vụ quần chúng nhân dân", "title_path": "c.Văn hóa phục vụ quần chúng nhân dân", "content": "[tutuonghcm / c.Văn hóa phục vụ quần chúng nhân dân]  Sức sống của các tác phẩm nghệ thuật phụ thuộc vào sự ảnh hưởng của nó đối với đời sống xã hội. Nghệ sỹ, chiến sỹ trên mặt trận văn hóa chỉ được xã hội tôn vinh nếu hoạt động của họ thấm vào đời sống thực tiễn của nhân dân. Theo Hồ Chí Minh văn hóa xuất phát từ thực tiễn, phản ánh cuộc sống phong phú đa dạng của quần chúng nhân dân, phản ánh khát vọng của quần chúng nhân dân, phục vụ nhân dân. Tư tưởng HCM về những nguyên tắc xây dựng đạo đức mới, liên hệ với sinh viên hiện nay. Những nguyên tắc xây dựng đạo đức mới, a. Nói đi đôi với làm, nêu gương về đạo đức  Là nguyên tắc hàng đầu, quan trọng nhất trong xây dựng nền đạo đức mới Là nguyên tắc xuyên suốt trong quan niệm của Hồ Chí Minh về đạo đức Nêu gương về đạo đức, đây là nguyên tắc đạo đức Thân giáo của truyền thống đạo đức phương Đông. Hồ Chí Minh đã vận dụng vào việc xây dựng đạo đức cách mạng ,một trăm bài diễn văn hay không bằng một tấm gương sống. Người yêu cầu cán bộ, đảng viên phải thật sự làm tấm gương cho quần chúng noi theo. Hô hào dân tiết kiệm, mình phải tiết kiệm trước đã.", "order_start": 0, "order_end": 1059, "word_count": 233}
{"parent_id": "c5537dd4-ab35-4601-af21-051aa81dc4ac", "subject": "tutuonghcm", "section": "c.Văn hóa phục vụ quần chúng nhân dân", "title_path": "c.Văn hóa phục vụ quần chúng nhân dân", "content": "[tutuonghcm / c.Văn hóa phục vụ quần chúng nhân dân] diễn văn hay không bằng một tấm gương sống. Người yêu cầu cán bộ, đảng viên phải thật sự làm tấm gương cho quần chúng noi theo. Hô hào dân tiết kiệm, mình phải tiết kiệm trước đã. Theo Người, Đảng viên đi trước, làng nước đi sau Hồ Chí Minh là một tấm gương sáng tuyệt vời về nói đi đôi với làm. Đạo đức cách mạng là đạo đức luôn được nhận thức và giải quyết trên lập trường của giai cấp công nhân, phục vụ lợi ích của cách mạng. Điều này phân biệt rạch ròi với thói đạo đức giả, đạo đức của giai cấp bóc lột với những bản chất nói nhiều, làm ít, nói mà không làm… Nói đi đôi với làm còn nhằm chống thói đạo đức giả. Nói không đi đôi với làm sẽ dẫn tới nguy cơ làm mất lòng tin của dân đối với Đảng và chế độ mới.", "order_start": 1059, "order_end": 1772, "word_count": 159}
{"parent_id": "b2bb7088-c3e1-4c74-a6fb-6efcd326239d", "subject": "tutuonghcm", "section": "b.Xây đi đôi với chống", "title_path": "b.Xây đi đôi với chống", "content": "[tutuonghcm / b.Xây đi đôi với chống] . Xây tức là xây dựng các giá trị, chuẩn mực, hành vi đạo đức mới. Chống là chống biểu hiện của những hành vi vô đạo đức, chống sự suy thoái của đạo đức cách mạng. xây phải đi đôi với chống, muốn xây phải chống, chống mục đích để xây, xây dựng đạo đức cách mạng là chính. Xây dựng đạo đức cách mạng trước hết phải tiến hành bằng việc giáo dục những những phẩm chất, chuẩn mực đạo đức mới - đạo đức cách mạng. Giáo dục đạo đức mới ngay từ trong gia đình đến nhà trường và xã hội Xây dựng đạo đức phải được tiến hành thường xuyên, liên tục. Quá trình xây dựng đạo đức là quá trình đồng thời xây dựng những phẩm chất đạo đức mới với quá trình loại bỏ dần những cái sai, cái xấu trong mỗi con người. Chống lại cái xấu, cái sai, cái vô đạo đức vẫn thường xuyên diễn ra.", "order_start": 0, "order_end": 764, "word_count": 166}
{"parent_id": "515b4a1f-8ec3-48ed-983e-63781f08b0e3", "subject": "tutuonghcm", "section": "c.Tu dưỡng đạo đức suốt đời", "title_path": "c.Tu dưỡng đạo đức suốt đời", "content": "[tutuonghcm / c.Tu dưỡng đạo đức suốt đời] Tu dưỡng đạo đức là một truyền thống tốt đẹp của dân tộc và văn hóa phương Đông. Hồ Chí Minh nói: “Chúng ta phải nhớ câu “Chính tâm, tu thân” để “trị quốc bình thiên hạ”. Dù khó khăn gian khổ, nhưng muốn cải tạo thì nhất định thành công. Mỗi người cần phải nhìn thẳng vào mình, phải kiên trì rèn luyện, tu dưỡng bền bỉ suốt đời phải như công việc rửa mặt hàng ngày. Nếu không sẽ dễ sa vào chủ nghĩa cá nhân thì có thể ngày hôm qua có công với cách mạng, nhưng ngày hôm nay lại có tội với nhân dân.  Đạo đức cách mạng là nhằm giải phóng và đem lại hạnh phúc, tự do cho con người, đó là đạo đức của những con người được giải phóng. Vì vậy, tu dưỡng đạo đức phải gắn liền với hoạt động thực tiễn, trên tinh thần tự giác, tự nguyện, dựa vào lương tâm và trách nhiệm của mỗi người", "order_start": 0, "order_end": 776, "word_count": 170}
{"parent_id": "e7b56e8d-8c2c-4f48-8064-ab115563bf57", "subject": "tutuonghcm", "section": "a. Học tập và làm theo tư tưởng đạo đức Hồ Chí Minh", "title_path": "a. Học tập và làm theo tư tưởng đạo đức Hồ Chí Minh", "content": "[tutuonghcm / a. Học tập và làm theo tư tưởng đạo đức Hồ Chí Minh] – Xác định đúng vị trí và vai trò của đạo đức đối với cá nhân Hồ Chí Minh cho rằng việc tu dưỡng đạo đức của mỗi cá nhân, mỗi con người có vai trò vô cùng quan trọng đặc biệt là thế hệ trẻ, vì họ là người chủ tương lai của nc nhà, là cái cầu nối giữa các thế hệ. – Kiên trì tu dưỡng theo các phẩm chất đạo đức Hồ Chí Minh. Trong bài nói tại đại hội sinh viên VN lần thứ hai ; 7/5/1958; những phẩm chất đó đc người tóm tắt trong 6 cái yêu Yêu tổ quốc, yêu nhân dân: là phải làm sao cho tổ quốc ta giàu mạnh, biết chia sẻ những lo lắng vui buồn với nhân dân. Cần cù sang tạo trong học tập. Sống nhân nghĩa có đạo lý. Tu dưỡng theo các nguyên tắc đạo đức Hồ Chí Minh. Kiên trì tu dưỡng đạo đức CM. Nói đi đôi với làm.  + Kết hợp giữa xây đạo đức mới và chống biểu hiện suy thoái đạo đức. b.", "order_start": 0, "order_end": 788, "word_count": 185}
{"parent_id": "e7b56e8d-8c2c-4f48-8064-ab115563bf57", "subject": "tutuonghcm", "section": "a. Học tập và làm theo tư tưởng đạo đức Hồ Chí Minh", "title_path": "a. Học tập và làm theo tư tưởng đạo đức Hồ Chí Minh", "content": "[tutuonghcm / a. Học tập và làm theo tư tưởng đạo đức Hồ Chí Minh] ạo lý. Tu dưỡng theo các nguyên tắc đạo đức Hồ Chí Minh. Kiên trì tu dưỡng đạo đức CM. Nói đi đôi với làm.  + Kết hợp giữa xây đạo đức mới và chống biểu hiện suy thoái đạo đức. b. Nội dung học tập theo tấm gương đạo đức Hồ Chí Minh Một là, học trung với nước học hiếu với dân, suốt đời đấu tranh cho sự nghiệp giải phóng dân tộc, giải phóng giai cấp, giải phóng con người Hai là, học cần, kiệm, liêm, chính, chí công vô tư, đời riêng trong sáng, nếp sống giản di và đức tính khiêm tốn phi thường Ba là, học đức tin tuyệt đối vào sức mạnh của nhân dân, kính trrọng nhân dân và hết lòng, hết sức phục vụ nhân dân; luôn nhân ái, vị tha, khoan dung và nhân hậu với con người Bốn là, học tấm gương về ý chí và nghị lực tinh thần to lớn, quyết tâm vượt qua mọi thử thách, gian nguy để đạt được mục đích cuộc sống.", "order_start": 788, "order_end": 1596, "word_count": 180}
{"parent_id": "43ae67c8-5c5f-4f48-a4de-03f393fa7675", "subject": "Xulyanh", "section": "LỜI NÓI ĐẦU", "title_path": "LỜI NÓI ĐẦU", "content": "[Xulyanh / LỜI NÓI ĐẦU] Khoảng hơn mười năm trở lại đây, phần cứng máy tính và các thiết bị liên quan đã có sự tiến bộ vượt bậc về tốc độ tính toán, dung lượng chứa, khả năng xử lý v.v.. và giá cả đã giảm đến mức máy tính và các thiết bị liên quan đến xử lý ảnh đã không còn là thiết bị chuyên dụng nữa. Khái niệm ảnh số đã trở nên thông dụng với hầu hết mọi người trong xã hội và việc thu nhận ảnh số bằng các thiết bị cá nhân hay chuyên dụng cùng với việc đưa vào máy tính xử lý đã trở nên đơn giản. Trong hoàn cảnh đó, xử lý ảnh là một lĩnh vực đang được quan tâm và đã trở thành môn học chuyên ngành của sinh viên ngành công nghệ thông tin trong nhiều trường đại học trên cả nước. Tuy nhiên, tài liệu giáo trình còn là một điều khó khăn. Hiện tại chỉ có một số ít tài liệu bằng tiếng Anh hoặc tiếng Pháp, tài liệu bằng tiếng Việt thì rất hiếm. Với mong muốn đóng góp vào sự nghiệp đào tạo và nghiên cứu trong lĩnh vực này, chúng tôi biên soạn cuốn giáo trình Xử lý ảnh dựa trên đề cương môn học đã được duyệt.", "order_start": 0, "order_end": 989, "word_count": 221}
{"parent_id": "43ae67c8-5c5f-4f48-a4de-03f393fa7675", "subject": "Xulyanh", "section": "LỜI NÓI ĐẦU", "title_path": "LỜI NÓI ĐẦU", "content": "[Xulyanh / LỜI NÓI ĐẦU] thì rất hiếm. Với mong muốn đóng góp vào sự nghiệp đào tạo và nghiên cứu trong lĩnh vực này, chúng tôi biên soạn cuốn giáo trình Xử lý ảnh dựa trên đề cương môn học đã được duyệt. Cuốn sách tập trung vào các vấn đề cơ bản của xử lý ảnh nhằm cung cấp một nền tảng kiến thức đầy đủ và chọn lọc nhằm giúp người đọc có thể tự tìm hiểu và xây dựng các chương trình ứng dụng liên quan đến xử lý ảnh. Giáo trình được chia làm 7 chươn g: Chương 1, t rình bày Tổng quan về xử lý ảnh, các khái niệm cơ bản, sơ đồ tổng quát của một hệ thống xử lý ảnh và các vấn đề cơ bản trong xử lý ảnh. Chương 2, trình bày các vấn đề liên quan đến thu nhận ảnh, bao gồm các thiết bị thu nhận ảnh cơ bản, quá trình lấy mẫu và lượng tử hóa, một số phương pháp biểu diễn ảnh, cũng như một số định dạng ảnh phổ dụng. Chương 3, trình bày các kỹ thuật nâng cao chất lượng ảnh dựa vào các thao tác với điểm ảnh, nâng cao chất lượng ảnh thông qua việc xử lý các điểm ảnh trong lân cận điểm ảnh đang xét. Chương này cũng trình bày các kỹ thuật nâng cao chất lượng ảnh nhờ vào việc lọc nhiễu.", "order_start": 989, "order_end": 2046, "word_count": 239}
{"parent_id": "43ae67c8-5c5f-4f48-a4de-03f393fa7675", "subject": "Xulyanh", "section": "LỜI NÓI ĐẦU", "title_path": "LỜI NÓI ĐẦU", "content": "[Xulyanh / LỜI NÓI ĐẦU] h, nâng cao chất lượng ảnh thông qua việc xử lý các điểm ảnh trong lân cận điểm ảnh đang xét. Chương này cũng trình bày các kỹ thuật nâng cao chất lượng ảnh nhờ vào việc lọc nhiễu. Chương 4, trình bày các kỹ thuật cơ bản trong việc phát hiện biên của các đối tượng ảnh theo cả hai khuynh hướng: Phát hiện biên trực tiếp và phát hiện biên gián tiếp. Chương 5 thể hiện các kỹ thuật phân vùng ảnh, đây là khâu quan trọng hỗ trợ cho việc trích chọn các thuộc tính của ảnh để tiến tới hiểu ảnh. Chương 6, trình bày các vấn đề và kỹ thuật liên quan đến nhận dạng ảnh, theo tiếp cận không gian, tiếp cận cấu trúc và tiếp cận mạng nơron. Và cuối cùng là Chương 7 với các kỹ thuật nén ảnh, đây là vấn đề luôn được quan tâm trong xử lý ảnh. Giáo trình được biên soạn dựa trên kinh nghiệm giảng dạy của tác giả trong nhiều năm tại các khóa đại học và cao học của ĐH Công nghệ - ĐHQG Hà Nội, ĐH Khoa học tự nhiên – ĐHQG Hà Nội, Khoa Công nghệ thông tin – ĐH Thái Nguyên, Khoa Công nghệ thông tin – Học viện Công nghệ BCVT v.v..", "order_start": 2046, "order_end": 3061, "word_count": 222}
{"parent_id": "43ae67c8-5c5f-4f48-a4de-03f393fa7675", "subject": "Xulyanh", "section": "LỜI NÓI ĐẦU", "title_path": "LỜI NÓI ĐẦU", "content": "[Xulyanh / LỜI NÓI ĐẦU] c và cao học của ĐH Công nghệ - ĐHQG Hà Nội, ĐH Khoa học tự nhiên – ĐHQG Hà Nội, Khoa Công nghệ thông tin – ĐH Thái Nguyên, Khoa Công nghệ thông tin – Học viện Công nghệ BCVT v.v.. Cuốn sách có thể làm tài liệu tham khảo cho sinh viên các hệ kỹ sư, cử nhân và các bạn quan tâm đến vấn đề nhận dạng và xử lý ảnh. Các tác giả bày tỏ lòng biết ơn chân thành tới các bạn đồng nghiệp trong Viện Công nghệ thông tin, Khoa Công nghệ thông tin – Học viện Công nghệ BCVT, Khoa Công nghệ thông tin - ĐH Thái Nguyên, Khoa Công nghệ thông tin - ĐH Công nghệ - ĐHQG Hà Nội, Khoa Toán – Cơ – Tin, ĐH Khoa học tự nhiên, ĐHQG Hà Nội đã động viên, góp ý và giúp đỡ để hoàn chỉnh nội dung cuốn sách này. Xin cám ơn Lãnh đạo Khoa Công nghệ thông tin – Học viện Công nghệ BCVT, Ban Giám đốc Học viện Công nghệ BCVT đã hỗ trợ và tạo điều kiện để cho ra đời giáo trình này. Mặc dù rất cố gắng nhưng tài liệu này chắc chắn không tránh khỏi những sai sót. Chúng tôi xin trân trọng tiếp thu tất cả những ý kiến đóng góp của bạn đọc cũng như các bạn đồng nghiệp để có chỉnh lý kịp thời.", "order_start": 3061, "order_end": 4121, "word_count": 242}
{"parent_id": "43ae67c8-5c5f-4f48-a4de-03f393fa7675", "subject": "Xulyanh", "section": "LỜI NÓI ĐẦU", "title_path": "LỜI NÓI ĐẦU", "content": "[Xulyanh / LỜI NÓI ĐẦU] liệu này chắc chắn không tránh khỏi những sai sót. Chúng tôi xin trân trọng tiếp thu tất cả những ý kiến đóng góp của bạn đọc cũng như các bạn đồng nghiệp để có chỉnh lý kịp thời. Thư góp ý xin gửi về: Đỗ Năng Toàn, Viện Công nghệ thông tin. 18 Hoàng Quốc Việt, Cầu Giấy, Hà Nội Điện thoại: 04.3.7567935 Email: dntoan@ioit.ac.vn Hà Nội, ngày 28 tháng 06 năm 2010 TÁC GIẢ", "order_start": 4121, "order_end": 4491, "word_count": 76}
{"parent_id": "73dc8bfa-274d-422d-929d-c9d78610e027", "subject": "Xulyanh", "section": "Chương 1: NHẬP MÔN XỬ LÝ ẢNH.", "title_path": "Chương 1: NHẬP MÔN XỬ LÝ ẢNH.", "content": "[Xulyanh / Chương 1: NHẬP MÔN XỬ LÝ ẢNH.] 1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH. 7 1.2. NHỮNG VẤN ĐỀ CƠ BẢN TRONG XỬ LÝ ẢNH. ..8 1.2.1. Một số khái niệm cơ bản. ..8 1.2.2. Nắn chỉnh biến dạng.. ..8 1.2.3. Khử nhiễu . ...8 1.2.4. Chỉnh số mức xám. ...9 1.2.5. Phân tích ảnh . ...9 1.2.6. Nhận dạng và phân loại ảnh.. ...9 1.2.7. Nén ảnh.. .10", "order_start": 0, "order_end": 298, "word_count": 64}
{"parent_id": "11cd4879-7c07-4262-89bb-9008d16c8ad3", "subject": "Xulyanh", "section": "2.1. CÁC THIẾT BỊ THU NHẬN ẢNH . .11", "title_path": "2.1. CÁC THIẾT BỊ THU NHẬN ẢNH . .11", "content": "[Xulyanh / 2.1. CÁC THIẾT BỊ THU NHẬN ẢNH . .11] 2.2. LẤY MẪU VÀ LƯỢNG TỬ HOÁ. .11 2.2.1. Giai đoạn lấy mẫu. ................ .11 2.2.2. Lượng tử hóa . .12 2.3. MỘT SỐ PHƯƠNG PHÁP BIỂU DIỄN ẢNH.. .12 2.3.1. Mô hình Raster.. .12 2.3.2. Mô hình Vector.. .13", "order_start": 0, "order_end": 206, "word_count": 40}
{"parent_id": "e3cb5942-76a5-4db5-8601-22143afd8229", "subject": "Xulyanh", "section": "2.4. CÁC ĐỊNH DẠNG ẢNH CƠ BẢN.. ..... .13", "title_path": "2.4. CÁC ĐỊNH DẠNG ẢNH CƠ BẢN.. ..... .13", "content": "[Xulyanh / 2.4. CÁC ĐỊNH DẠNG ẢNH CƠ BẢN.. ..... .13] 2.4.1. Định dạng ảnh IMG. .13 2.4.2. Định dạng ảnh PC .14 2.4.3. Định dạng ảnh TIFF. .15 2.4.4. Định dạng file ảnh BITMAP. .16 2.5. KỸ THUẬT TÁI NHẬN ẢNH. ..17 2.5.1 Kỹ thuật chụp ảnh.. .17 2.5.2 Kỹ thuật in ảnh . ..18 2.6. KHÁI NIỆM ẢNH ĐEN TRẮNG, ẢNH MÀU.. ..20 2.6.1. Phân loại ảnh số.. .20 2.6.2. Màu sắc.. ..21 2.7. CÂU HỎI ÔN TẬP CHƯƠNG. ..28", "order_start": 0, "order_end": 348, "word_count": 71}
{"parent_id": "83c3ffb3-ba76-4488-8c7c-c35075db5f7c", "subject": "Xulyanh", "section": "Chương 3: XỬ LÝ NÂNG CAO CHẤT LƯỢNG ẢNH. ..29", "title_path": "Chương 3: XỬ LÝ NÂNG CAO CHẤT LƯỢNG ẢNH. ..29", "content": "[Xulyanh / Chương 3: XỬ LÝ NÂNG CAO CHẤT LƯỢNG ẢNH. ..29] .1. CẢI THIỆN ẢNH SỬ DỤNG CÁC TOÁN TỬ ĐIỂM. ..29 3.1.1. Giới thiệu .. ..29 3.1.2. Tăng giảm độ sáng . ..29 3.1.3. Tách ngưỡng. ..29 3.1.4. Cân bằng histogram. ..30 3.1.5. Kỹ thuật tìm tách ngưỡng tự động . ..31 3.1.6. Biến đổi cấp xám tổng thể . .32 3.2. CẢI THIỆN ẢNH SỬ DỤNG CÁC TOÁN TỬ KHÔNG GIAN . ..32 3.2.1. Phép cửa sổ di chuyển.. ..32 3.2.2. Phép nhân chập và mẫu .33 3.2.3. Lọc trung vị .. ..35 3.2.4. Lọc trung bình . ..37 3.2.5. Lọc trung bình theo k giá trị gần nhất . ..38 3.3. KHÔI PHỤC ẢNH.. ..39 3.3.1. Nhiễu và mô hình nhiễu.. ..39 3.3.2. Các loại nhiễu .. ..39 3.3.3. Các kỹ thuật lọc nhiễu . ..40", "order_start": 0, "order_end": 615, "word_count": 128}
{"parent_id": "6db03b01-d475-4afc-a999-2eb79a3415bf", "subject": "Xulyanh", "section": "4.1. KHÁI QUÁT VỀ BIÊN VÀ PHÂN LOẠI CÁC KỸ THUẬT DÒ BIÊN CƠ BẢN.....43", "title_path": "4.1. KHÁI QUÁT VỀ BIÊN VÀ PHÂN LOẠI CÁC KỸ THUẬT DÒ BIÊN CƠ BẢN.....43", "content": "[Xulyanh / 4.1. KHÁI QUÁT VỀ BIÊN VÀ PHÂN LOẠI CÁC KỸ THUẬT DÒ BIÊN CƠ BẢN.....43] 4.1.1. Giới thiệu . ..43 4.1.2. Kỹ thuật phát hiện biên Gradient. ..43 4.1.3. Kỹ thuật phát hiện biên Laplace.. ..47 4.1.4. Kỹ thuật Canny. ..47 4.2. PHƯƠNG PHÁP PHÁT HIỆN BIÊN CỤC BỘ..... ..49 4.2.1. Biên và độ biến đổi về mức xám... ..49 4.2.2. Phát hiện biên dựa vào trung bình cục bộ.. .50 4.3. DÒ BIÊN THEO QUY HOẠCH ĐỘNG.. .53 4.3.1. Một số khái niệm cơ bản ..53 4.3.2. Chu tuyến của một đối tượng ảnh.. .54 4.3.3. Thuật toán dò biên tổng quát... ..55", "order_start": 0, "order_end": 457, "word_count": 89}
{"parent_id": "cc283ebc-c078-43ef-8ba2-d76f1b17c15e", "subject": "Xulyanh", "section": "4.4.CÁC PHƯƠNG PHÁP KHÁC .58", "title_path": "4.4.CÁC PHƯƠNG PHÁP KHÁC .58", "content": "[Xulyanh / 4.4.CÁC PHƯƠNG PHÁP KHÁC .58] 4.4.1. Các phép toán hình thái cơ bản . ..58 4.4.2. Một số tính chất của phép toán hình thái.. ..59 4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh . ..62 4.4.4. Thuật toán phát hiện biên dựa vào phép toán hình thái . ..64 4.5. CÂU HỎI ÔN TẬP CHƯƠNG.. ..65", "order_start": 0, "order_end": 256, "word_count": 55}
{"parent_id": "8ba58164-1993-4473-9b8d-039df7959dbd", "subject": "Xulyanh", "section": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ ..67", "title_path": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ ..67", "content": "[Xulyanh / 5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ ..67] 5.2.1. Thuật toán đẳng liệu.. ..68 5.2.2. Thuật toán đối xứng nền. ..69 5.2.3. Thuật toán tam giác . ..70 5.2.3. Chọn ngưỡng đối với Bimodal Histogram.. ..70 5.3. PHÂN VÙNG THEO MIỀN ĐỒNG NHẤT. ..71 5.3.1. Giới thiệu . ..71 5.3.2. Phương pháp tách cây tứ phân (quad tree).. ..72 5.3.3. Các phương pháp phân vùng bởi hợp. ..75 5.3.4. Phương pháp tách hợp (split-merge). ..76 5.4. PHÂN VÙNG DỰA THEO ĐƯỜNG BIÊN. ..77 5.4.1. Phát hiện biên. ..77 5.4.2. Làm mảnh biên ..78 5.4.3. Nhị phân hóa đường biên . ..78 5.4.4. Miêu tả đường biên.. ..78 5.5. PHÂN VÙNG THEO KẾT CẤU BỀ MẶT.. ..79 5.4.1. Phương pháp thống kê ..79 5.4.2. Phương pháp cấu trúc.. ..81 5.4.3. Tiếp cận theo tính kết cấu ..81 5.6. CÂU HỎI ÔN TẬP CHƯƠNG. ..", "order_start": 0, "order_end": 719, "word_count": 135}
{"parent_id": "8ba58164-1993-4473-9b8d-039df7959dbd", "subject": "Xulyanh", "section": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ ..67", "title_path": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ ..67", "content": "[Xulyanh / 5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ ..67] 5.5. PHÂN VÙNG THEO KẾT CẤU BỀ MẶT.. ..79 5.4.1. Phương pháp thống kê ..79 5.4.2. Phương pháp cấu trúc.. ..81 5.4.3. Tiếp cận theo tính kết cấu ..81 5.6. CÂU HỎI ÔN TẬP CHƯƠNG. ..82", "order_start": 719, "order_end": 900, "word_count": 36}
{"parent_id": "715ebc81-3658-4649-89ad-d58f1ab81534", "subject": "Xulyanh", "section": "6.2. NHẬN DẠNG DỰA THEO MIỀN KHÔNG GIAN.. ..84", "title_path": "6.2. NHẬN DẠNG DỰA THEO MIỀN KHÔNG GIAN.. ..84", "content": "[Xulyanh / 6.2. NHẬN DẠNG DỰA THEO MIỀN KHÔNG GIAN.. ..84] 6.2.1. Phân hoạch không gian . ..84 6.2.2. Hàm phân lớp hay hàm ra quyết định ..84 6.2.3. Nhận dạng thống kê. ..85 6.2.4. Một số thuật toán nhận dạng t u biểu trong t học. ..86 6.3. NHẬN DẠNG DỰA THEO CẤU TRÚ .88 6.3.1. Biểu diễn định tính. .88 6.3.2. Phương pháp ra quyết định ựa vào cấu trúc. ..88 6.4. NHẬN DẠNG DỰA THEO MẠNG ƠRON... ..90 6.4.1. Mạng Hopfiel ..90 6.4.2. Mạng Kohonen. ..92", "order_start": 0, "order_end": 392, "word_count": 78}
{"parent_id": "2931fd82-b26e-4398-a107-b820ac8348dd", "subject": "Xulyanh", "section": "Chương 7: NÉN DỮ LIỆU ẢNH ..95", "title_path": "Chương 7: NÉN DỮ LIỆU ẢNH ..95", "content": "[Xulyanh / Chương 7: NÉN DỮ LIỆU ẢNH ..95] 7.1. GIỚI THIỆU. ..95 7.2. CÁC PHƯƠNG PHÁP NÉN THẾ HỆ THỨ NHẤT. ..96 7.2.1. Phương pháp mã hóa loạt dài . ..96 7.2.2. Phương pháp mã hóa Huffman. ..96 7.2.3. Phương pháp LZW.. ..98 7.2.4. Phương pháp mã hóa khối.. .. 102 7.2.5. Phương pháp thích nghi. .. 103 7.2.6. Biến đổi Cosin và chuẩn nén JPEG. .. 104 7.3. CÁC PHƯƠNG PHÁP NÉN THẾ HỆ THỨ HAI. .. 109 7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace). ..109 7.3.2. Phương pháp mã hóa dựa vào biểu diễn ảnh. .. 110 7.4. CÂU HỎI ÔN TẬP CHƯƠNG.. .. 112 TÀI LIỆU THAM KHẢO. .113 Chương 1:", "order_start": 0, "order_end": 546, "word_count": 108}
{"parent_id": "bac183c4-d17f-474d-93cc-de2e6fe6e5d7", "subject": "Xulyanh", "section": "1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH", "title_path": "1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH", "content": "[Xulyanh / 1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH] Con người thu nhận thông tin qua các giác quan, trong đó thị giác đóng vai trò quan trọng nhất. Những năm trở lại đây với sự phát triển của phần cứng máy tính, xử lý ảnh và đồ hoạ đó phát triển một cách mạnh mẽ và có nhiều ứng dụng trong cuộc sống. Xử lý ảnh và đồ hoạ đóng một vai trò quan trọng trong tương tác người máy. Quá trình xử lý ảnh được xem như là quá trình thao tác ảnh đầu vào nhằm cho ra kết quả mong muốn. Kết quả đầu ra của một quá trình xử lý ảnh có thể là một ảnh “tốt hơn” hoặc một kết luận. Ảnh có thể xem là tập hợp các điểm ảnh v mỗi điểm ảnh được xem như là đặc trưng cường độ sáng hay một dấu hiệu nào đó tại một vị trí nào đó của đối tượng trong khôngT gian và nó có thể xem như t hàm n b ến P(c1, c2,..., cn). Do đó, ảnh trong xử lý ảnh có thể xem như ảnh n chiề Hình 1.2 biểu diễn sơ đồ tổng quát của một hệ thống xử lý ảnh: Khối thu nhận ảnh: có nhiệm vụ tiếp nhận ảnh đầu vào. Khối tiền xử lý: có nhiệm vụ xử lý nâng cao chất lượng ảnh như giảm nhiễu, phân vùng, tìm biên v.v..", "order_start": 0, "order_end": 1007, "word_count": 235}
{"parent_id": "bac183c4-d17f-474d-93cc-de2e6fe6e5d7", "subject": "Xulyanh", "section": "1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH", "title_path": "1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH", "content": "[Xulyanh / 1.1. TỔNG QUAN VỀ HỆ THỐNG XỬ LÝ ẢNH] a một hệ thống xử lý ảnh: Khối thu nhận ảnh: có nhiệm vụ tiếp nhận ảnh đầu vào. Khối tiền xử lý: có nhiệm vụ xử lý nâng cao chất lượng ảnh như giảm nhiễu, phân vùng, tìm biên v.v..  Khối trich chọn đặc điểm: có nhiệm vụ trích chọn các đặc trưng quan trọng của các bức ảnh đã được tiền xử lý để sử dụng trong hệ quyết định  Khối hậu xử lý: có nhiệm vụ xử lý các đặc điểm đã trích chọn, có thể lược bỏ hoặc biến đổi các đặc điểm này để phù hợp với các kỹ thuật cụ thể sử dụng trong hệ quyết định Khối hệ quyết định và lưu trữ: có nhiệm vụ đưa ra quyết định (phân loại) dựa trên dự liệu đã học lưu trong khối lưu trữ Khối kết luận: đưa ra kết luận dựa vào quyết định của khối quyết định", "order_start": 1007, "order_end": 1692, "word_count": 157}
{"parent_id": "1deb52d5-dfb3-4a21-834d-fea6b1cd6e50", "subject": "Xulyanh", "section": "1.2.1. Một số khái niệm cơ bản", "title_path": "1.2.1. Một số khái niệm cơ bản", "content": "[Xulyanh / 1.2.1. Một số khái niệm cơ bản] * Ảnh và điểm ảnh: Điểm ảnh được xem như là dấu hiệu hay cường độ sáng tại một vị trí nào đó của đối tượng trong không gian và ảnh được xem như là một tập hợp các điểm ảnh.", "order_start": 0, "order_end": 172, "word_count": 41}
{"parent_id": "be6f03c3-2f81-47de-9225-e59d0ab193e4", "subject": "Xulyanh", "section": "* Mức xám, màu", "title_path": "* Mức xám, màu", "content": "[Xulyanh / * Mức xám, màu] Là số các giá trị có thể có của các điểm ảnh của ảnh", "order_start": 0, "order_end": 52, "word_count": 14}
{"parent_id": "fb14cc52-5abe-471a-8de3-3006c7a57b9f", "subject": "Xulyanh", "section": "1.2.2. Nắn chỉnh biến dạng", "title_path": "1.2.2. Nắn chỉnh biến dạng", "content": "[Xulyanh / 1.2.2. Nắn chỉnh biến dạng] Ảnh thu nhận thường bị biến dạng do các thiết bị quang học và điện tử.", "order_start": 0, "order_end": 70, "word_count": 16}
{"parent_id": "bf43909a-16bf-4dc5-aa47-3050d6788042", "subject": "Xulyanh", "section": "Hình 1.3. Ảnh thu nhận và ảnh mong muốn", "title_path": "Hình 1.3. Ảnh thu nhận và ảnh mong muốn", "content": "[Xulyanh / Hình 1.3. Ảnh thu nhận và ảnh mong muốn] Để khắc phục người ta sử dụng các phép chiếu được xây dựng trên tập các điểm điều khiển. Giả sử có hai ảnh I và tương ứng với ảnh thu nhận được và ảnh mong muốn. Pi là một điểm thuộc I tương ứng với một điểm Pi' trên I', ta có n các cặp điểm điều khiển như vậy. Nắn chỉnh biến dạng là tìm hàm \u0000: P\u0000 → \u0000(\u0000\u0000) sao cho Thông thường các điểm điều khiển được lấy bằng cách chụp những ảnh có cấu trúc định sẵn như là ảnh lưới giống như ảnh mong muốn trên Hình 1.3.", "order_start": 0, "order_end": 457, "word_count": 104}
{"parent_id": "1de9d2ad-5faa-4989-b71b-746be6431255", "subject": "Xulyanh", "section": "1.2.3. Khử nhiễu", "title_path": "1.2.3. Khử nhiễu", "content": "[Xulyanh / 1.2.3. Khử nhiễu] Có 2 loại nhiễu cơ bản trong quá trình thu nhận ảnh mà chúng ta cần loại bỏ:  Nhiễu hệ thống: là nhiễu có quy luật có thể khử bằng các phép biến đổi  Nhiễu ngẫu nhiên: vết bẩn không rõ nguyên nhân có thể khắc phục bằng các phép lọc", "order_start": 0, "order_end": 233, "word_count": 53}
{"parent_id": "1ed45c63-1625-4b32-b1ca-63ac5ca898c1", "subject": "Xulyanh", "section": "1.2.4. Chỉnh số mức xám", "title_path": "1.2.4. Chỉnh số mức xám", "content": "[Xulyanh / 1.2.4. Chỉnh số mức xám] Chỉnh số mức xám là nhằm khắc phục tính không đồng đều của hệ thống xử lý ảnh, thông thường có 2 hướng tiếp cận: Giảm số mức xám: Thực hiện bằng cách nhóm các mức xám gần nhau thành một bó. Trường hợp giảm xuống 2 mức xám thì chính là chuyển về ảnh đen trắng. Tăng số mức xám: Thực hiện nội suy ra các mức xám trung gian bằng kỹ thuật nội suy. Kỹ thuật này nhằm tăng cường độ mịn cho ảnh.", "order_start": 0, "order_end": 388, "word_count": 86}
{"parent_id": "e27b1d53-5103-4c0a-ae61-3a6f6f9406cf", "subject": "Xulyanh", "section": "1.2.5. Phân tích ảnh", "title_path": "1.2.5. Phân tích ảnh", "content": "[Xulyanh / 1.2.5. Phân tích ảnh] Là khâu quan trọng trong quá trình xử lý ảnh để tiến tới hiểu ảnh. Trong phân tích ảnh việc trích chọn đặc điểm là một bước quan trọng. Các đặc điểm của đối tượng được trích chọn tuỳ theo mục đích nhận dạng trong quá trình xử lý ảnh. Có thể nêu ra một số đặc điểm của ảnh sau đây: Đặc điểm không gian: Phân bố mức xám, phân bố xác suất, biên độ, điểm uốn v.v.. Đặc điểm biến đổi: Các đặc điểm loại này được trích chọn bằng việc thực hiện lọc vùng (zonal filtering). Các bộ vùng được gọi là “mặt nạ đặc điểm” (feature mask) thường là các khe hẹp với hình dạng khác nhau (chữ nhật, tam giác, cung tròn v.v..) Đặc điểm biên và đường biê : Đặc trưng cho đường biên của đối tượng và do vậy rất hữu ích trong việc trích trọ n các thuộc tính bất biến được dùng khi nhận dạng đối tượng (Ví dụ đặc điểm góc, cạnh v.v..). Các đặc điểm này có thể được trích chọn thông qua ảnh iên. Để thu được ảnh biên ta có thể sử dụng toán tử gradient, toán tử l àn, toán tử Laplace v.v..", "order_start": 0, "order_end": 963, "word_count": 207}
{"parent_id": "e27b1d53-5103-4c0a-ae61-3a6f6f9406cf", "subject": "Xulyanh", "section": "1.2.5. Phân tích ảnh", "title_path": "1.2.5. Phân tích ảnh", "content": "[Xulyanh / 1.2.5. Phân tích ảnh] ụ đặc điểm góc, cạnh v.v..). Các đặc điểm này có thể được trích chọn thông qua ảnh iên. Để thu được ảnh biên ta có thể sử dụng toán tử gradient, toán tử l àn, toán tử Laplace v.v.. Việc trích chọn hiệu quả các đặc điểm giúp cho việc nhận dạng các đối tượng ảnh chính xác, với tốc độ tính toán cao và giảm thiểu dung lượng lưu trữ.", "order_start": 963, "order_end": 1293, "word_count": 72}
{"parent_id": "a5078a14-d91a-47e5-9ad7-3ff2febb64e1", "subject": "Xulyanh", "section": "1.2.6. Nhận dạng và phân loạ nh", "title_path": "1.2.6. Nhận dạng và phân loạ nh", "content": "[Xulyanh / 1.2.6. Nhận dạng và phân loạ nh] Nhận dạng tự động (automatic recognition), mô tả đối tượng, phân loại và phân nhóm các mẫu là những vấn đề quan trọng trong thị giác máy, được ứng dụng trong nhiều ngành khoa học khác nhau. Tuy nhiên, một câu hỏi đặt ra là: mẫu (pattern) là gì? Watanabe, một trong những người đi đầu trong lĩnh vực này đã định nghĩa: “Ngược lại với hỗn loạn (chaos), mẫu là một thực thể (entity), được xác định một cách ang áng (vaguely defined) và có thể gán cho nó một tên gọi nào đó”. Ví dụ mẫu có thể là ảnh của vân tay, ảnh của một vật nào đó được chụp, một chữ viết, khuôn mặt người hoặc một ký đồ tín hiệu tiếng nói. Khi biết một mẫu nào đó, để nhận dạng hoặc phân loại mẫu đó có thể sử dụng hai cách chính: Phân loại có mẫu (supervised classification): ví dụ phân tích phân biệt (discriminant analyis), trong đó mẫu đầu vào được định danh thành một phần của một lớp đã xác định.  Phân loại không có mẫu (unsupervised classification hay clustering): Các mẫu được gán vào các lớp khác nhau dựa trên một tiêu chuẩn đồng dạng nào đó.", "order_start": 0, "order_end": 1022, "word_count": 207}
{"parent_id": "a5078a14-d91a-47e5-9ad7-3ff2febb64e1", "subject": "Xulyanh", "section": "1.2.6. Nhận dạng và phân loạ nh", "title_path": "1.2.6. Nhận dạng và phân loạ nh", "content": "[Xulyanh / 1.2.6. Nhận dạng và phân loạ nh] hần của một lớp đã xác định.  Phân loại không có mẫu (unsupervised classification hay clustering): Các mẫu được gán vào các lớp khác nhau dựa trên một tiêu chuẩn đồng dạng nào đó. Các lớp này cho đến thời điểm phân loại vẫn chưa biết hay chưa được định danh. Có nhiều cách tiếp cận khác nhau trong lý thuyết nhận dạng trong đó có: Đối sánh mẫu dựa trên các đặc trưng được trích chọn, phân loại thống kê, đối sánh cấu trúc, phân loại dựa trên mạng nơ-ron nhân tạo... Hệ thống nhận dạng tự động bao gồm ba khâu tương ứng với ba giai đoạn chủ yếu sau đây: 1. Thu nhận dữ liệu và tiền xử lý. 2. Biểu diễn dữ liệu. 3. Nhận dạng, ra quyết định. Trong ứng dụng thực tiễn, không thể chỉ dùng có một cách tiếp cận đơn lẻ để phân loại “tối ưu” vì vậy các phương thức phân loại tổ hợp thường được sử dụng khi nhận dạng. Cho đến nay các hệ thống lai (hybrid system) sử dụng nhiều phương pháp và cách tiếp cận khác nhau đã cho những kết quả nhiều triển vọng.", "order_start": 1022, "order_end": 1968, "word_count": 199}
{"parent_id": "7d3a85f8-fe7d-4ed5-8e57-b6ff8e66ddec", "subject": "Xulyanh", "section": "1.2.7. Nén ảnh", "title_path": "1.2.7. Nén ảnh", "content": "[Xulyanh / 1.2.7. Nén ảnh] Nén ảnh là kỹ thuật nhằm giảm thiểu không gian lưu trữ. Có hai hướng tiếp cận chính là nén có bảo toàn và không bảo toàn thông tin. Nén không bảo toàn thì thường có khả năng nén cao hơn nhưng không phục hồi được ảnh gốc, ngược lại nén có bảo toàn cho phép khôi phục hoàn toàn ảnh gốc. Nén ảnh nói chung có 4 cách tiếp cận cơ bản: Nén ảnh thống kê: Kỹ thuật nén này dựa vào việc thống kê tần xuất xuất hiện của giá trị các điểm ảnh, trên cơ sở đó mà có chiến lược mã hóa thích hợp. Một ví dụ điển hình cho kỹ thuật mã hóa này là *.TIF Nén ảnh không gian: thuật này dựa vào vị trí không gian của các điểm ảnh để tiến hành mã hóa. Kỹ thuật lợi dụng sự giống nhau của các điểm ảnh trong các vùng gần nhau. Ví dụ cho kỹ thuật này là mã nén *.PCX Nén ảnh sử dụng phép biến đổi: Đây là kỹ thuật tiếp cận theo hướng nén không bảo toàn và do vậy tỉ lệ nén tương đối cao. *.JPG chính là tiếp cận theo kỹ thuật nén này. Nén ảnh Fractal: Sử dụng tính chất Fractal của các đối tượng ảnh. Tính chất Fractal của ảnh thể hiện sự lặp lại của các chi tiết tại nhiều vị trí khác nhau với kích thước và hướng khác nhau.", "order_start": 0, "order_end": 1099, "word_count": 246}
{"parent_id": "7d3a85f8-fe7d-4ed5-8e57-b6ff8e66ddec", "subject": "Xulyanh", "section": "1.2.7. Nén ảnh", "title_path": "1.2.7. Nén ảnh", "content": "[Xulyanh / 1.2.7. Nén ảnh] actal: Sử dụng tính chất Fractal của các đối tượng ảnh. Tính chất Fractal của ảnh thể hiện sự lặp lại của các chi tiết tại nhiều vị trí khác nhau với kích thước và hướng khác nhau. Kỹ thuật nén sẽ tính toán để chỉ cần lưu trữ phần gốc ảnh và quy luật sinh ra ảnh theo nguyên lý Fractal.", "order_start": 1099, "order_end": 1385, "word_count": 62}
{"parent_id": "a8d8ca0f-8783-4f5d-86d0-bdf21867dd16", "subject": "Xulyanh", "section": "2.1. CÁC THIẾT BỊ THU NHẬN ẢNH", "title_path": "2.1. CÁC THIẾT BỊ THU NHẬN ẢNH", "content": "[Xulyanh / 2.1. CÁC THIẾT BỊ THU NHẬN ẢNH] Các thiết bị thu nhận ảnh có hai loại chính ứng với hai loại ảnh thông dụng Raster, Vector và có thể cho ảnh đen trắng hoặc ảnh màu. Các thiết bị thu nhận ảnh Raster thông thường là camera, scanner. Còn các thiết bị thu nhận ảnh Vector thông thường là sensor hoặc bàn số hoá digitalizer hoặc được chuyển đổi từ ảnh Raster. Các hệ thống thu nhận ảnh sử dụng chung một quá trình thu nhận:  Cảm biến: biến đổi năng lượng quang học thành năng lượng điện (giai đoạn lấy mẫu)  Tổng hợp năng lượng điện thành ảnh (giai đoạn lượng tử hóa)", "order_start": 0, "order_end": 532, "word_count": 109}
{"parent_id": "7aedaa78-f9c5-44e1-9c6b-b8b38b92a244", "subject": "Xulyanh", "section": "2.2.1. Giai đoạn lấy mẫu", "title_path": "2.2.1. Giai đoạn lấy mẫu", "content": "[Xulyanh / 2.2.1. Giai đoạn lấy mẫu] Người ta sử dụng bộ cảm biến hoặc máy quét để biến tín hiệu quang của ảnh thành tín hiệu điện liên tục. Phương pháp sử dụng máy quét phổ biến hơn. Máy quét sẽ quét theo chiều ngang để tạo ra tín hiệu điện của ảnh, k quả cho ra một tín hiệu điện hai chiều I(x,y) liên tục. Xét ảnh liên tục được biểu diễn bởi hàm I(x, y), gọi x là khoảng cách giữa hai điểm được giữ lại theo trục x, gọi y là khoảng cách giữa hai điểm được giữ lại theo trục y. y , x được gọi là chu kỳ lấy mẫu theo trục x và y. Giai đoạn lấy mẫu sẽ biến hàm liên tục I(x,y) thành hàm rời rạc I(n x , m y ). Với m,n là nguyên. Theo SHANON để đảm bảo không xảy ra hiện tượng chồng phổ, cho phép tái tạo lại ảnh gốc từ ảnh đã số hóa thì tần số lấy mẫu phải ít nhất phải lớn hơn hoặc bằng hai tần số cao nhất của tín hiệu ảnh. Gọi fxmax, fymax là tần số cao nhất của tín hiệu theo trục x, y thì:  fx  2fxmax với fx = 1 là tần số lấy mẫu theo trục x.  fy  2fymax với fy = 1 là tần số lấy mẫu theo trục y.", "order_start": 0, "order_end": 975, "word_count": 232}
{"parent_id": "7aedaa78-f9c5-44e1-9c6b-b8b38b92a244", "subject": "Xulyanh", "section": "2.2.1. Giai đoạn lấy mẫu", "title_path": "2.2.1. Giai đoạn lấy mẫu", "content": "[Xulyanh / 2.2.1. Giai đoạn lấy mẫu] Gọi fxmax, fymax là tần số cao nhất của tín hiệu theo trục x, y thì:  fx  2fxmax với fx = 1 là tần số lấy mẫu theo trục x.  fy  2fymax với fy = 1 là tần số lấy mẫu theo trục y. y", "order_start": 975, "order_end": 1158, "word_count": 49}
{"parent_id": "abef3be6-d2dc-4a04-862c-ecd36f55b948", "subject": "Xulyanh", "section": "2.2.2. Lượng tử hóa", "title_path": "2.2.2. Lượng tử hóa", "content": "[Xulyanh / 2.2.2. Lượng tử hóa] Ảnh sau khi lấy mẫu sẽ có dạng I(m,n) với m, n là nguyên nhưng giá trị I(m, n) vẫn là giá trị vật lý liên tục. Quá trình biến đổi giá trị I(m,n) thành một số nguyên thích hợp để lưu trữ gọi là lượng tử hoá. Đây là quá trình ánh xạ một biến liên tục u vào biến rời rạc u* thuộc tập hữu hạn [u1, u2,..uL] xác định trước, L là mức lượng tử hoá được tạo ra. Ví dụ:  Với ảnh đa cấp xám thì L=256, f(m,n) = g  0, 255  Với ảnh 24 bit thì L=224, f(m, n) = g 0, 2 1 24  ", "order_start": 0, "order_end": 470, "word_count": 115}
{"parent_id": "e74d6022-a0e8-488c-862d-91030e84202e", "subject": "Xulyanh", "section": "2.3. MỘT SỐ PHƯƠNG PHÁP BIỂU DIỄN ẢNH", "title_path": "2.3. MỘT SỐ PHƯƠNG PHÁP BIỂU DIỄN ẢNH", "content": "[Xulyanh / 2.3. MỘT SỐ PHƯƠNG PHÁP BIỂU DIỄN ẢNH] Ảnh trên máy tính là kết quả thu nhận theo các phương pháp số hoá được nhúng trong các thiết bị kỹ thuật khác nhau. Cấu trúc dữ liệu để lưu trữ thông tin ảnh trong bộ nhớ có ảnh hưởng rất lớn đến việc hiển thị, in ấn và xử lý. Quá trình lưu trữ ảnh nhằm biểu diễn ảnh dưới dạng lưu trữ được với hai tiêu chí chính: Tiết kiệm bộ nhớ  Giảm thời gian xử lý Ảnh được biểu diễn theo hai mô hình cơ bản, ảnh Raster và ảnh Vector.", "order_start": 0, "order_end": 424, "word_count": 96}
{"parent_id": "4e512a7e-8cf5-4c1b-a8e2-8a62db6523e9", "subject": "Xulyanh", "section": "2.3.1. Mô hình Raster", "title_path": "2.3.1. Mô hình Raster", "content": "[Xulyanh / 2.3.1. Mô hình Raster] Đây là cách biểu diễn ảnh thông dụng nhất hiện nay, ảnh được biểu diễn dưới dạng ma trận các điểm (điểm ảnh). Thường thu nhận qua các thiết bị như camera, scanner. Tuỳ theo yêu cầu thực thế mà mỗi điểm ảnh được biểu diễn qua 1 hay nhiều bít. Mật độ điểm ảnh trên một đơn vị kích thước vật lý được gọi là độ phân giải. Ảnh có độ phân giải cao thì càng đẹp, càng mịn và càng thể hiện rõ chi tiết. Việc lựa chọn độ phân giải thích hợp tuỳ thuộc vào nhu cầu sử dụng và đặc trưng của mỗi ảnh cụ thể. Mô hình Raster thuận lợi cho hiển thị và in ấn. Ngày nay công nghệ phần cứng cung cấp những thiết bị thu nhận ảnh Raster phù hợp với tốc độ nhanh và chất lượng cao cho cả đầu vào và đầu ra. Một thuận lợi cho việc hiển thị trong môi trường Windows là Microsoft đưa ra khuôn dạng ảnh DIB (Device Independent Bitmap) làm trung gian. Hình 2.1 thể hình quy trình chung để hiển thị ảnh Raster thông qua DIB. Một trong những hướng nghiên cứu cơ bản trên mô hình biểu diễn này là kỹ thuật nén ảnh bao gồm cả nén bảo toàn và không bảo toàn.", "order_start": 0, "order_end": 1026, "word_count": 222}
{"parent_id": "4e512a7e-8cf5-4c1b-a8e2-8a62db6523e9", "subject": "Xulyanh", "section": "2.3.1. Mô hình Raster", "title_path": "2.3.1. Mô hình Raster", "content": "[Xulyanh / 2.3.1. Mô hình Raster] trình chung để hiển thị ảnh Raster thông qua DIB. Một trong những hướng nghiên cứu cơ bản trên mô hình biểu diễn này là kỹ thuật nén ảnh bao gồm cả nén bảo toàn và không bảo toàn. Hiện nay trên thế giới có trên 50 khuôn dạng ảnh thông dụng (BMP, TIF, GIF, PCX v.v..) bao gồm cả trong đó các kỹ thuật nén có khả năng phục hồi dữ liệu 100% và nén có khả năng phục hồi với độ sai số nhất định.", "order_start": 1026, "order_end": 1416, "word_count": 87}
{"parent_id": "e9b63080-a122-451e-a2cc-8c772ebcc8ae", "subject": "Xulyanh", "section": "2.3.2. Mô hình Vector", "title_path": "2.3.2. Mô hình Vector", "content": "[Xulyanh / 2.3.2. Mô hình Vector] Biểu diễn ảnh ngoài tiêu chí tiết kiệm không gian lưu trữ, dễ dàng cho hiển thị và in ấn còn cần đảm bảo dễ dàng trong lựa chọn, sao chép, di chuyển và tìm kiếm v.v.. Theo những yêu cầu này kỹ thuật biểu diễn Vector tỏ ra ưu việt hơn. Trong mô hình vector người ta sử dụng hướng giữa các vector của điểm ảnh lân cận để mã hoá và tái tạo hình ảnh ban đầu ảnh vector được thu nhận trực tiếp từ các thiết bị số hoá như Digital hoặc được chuyển đổi từ ảnh Raster thông qua các chương trình số hoá Công nghệ phần cứng cung cấp những thiết bị xử lý với tốc độ nhanh và chất lượng cho cả đầu vào và ra nhưng lại chỉ hỗ trợ cho ảnh Raster. Do vậy, những nghiên cứu về biểu diễn Vector đều tập trung vào việc chuyển đổi ảnh từ mô hình Raster.", "order_start": 0, "order_end": 733, "word_count": 161}
{"parent_id": "48927cc7-2cde-44a3-bfea-b2302cd6b28e", "subject": "Xulyanh", "section": "2.4. CÁC ĐỊNH DẠNG ẢNH CƠ BẢN", "title_path": "2.4. CÁC ĐỊNH DẠNG ẢNH CƠ BẢN", "content": "[Xulyanh / 2.4. CÁC ĐỊNH DẠNG ẢNH CƠ BẢN] Hiện nay trên thế giới có trên 50 khuôn dạng ảnh thông dụng. Sau đây là một số định dạng ảnh hay dùng trong quá trình xử lý ảnh hiện ay.", "order_start": 0, "order_end": 136, "word_count": 31}
{"parent_id": "bd9e10f9-468c-4e37-b8e0-e8d07aa58a16", "subject": "Xulyanh", "section": "2.4.1. Định dạng ảnh IMG", "title_path": "2.4.1. Định dạng ảnh IMG", "content": "[Xulyanh / 2.4.1. Định dạng ảnh IMG] Ảnh IMG là ảnh đen trắng, phần đầu của ảnh IMG có 16 byte chứa các thông tin:  6 byte đầu: dùng để đá nh dấu định ng ảnh. Giá trị của 6 byte này viết dưới dạng Hexa: 0x0001 0x0008 0x0001 2 byte tiếp theo: chứa độ dài mẫu tin. Đó là độ dài của dãy các byte kề liền nhau mà dóy này sẽ được lặp lại một số lần nào đó. Số lần lặp này sẽ được lưu trong byte đếm. Nhiều dãy giống nhau được lưu trong một byte. 4 byte tiếp: mô tả kích cỡ pixel. 2 byte tiếp: số pixel trên một dòng ảnh.  2 byte cuối: số dòng ảnh trong ảnh. Ảnh IMG được nén theo từng dòng, mỗi dòng bao gồm các gói (pack). Các dòng giống nhau cũng được nén thành một gói. Có 4 loại gói sau:  Loại 1: Gói các dòng giống nhau. Quy cách gói tin này như sau: 0x00 0x00 0xFF Count. Ba byte đầu tiên cho biết số các dãy giống nhau, byte cuối cho biết số các dòng giống nhau.  Loại 2: Gói các dãy giống nhau. Quy cách gói tin này như sau: 0x00 Count. Byte thứ hai cho biết số các dãy giống nhau được nén trong gói. Độ dài của dãy ghi ở đầu tệp. Loại 3: Dãy các Pixel không giống nhau, không lặp lại và không nén được.", "order_start": 0, "order_end": 1073, "word_count": 242}
{"parent_id": "bd9e10f9-468c-4e37-b8e0-e8d07aa58a16", "subject": "Xulyanh", "section": "2.4.1. Định dạng ảnh IMG", "title_path": "2.4.1. Định dạng ảnh IMG", "content": "[Xulyanh / 2.4.1. Định dạng ảnh IMG] : 0x00 Count. Byte thứ hai cho biết số các dãy giống nhau được nén trong gói. Độ dài của dãy ghi ở đầu tệp. Loại 3: Dãy các Pixel không giống nhau, không lặp lại và không nén được. Quy cách gói tin này như sau: 0x80 Count. Byte thứ hai cho biết độ dài dãy các pixel không giống nhau không nén được. Loại 4: Dãy các Pixel giống nhau. Tuỳ theo các bít cao của byte đầu tiên được bật hay tắt. Nếu bít cao được bật (giá trị 1) thì đây là gói nén các byte chỉ gồm bít 0, số các byte được nén được tính bởi 7 bít thấp còn lại. Nếu bớt cao tắt (giá trị 0) thì đây là gói nén các byte gồm toán bít 1. Số các byte được nén được tính bởi 7 bít còn lại. Các gói tin của file IMG rất đa dạng do ảnh IMG là ảnh đen trắng, do vậy chỉ cần 1 bít cho 1 pixel thay vì 4 hoặc 8 như đã nói ở trên. Toàn bộ ảnh chỉ có những điểm sáng và tối tương ứng với giá trị 1 hoặc 0. Tỷ lệ nén của kiểu định dạng này là khá cao.", "order_start": 1073, "order_end": 1969, "word_count": 211}
{"parent_id": "05623fc4-c790-47d3-b0f2-be22dd2a9fdf", "subject": "Xulyanh", "section": "2.4.2. Định dạng ảnh PCX", "title_path": "2.4.2. Định dạng ảnh PCX", "content": "[Xulyanh / 2.4.2. Định dạng ảnh PCX] Định dạng ảnh PCX là một trong những định dạng ảnh cổ điển. Nó sử dụng phương pháp mã hoá loạt dài RLE (Run – Length – Encoded) để nén dữ liệu ảnh. Quá trình nén và giải nén được thực hiện trên từng dạng ảnh. Thực tế, phương pháp giải nén PCX kém hiệu quả hơn so với kiểu IMG. Tệp PCX gồm 3 phần: đầu tệp (header), dữ liệu ảnh (Image data) và bảng màu mở rộng. Header của tệp PCX có kích thước cố định gồm 128 byte và được phân bố như sau:  1 byte: chỉ ra kiểu định dạng.Nếu là PCX/PCC thì nó luôn có giá trị là 0Ah.  1 byte: chỉ ra version sử dụng để nén ảnh, có thể có các giá trị sau:  0: version 2.5.  2: version 2.8 với bảng mà  3: version 2.8 hay 3.0 không có bảng màu.  5: version 3.0 cố bảng màu. a 1 byte: chỉ ra phươ g pháp mã hoá. Nếu là 0 thì mã hoá theo phương pháp BYTE PACKED, ngược lại à phương pháp RLE.  1 byte: Số bít cho một điểm ảnh phẳng (plane).  1 word: toạ độ góc tr của ảnh. Với kiểu PCX nó có giá trị là (0,0), cũn PCC thì khác (0,0).  1 word: toạ độ góc phải dưới.  1 word: kích thước bề rộng và bề cao của ảnh.  1 word: số điểm ảnh.", "order_start": 0, "order_end": 1072, "word_count": 248}
{"parent_id": "05623fc4-c790-47d3-b0f2-be22dd2a9fdf", "subject": "Xulyanh", "section": "2.4.2. Định dạng ảnh PCX", "title_path": "2.4.2. Định dạng ảnh PCX", "content": "[Xulyanh / 2.4.2. Định dạng ảnh PCX] góc tr của ảnh. Với kiểu PCX nó có giá trị là (0,0), cũn PCC thì khác (0,0).  1 word: toạ độ góc phải dưới.  1 word: kích thước bề rộng và bề cao của ảnh.  1 word: số điểm ảnh.  1 word: độ phân giải màn hình.  1 word. 48 byte: chia nó thành 16 nhóm, mỗi nhóm 3 byte. Mỗi nhóm này chứa thông tin về một thanh ghi màu. Như vậy ta có 16 thanh ghi màu. 1 byte: không dùng đến và luôn đặt là 0. 1 byte: số bớt plane mà ảnh sử dụng. Với ảnh 16 màu, giá trị này là 4, với ảnh 256 mầu (1pixel/8bits) thì số bít plane lại là 1. 1 byte: số bytes cho một dòng quét ảnh.  1 word: kiểu bảng màu.  58 byte: không dùng. Định dạng ảnh PCX thường được dùng để lưu trữ ảnh và thao tác đơn giản, cho phép nén và giải nén nhanh. Tuy nhiên, vì cấu trúc của nó cố định, nên trong một số trường hợp làm tăng kích thước lưu trữ. Cũng vì nhược điểm này mà một số ứng dụng sử dụng một kiểu định dạng khác mềm dẻo hơn: định dạng TIFF (Targed Image File Format) sẽ mô tả dưới đây.", "order_start": 1072, "order_end": 2031, "word_count": 221}
{"parent_id": "13acf3e5-4a68-48b0-90e9-d68a833db43e", "subject": "Xulyanh", "section": "2.4.3. Định dạng ảnh TIFF", "title_path": "2.4.3. Định dạng ảnh TIFF", "content": "[Xulyanh / 2.4.3. Định dạng ảnh TIFF] Kiểu định dạng TIFF được thiết kế để làm nhẹ bớt các vấn đề liên quan đến việc mở rộng file ảnh cố định. Về cấu trúc, nó cũng gồm 3 phần chính:  Phần Header (IFH): có trong tất cả các tệp TIFF và gồm 8 byte:  1 word: chỉ ra kiểu tạo tệp trên máy tính PC hay máy Macintosh. Hai loại này khác nhau rất lớn ở thứ tự các byte lưu trữ trong các số dài 2 hay 4 byte. Nếu trường này có giá trị là 4D4Dh thì đó là ảnh cho máy Macintosh, nếu là 4949h là của máy PC.  1 word: version. từ này luôn có giá trị là 42. đây là đặc trưng của file TIFF và không thay đổi.  2 word: giá trị Offset theo byte tính từ đầu tới cấu trúc IFD là cấu trúc thứ hai của file. Thứ tự các byte này phụ thuộc vào dấu hiệu trường đầu tiên.  Phần thứ 2 (IFD): Không ở ngay sau cấu trúc IFH mà vị trí được xác định bởi trường Offset trong đầu tệp. Có thể có một hay nhiều IFD cùng tồn tại trong một file. Một IFD bao gồm:  2 byte: chứa các DE (Directory E  12 byte là các DE xếp liên tiếp, mỗi DE chiếm 12 byte.  4 byte: chứa Offset trỏ tới IFD tiếp theo. Nếu đây là IFD cuối cùng thì trường này có giá trị 0.", "order_start": 0, "order_end": 1083, "word_count": 251}
{"parent_id": "13acf3e5-4a68-48b0-90e9-d68a833db43e", "subject": "Xulyanh", "section": "2.4.3. Định dạng ảnh TIFF", "title_path": "2.4.3. Định dạng ảnh TIFF", "content": "[Xulyanh / 2.4.3. Định dạng ảnh TIFF] chứa các DE (Directory E  12 byte là các DE xếp liên tiếp, mỗi DE chiếm 12 byte.  4 byte: chứa Offset trỏ tới IFD tiếp theo. Nếu đây là IFD cuối cùng thì trường này có giá trị 0.  Phần thứ 3: các DE: các DE có dộ dài cố định gồm 12 byte và chia làm 4 phần:  2 byte: chỉ ra dấu hiệu mà file ảnh đó được xây dựng.  2 byte: kiểu dữ liệu của tham số ảnh. Có 5 kiểu tham số cơ bản: 1: BYTE (1 byte) 2: ASCII (1 byte) 3: SHORT (2 byte). 4: LONG (4 byte) 5: RATIONAL (8 byte)  4 byte: trường độ dài chưa số lượng chỉ mục của kiểu dữ liệu đó chỉ ra. Nó không phải là tổng số byte cần thiết để lưu trữ. Để có số liệu này ta cần nhân số chỉ mục với kiểu dữ liệu đã dùng.  4 byte: đó là Offset tới điểm bắt đầu dữ liệu liên quan tới dấu hiệu, tức là liên quan với DE không phải lưu trữ vật lý cùng với nó nằm ở một vị trí nào đó trong file. Dữ liệu chứa trong tệp thường được tổ chức thành các nhóm dòng (cột) quét của dữ liệu ảnh. Cách tổ chức này làm giảm bộ nhớ cần thiết cho việc đọc tệp. Việc giải nén được thực hiện theo 4 kiểu khác nhau được lưu trữ trong byte dấu hiệu nén.", "order_start": 1083, "order_end": 2160, "word_count": 254}
{"parent_id": "cc3b6272-820a-41de-8387-cbb222e18a6c", "subject": "Xulyanh", "section": "2.4.4. Định dạng file ảnh BITMAP", "title_path": "2.4.4. Định dạng file ảnh BITMAP", "content": "[Xulyanh / 2.4.4. Định dạng file ảnh BITMAP] Mỗi file BITMAP gồm đầu file chứa các thông tin chung về file, đầu thông tin chứa các thông tin về ảnh, một bảng màu và một mảng dữ liệu ảnh. Khuôn dạng được cho như sau: BITMAPFILEHEADER bmfh; BITMAPINFOHEADER bmih; RGBQUAD aColors[]; BYTE aBitmapBits[]; Trong đó, các cấu trúc được định nghĩa như sau: typedef struct tagBITMAPFILEHEADER { /* bmfh */ UINT bfType; DWORD bfSize; UINT bfReserved1; UINT bfReserved2; DWORD bfOffBits; } BITMAPFILEHEADER typedef struct tagBITMAPINFOHEADER { /* bmih */ DWORD biSize; LONG bi Width; LONG biHeig ht; WORD biPlanes; WORD biBitCount; DWORD biCompression; DWORD biSizeImage; LONG biXPelsPerMeter; LONG biYPelsPerMeter; DWORD biClrUsed; DWORD biClrImportant; } BITMAPINFOHEADER, *LPBITMAPINFOHEADER; Với biến chi tiết như sau typedef struct tagRGBQUAD { /* rgbq BYTE rgbBlu (, BYTE rgbGr n; BYTE bRed; BYTE rgbR e served; } RGBQUAD; typedef struct tagBITMAPINFO { BITMAPINFOHEADER bmiHeader; RGBQUAD bmiColors[1]; } BITMAPINFO, *PBITMAPINFO;", "order_start": 0, "order_end": 981, "word_count": 145}
{"parent_id": "e5512e7d-2f45-40e5-a0f0-2006e818163d", "subject": "Xulyanh", "section": "2.5.1 Kỹ thuật chụp ảnh", "title_path": "2.5.1 Kỹ thuật chụp ảnh", "content": "[Xulyanh / 2.5.1 Kỹ thuật chụp ảnh] Phương pháp sao chụp ảnh là phương pháp đơn giản, giá thành thấp, chất lượng cao. Sau bước chụp là kỹ thuật phòng tối nhằm tăng cường ảnh như mong muốn. Ví dụ kỹ thuật phòng tối như: phóng đại ảnh, thu nhỏ ảnh…, tùy theo ứng dụng. Kỹ thuật chụp ảnh màn hình màu khá đơn giản. Nó bao gồm các bước sau:  Đặt camera trong phòng tối, cách màn hình khoảng 10 feet (1feet=0,3048m)  Mở ống kính để phẳng mặt cong màn hình, do vậy ảnh sẽ dàn đều hơn  Tắt phím sang tối (Brightness) và phím tương phản (Contrast) của màn hình để tạo độ rõ cho ảnh. Các màu chói, cường độ cao trên ảnh sẽ giảm đi.  Đặt tốc độ ống kính từ 1/8 đến 1/2 giây.", "order_start": 0, "order_end": 632, "word_count": 136}
{"parent_id": "24580091-94a7-4e59-8795-433150d1ff83", "subject": "Xulyanh", "section": "2.5.2 Kỹ thuật in ảnh", "title_path": "2.5.2 Kỹ thuật in ảnh", "content": "[Xulyanh / 2.5.2 Kỹ thuật in ảnh] Người ta dùng kỹ thuật nửa cường độ để thể hiện ảnh trên sách báo, tạp chí. Theo kỹ thuật này, một ảnh tạo nên bởi một chuỗi các điểm in trên giấy. Thực chất, mỗi điểm ảnh có thể được coi là một hình vuông trắng bao quanh một chấm đen. Do vậy, nếu chấm đen càng lớn điểm ảnh sẽ càng xẫm màu. Màu xám có thể coi như chấm đen chiếm nửa vùng trắng. Vùng trắng là vùng gồm một chùm các điểm ảnh có rất ít hoặc không có chấm đen. Từ đặc điểm cảm nhận của mắt người, sự thay đổi cường độ chấm đen trong các phần tử ảnh trắng tạo nên mô phỏng của một ảnh liên tục. Như vậy, mắt người cảm nhận từ một ảnh mà màu biến đổi từ đen qua xám rồi đến trắng. Tổng số cường độ duy nhất hiện diện sẽ xác định các kích thước khác nhau của chấm đen. Thông thường, báo ảnh tạo ảnh nửa cường độ với độ phân giải từ 60 đến 80 DPI(dot per inchs: số điểm ảnh trên một inch), sách có thể in đến 150 DPI.", "order_start": 0, "order_end": 877, "word_count": 197}
{"parent_id": "24580091-94a7-4e59-8795-433150d1ff83", "subject": "Xulyanh", "section": "2.5.2 Kỹ thuật in ảnh", "title_path": "2.5.2 Kỹ thuật in ảnh", "content": "[Xulyanh / 2.5.2 Kỹ thuật in ảnh] ch thước khác nhau của chấm đen. Thông thường, báo ảnh tạo ảnh nửa cường độ với độ phân giải từ 60 đến 80 DPI(dot per inchs: số điểm ảnh trên một inch), sách có thể in đến 150 DPI. Tuy nhiên, các máy in ghép nối với máy tính không có khả năng sắp xếp các chấm đen có kích thước khác nhau của ảnh, vì vậy chúng ta cần các kỹ thuật nửa cường độ kỹ thuật số (Digital Halftoning): phân ngưỡng, chọn mẫu (Patterning), Dithering hoặc khuếch tán lỗi (Error Diffusion).", "order_start": 877, "order_end": 1338, "word_count": 94}
{"parent_id": "85bf3862-1727-4491-a6e3-922653781a86", "subject": "Xulyanh", "section": "a) Phân ngưỡng", "title_path": "a) Phân ngưỡng", "content": "[Xulyanh / a) Phân ngưỡng] Kỹ thuật này đặt ngưỡng để hiển thị các tông màu liên tục. Các điểm trong ảnh được so sánh với ngưỡng định trước. Giá trị của ngưỡng sẽ quyết định điểm có được hiển thị hay không. Do vậy ảnh kết uả sẽ mất đi một số chi tiết. Có nhiều kỹ thuật chọn ngưỡng áp dụng cho các đối tượng khác nhau: Hiển thị 2 màu: chỉ dùng ảnh đen trắng có 256 mức xám. Bản chất của phương pháp này là chọn ngưỡng dựa trên lược đồ mức xám của ảnh. Để đơn giản có thể lấy ngưỡng với giá trị là 127. Như vậy nghĩa là các điểm có giá trị điểm ảnh lớn hơn 127 sẽ là 1, ngược lại là 0. Hiển thị 4 màu: sử dụng 4 màu để khắc phục nhược điểm của kỹ thuật hiển thị 2 màu. Một ví dụ của Bảng mã 4 mầu được cho ở Bảng 2.1.", "order_start": 0, "order_end": 689, "word_count": 160}
{"parent_id": "ef0102fc-91af-4574-9580-965bd1bcdf10", "subject": "Xulyanh", "section": "b) Kỹ thuật chọn theo mẫu (Patterning)", "title_path": "b) Kỹ thuật chọn theo mẫu (Patterning)", "content": "[Xulyanh / b) Kỹ thuật chọn theo mẫu (Patterning)] Kỹ thuật này sử dụng một nhóm các phần tử trên thiết bị ra (máy in chẳng hạn) để biểu diễn một pixel trên ảnh nguồn. Các phần tử của nhóm quyết định độ sáng tối của cả nhóm. Các phần tử này mô phỏng các chấm đen trong kỹ thuật nửa cường độ. Nhóm thường được chọn có dạng ma trận vuông. Nhóm nn phần tử sẽ tạo nên n2 +1 mức sáng. Ma trận mẫu thường được chọn là ma trận Rylander. Ma trận Rylander cấp 4 có dạng như Bảng 2.2. Việc chọn kích thước của nhóm như vậy sẽ làm giảm độ mịn của ảnh. Vì vậy kỹ thuật này chỉ áp dụng trong trường hợp mà độ phân giải của thiết bị ra lớn hơn độ phân giải của ảnh nguồn. Ví dụ: thiết bị ra có độ phân giải 640480 khi sử dụng nhóm có kích thước 44 sẽ chỉ còn 160120.", "order_start": 0, "order_end": 705, "word_count": 158}
{"parent_id": "c3b0db50-d6a0-44dd-8762-d176c6a75f3f", "subject": "Xulyanh", "section": "c) Kỹ thuật Dithering", "title_path": "c) Kỹ thuật Dithering", "content": "[Xulyanh / c) Kỹ thuật Dithering] Dithering là việc biế ổi một ản đa cấp xám (nhiều mức sáng tối) sang ảnh nhị phân (hai mức sáng tối) Kỹ thuật Dithering đựợc áp dụng để tạo ra ảnh đa cấp sáng khi độ phân giải nguồn và đích là như nhau. Kỹ thuật này sử dụng một ma trận mẫu gọi là ma trận Dither. Ma trận này gần giống như ma trận Rylander. Để tạo ảnh, mỗi phần tử của ảnh gốc sẽ được so sánh với phần tử tương ứng của ma trận Dither. Nếu lớn hơn, phần tử ở đầu ra sẽ sáng và ngược lại.", "order_start": 0, "order_end": 452, "word_count": 103}
{"parent_id": "1c588d47-9427-420c-87a9-205201e35a8e", "subject": "Xulyanh", "section": "d) Kỹ thuật khuếch tán lỗi (Error diffusion)", "title_path": "d) Kỹ thuật khuếch tán lỗi (Error diffusion)", "content": "[Xulyanh / d) Kỹ thuật khuếch tán lỗi (Error diffusion)] Khuếch tán lỗi cho phép giảm thiểu mức độ mất chi tiết của ảnh khi tách ngưỡng bằng cách phân tán lỗi do lượng tử hóa ra các điểm ảnh xung quanh. Bằng cách này tổng giá trị điểm ảnh của một vùng nhỏ được giữ tương đối gần với giá trị trên ảnh gốc. Khuếch tán lỗi có hai dạng, khuếch tán lỗi một chiều và khuếch tán lỗi hai chiều. Khuếch tán lỗi một chiều chỉ phân tán lỗi sang điểm ảnh lân cận trên cùng một dòng trong khi đó khuếch tán lỗi hai chiều phân tán lỗi sang các điểm ảnh lân cận theo một tỷ lệ xác định bởi một ma trận khuếch tán lỗi.", "order_start": 0, "order_end": 545, "word_count": 120}
{"parent_id": "a4eb034d-e1c3-4753-8427-a61afa57f8ff", "subject": "Xulyanh", "section": "Kỹ thuật khuếch tán lỗi một chiều:", "title_path": "Kỹ thuật khuếch tán lỗi một chiều:", "content": "[Xulyanh / Kỹ thuật khuếch tán lỗi một chiều:] o Ảnh được duyệt từ trái qua phải, từ trên xuống dưới. o Tại mỗi điểm ảnh, giá trị điểm ảnh được tách theo ngưỡng có sẵn. o Phần dư do lượng tử hóa được được chuyến sang điểm ảnh tiếp theo trên cùng dòng. o Các bước được lặp lại cho đến hết dòng, phần dư của điểm ảnh cuối cùng sẽ được loại bỏ. Kỹ thuật khuếch tán lỗi hai chiều: o Các bước được thực hiện như khuếch tán lỗi một chiều, tuy nhiên lỗi do lượng tử hóa sẽ đươc phân tán ra các điểm xung quanh theo tỷ lệ xác định bởi ma trận khuếch tán o Có hai ma trận phổ biến (Hình 2.3): Ma trận của Floyd và Steinberg.  Ma trận của J F Jarvis, C N Judice, và W H Ninke tại phòng thí nghiệm Bell. Floyd và Steinberg Phòng thí nghiệm Bell \"#\" chỉ điểm đang xét và \"\" chỉ các điểm đã xét, các con số chỉ tỷ lệ lỗi được phântán từ điểm hiện tại", "order_start": 0, "order_end": 792, "word_count": 177}
{"parent_id": "ca8cdbcd-e7c8-4ba7-bbeb-0220fccfc5f9", "subject": "Xulyanh", "section": "2.6. KHÁI NIỆM ẢNH ĐEN TRẮNG, ẢNH MÀU", "title_path": "2.6. KHÁI NIỆM ẢNH ĐEN TRẮNG, ẢNH MÀU", "content": "[Xulyanh / 2.6. KHÁI NIỆM ẢNH ĐEN TRẮNG, ẢNH MÀU] Ảnh trong thực tế là một ảnh liên tục về không gian và giá trị cường độ sáng. Để có thể xử lý ảnh bằng máy tính người ta cần thiết phải số hóa ảnh. Trong quá trình số hóa, ta biến đổi tín hiệu liên tục sa tín hiệu rời rạc thông qua quá trình lấy mẫu (rời rạc hóa về không gian) và lượng hóa thành phần giá trị mà về nguyên tắc bằng mắt thường không phân biệt được hai điểm kề nhau. Một ảnh sẽ là một tập hợp các phần tử ảnh (Picture element) hay còn được gọi là Pixel. Như vậy, ảnh số là một tập hợp các điểm ảnh. Khi được số hóa, nó thường được biểu diễn bởi một mảng hai chiều I(n,p) với n là số dòng và p là số cột. Ta nói ảnh gồm np pixels. Người ta thường ký hiệu I(x,y) để chỉ một pixel I chính là giá trị cường độ sáng của ảnh tại pixel đó. Ảnh có thể được biểu diễn với các độ phân giải khác nhau. Một pixel có thể được lưu trữ trên 1, 4, 8 hay 24 bit tùy thuộc vào các mức cường độ sáng cần phân biệt của ảnh và số lượng thành phần mầu cơ bản chứa trong ảnh đó.", "order_start": 0, "order_end": 971, "word_count": 222}
{"parent_id": "bb39738b-253f-4020-9905-8169d455987f", "subject": "Xulyanh", "section": "2.6.1. Phân loại ảnh số", "title_path": "2.6.1. Phân loại ảnh số", "content": "[Xulyanh / 2.6.1. Phân loại ảnh số] Người ta thường chia ảnh số ra làm ba loại chính là:  Ảnh đen trắng: Mỗi phần tử ảnh nhận một trong hai giá trị tương ứng với hai mức sáng đen và trắng (còn gọi là ảnh nhị phân) Ảnh đa mức xám (Grayscale): Các phần tử ảnh chứa thông số về cường độ sáng đã được mã hoá thành N mức (8, 256 hoặc nhiều hơn) tương ứng với 3 bít, 8 bít hoặc hơn nữa, ảnh xám có một đặc trưng là lược đồ xám (histogram). Ảnh mầu: Mỗi phần tử ảnh được lưu trữ trong ảnh dưới dạng một cấu trúc có 3 trường chứa thông tin về 3 màu cơ bản là đỏ, xanh, lơ (red, blue, green). Màu của ảnh sẽ là tổng hợp của 3 giá trị trên. Mỗi trường biểu diễn giá trị màu có thể dùng 8 bít, 16 bít hược 24 bit để mã hoá. Như vậy ảnh màu là ảnh mang thông tin về đối tượng đầy đủ nhất so với ảnh đen trắng và ảnh đa cấp xám. Tuy nhiên, tất cả cách biểu diễn này đều chỉ là sự mô phỏng hệ màu trong tự nhiên. Thực tế thì một màu được phân biệt qua 3 thuộc tính là độ chói (Itensity), sắc thái màu (Hue) và độ bão hoà (Saturation).", "order_start": 0, "order_end": 985, "word_count": 225}
{"parent_id": "bb39738b-253f-4020-9905-8169d455987f", "subject": "Xulyanh", "section": "2.6.1. Phân loại ảnh số", "title_path": "2.6.1. Phân loại ảnh số", "content": "[Xulyanh / 2.6.1. Phân loại ảnh số] iểu diễn này đều chỉ là sự mô phỏng hệ màu trong tự nhiên. Thực tế thì một màu được phân biệt qua 3 thuộc tính là độ chói (Itensity), sắc thái màu (Hue) và độ bão hoà (Saturation). Tuy nhiên với khả năng cảm nhận của mắt người thì cách biểu diễn ảnh dưới dạng cấu trúc 3 màu RGB chất lượng ảnh thu được là có thể chấp nhận được.", "order_start": 985, "order_end": 1313, "word_count": 72}
{"parent_id": "a8ee498c-26e6-40f6-a9bd-5a39339f3389", "subject": "Xulyanh", "section": "2.6.2. Màu sắc", "title_path": "2.6.2. Màu sắc", "content": "[Xulyanh / 2.6.2. Màu sắc] Màu sắc được tạo ra bởi các ánh sáng với các bước sóng khác nhau, mắt người bao gồm ba loại tế bào cảm nhận mầu có thể nhìn được bảy triệu màu nhưng thực chất chúng ta chỉ có thể cảm nhận sự khác biệt vài ngàn màu. Một màu có thể được biểu diễn bởi ba thuộc tính: Sắc thái màu (Hue), độ bão hòa (Saturation), và độ chói (Itensity). Trong xử lý ảnh và đồ họa, mô hình màu là một chỉ số kỹ thuật của một hệ tọa độ màu 3 chiều có thể dùng để biểu diễn tất cả các màu. Ví dụ như mô hình màu RGB (Red, Green, Blue): là một đơn vị tập các màu thành phần sắp xếp theo hình lập phương của hệ trục tọa độ Đề các. Mục đích của mô hình màu là cho phép biểu diễn một phần các mầu nhìn thấy được bằng các chỉ số kỹ thuật quy ước. Sau đây, ta xem xét một số mô hình hay được sử dụng nhất.", "order_start": 0, "order_end": 774, "word_count": 178}
{"parent_id": "1c48c179-47cb-48f1-95ee-4e6cf91fde5f", "subject": "Xulyanh", "section": "2.6.2.1. Mô hình màu RGB (Red, Green, Bule", "title_path": "2.6.2.1. Mô hình màu RGB (Red, Green, Bule", "content": "[Xulyanh / 2.6.2.1. Mô hình màu RGB (Red, Green, Bule] Màu đỏ, lục – xanh lá ây, l xanh da trời (RGB) được sử dụng phổ biến nhất trong hiển thị. Các mầu gốc ày được t hợp với nhau theo một tỷ lệ để tái tạo mầu sắc, hệ mầu này sử dụng phối màu cộn . Tập hợp các mầu được sắp xếp theo khối lập phương đơn vị. Đường chéo chính của khối lập phương thể hiện các mầu được phối bởi ba mầu gốc với tỷ lệ tương đương nhau ứng với các mức độ xám từ đen là (0,0,0) t trắng (1,1,1).", "order_start": 0, "order_end": 415, "word_count": 97}
{"parent_id": "5397e118-07a9-4601-b553-e5279808ff82", "subject": "Xulyanh", "section": "2.6.2.2. Mô hình màu CMY (Cyan, Magenta, Yellow)", "title_path": "2.6.2.2. Mô hình màu CMY (Cyan, Magenta, Yellow)", "content": "[Xulyanh / 2.6.2.2. Mô hình màu CMY (Cyan, Magenta, Yellow)] Xanh nhạt (Cyan), vàng (Yellow) và tím (Magenta) là các phần bù tương ứng cho các màu đỏ, lục và lam. Chúng có thể được sử dụng để lọc loại trừ các màu này từ ánh sáng trắng. Vì vậy CMY còn được gọi là các phần bù loại trừ của màu gốc. Các mầu trong hệ mầu CMY cũng được biểu diễn trong hệ tọa độ Đề-các nhưng phương pháp phối màu sử dụng là phối màu trừ. Các màu được tạo thành bằng cách loại bỏ hoặc được bù từ ánh sáng trắng thay vì là được thêm vào vùng tối. Khi bề mặt được bao phủ bởi lớp mực màu xanh tím, sẽ không có tia màu đỏ phản chiếu từ bề mặt đó. Màu xanh tím đã loại bỏ phần màu đỏ phản xạ khi có tia sáng trắng, mà bản chất là tổng của 3 màu đỏ, lục, lam. Vì thế ta có thể coi màu Cyan là màu trắng trừ đi màu đỏ và đó cũng là mà lam cộng màu lục. Tương tự như vậy ta có màu đỏ thẫm (magenta) hấp thụ màu lục, v thế nó tương đương với màu đỏ cộng màu lam. Và cuối cùng màu vàng (yellow) h thụ màu lam, nó sẽ bằng màu đỏ cộng với lục. Khi bề mặt của thực thể được bao phủ bởi xanh tím và vàng, chúng sẽ hấp thụ hết các phần màu đỏ và xanh lam của bề mặt.", "order_start": 0, "order_end": 1069, "word_count": 250}
{"parent_id": "5397e118-07a9-4601-b553-e5279808ff82", "subject": "Xulyanh", "section": "2.6.2.2. Mô hình màu CMY (Cyan, Magenta, Yellow)", "title_path": "2.6.2.2. Mô hình màu CMY (Cyan, Magenta, Yellow)", "content": "[Xulyanh / 2.6.2.2. Mô hình màu CMY (Cyan, Magenta, Yellow)] vàng (yellow) h thụ màu lam, nó sẽ bằng màu đỏ cộng với lục. Khi bề mặt của thực thể được bao phủ bởi xanh tím và vàng, chúng sẽ hấp thụ hết các phần màu đỏ và xanh lam của bề mặt. Khi đó chỉ tồn tại duy nhất màu lục bị phản xạ từ sự chiếu sáng của ánh sáng trắng. Trong trường hợp khi bề mặt được bao phủ bởi cả 3 màu xanh tím, vàng, đỏ thẫm, hiện tượng hấp thụ xảy ra trên cả 3 màu đỏ, lục và lam. Do đó, màu đen sẽ màu của bề mặt. Những mối liên hệ này có thể được miêu tả bởi:", "order_start": 1069, "order_end": 1549, "word_count": 115}
{"parent_id": "4084344e-932d-4071-af6e-84c0b8596048", "subject": "Xulyanh", "section": "2.6.2.3. Mô hình màu HSV (Hue, Saturation, Value)", "title_path": "2.6.2.3. Mô hình màu HSV (Hue, Saturation, Value)", "content": "[Xulyanh / 2.6.2.3. Mô hình màu HSV (Hue, Saturation, Value)] Các mô hình màu RGB, CMY có thể hiển thị được tất cả các mầu cần thiết, tuy vậy rất khó khắn để con người có thể phối mầu trên hai hệ màu này. Để phối mầu dễ dàng hơn Smith định nghĩa mô hình màu HSV của hay HSB với B là Brightness (độ sáng) hướng người sử dụng dựa trên cơ sở nền tảng trực giác về tông màu, sắc độ và sắc thái mỹ thuật. Hệ thống tọa độ có dạng hệ hình trụ và tập màu thành phần của không gian bần của không gian bên trong mô hình màu được xác định lợc là hình nón như trong hình 2.7. Sắc màu (hue) hoặc H đặc được đo bởi góc quanh trục đứng với mục màu đỏ là 0o , màu lục là 120o , màu lam là 240o . Các màu bù nằm ở vị trí đối diện với những mững màu gốc. S lấy giá trị từ 0 trên đường trục tâm (trục V) đến 1 trờng trên các mặt bên tại của hình chóp sáu cình cạnh. Sự bão hòa được hiểu là mức độ tức tươi của mầu, các mầu xám từ đen tới trắng có Sủa trắng có là 0. Giá trị V được hiểu là độ sáng của mộ màu, V là 0 thì là màu đen, V là 1 thì là mầu có độ sáng tối đa.", "order_start": 0, "order_end": 987, "word_count": 239}
{"parent_id": "4084344e-932d-4071-af6e-84c0b8596048", "subject": "Xulyanh", "section": "2.6.2.3. Mô hình màu HSV (Hue, Saturation, Value)", "title_path": "2.6.2.3. Mô hình màu HSV (Hue, Saturation, Value)", "content": "[Xulyanh / 2.6.2.3. Mô hình màu HSV (Hue, Saturation, Value)] à mức độ tức tươi của mầu, các mầu xám từ đen tới trắng có Sủa trắng có là 0. Giá trị V được hiểu là độ sáng của mộ màu, V là 0 thì là màu đen, V là 1 thì là mầu có độ sáng tối đa.ầu có độ sáng", "order_start": 987, "order_end": 1180, "word_count": 52}
{"parent_id": "85027a97-d413-4621-8f3e-bf47a796c1d0", "subject": "Xulyanh", "section": "Giả mã chuyển đổi từ RGB sang HSVển", "title_path": "Giả mã chuyển đổi từ RGB sang HSVển", "content": "[Xulyanh / Giả mã chuyển đổi từ RGB sang HSVển] Hàm RGB_HSV_Conversion H: Sắc độ màu [0àu [0-360] với màu đỏ tại iểm 0 S: Độ bão hòa [0ão [0-1] đại Min: Hàm lấy giá trị nhỏ nấy t { //Xác định giịnh tr ccường độ sáng V= Max(R,G,B) //Xác định độ bịnh bão òa Temp= Min(R,G,B) If V=0 than S= 0 Else S= (V-Temp)/VTemp)/V End //Xác định sắc mịnh màu IF s=0 THEN H= Undefined Else Cr= (V-R)/(VR)/(V-Temp); Cg= (V-G)/(VG)/(V-Temp); Cb= (V-B)/(VB)/(V-Temp); // Màu nằm trong khoảng giữa vằm vàng (Yelloàng If R=V then H= Cb-CgCg // Màu nằm trong khoảng giữa xanh tím (cyan) và vàng (yellow) If G= V then H= 2+Cr-Cb // Màu nằm trong khoảng giữa đỏ tươi (magenta) và xanh (cyan) If B=V then H= 4+ Cg – Cr H= 60*H // Chuyển sang độ //Loại các giá trị âm If H < 0 then H= H+360", "order_start": 0, "order_end": 716, "word_count": 143}
{"parent_id": "271a6279-6dcd-4d25-8ca0-a6cdaf18f0b6", "subject": "Xulyanh", "section": "Giả mã chuyển đổi từ HSV sang RGB", "title_path": "Giả mã chuyển đổi từ HSV sang RGB", "content": "[Xulyanh / Giả mã chuyển đổi từ HSV sang RGB] Hàm HSV_RGB_Conversion() H: Sắc độ màu [0-360] với màu đỏ tại điểm 0 S: Độ bão hòa [0-1] V: Giá trị cường độ sáng [0-1] { //Kiểm tra trường hợ ánh màu If S=0 then H=Undefined thenR= VG= V Endif Else If H=36 e H= 0 Else H= H/60 endif I= Floor(H) F= H-I M= V*(1-S) N= V*(1-S*F) K= V*(1-S*(1-F)) //(R,G,B)=(V,K,M)  R= V; C= K; B= M If I=0 then (R,G,B)=(V,K,M); If I=1 then (R,G,B)=(N,V,M); If I=2 then (R,G,B)=(M,V,K); If I=3 then (R,G,B)=(M,N,V); If I=4 then (R,G,B)=(K,M,V); If I=5 then (R,G,B)=(V,M,N); }", "order_start": 0, "order_end": 505, "word_count": 93}
{"parent_id": "311d8c00-6f15-4bd2-b7f2-6572051bbb40", "subject": "Xulyanh", "section": "2.6.2.4. Mô hình màu HS.2.4. HSL", "title_path": "2.6.2.4. Mô hình màu HS.2.4. HSL", "content": "[Xulyanh / 2.6.2.4. Mô hình màu HS.2.4. HSL] Mô hình màu HSLL tương tự như mô hình HSV nhưng thay vì biì biểu diễn tập hợp màu hình nón sáu như mô hư hình HSV thì HSL biểu diễn các tập hợp màu hình chóp àu đôi dưới dạng không gian hình trụ. Sắc mụ. màu H (hue) vẫn là góc quanh trục đứng với mục màu đỏ tại góc 0o . Chúng ta có thể xem hệ mầu HSL như một sự biến dạng của hệ HSVHSV.", "order_start": 0, "order_end": 337, "word_count": 80}
{"parent_id": "5af3bd41-4e27-4224-b9ae-22cf9a4d4347", "subject": "Xulyanh", "section": "Giả mã chuyển đổi từ RGB sang Hển HSL", "title_path": "Giả mã chuyển đổi từ RGB sang Hển HSL", "content": "[Xulyanh / Giả mã chuyển đổi từ RGB sang Hển HSL] Hàm RGB_HLS_Conversion() H: Sắc độ màu [0àu [0 360] với màu đỏ tại điểm 0 S: Độ bão hòa [0ão [0-1] V: Giá trị cường độ sáng [0ờng [0-1] Max: Hàm lấy giá trị cực đạiấy Min: Hàm lấy giá trị nhỏ nhấtấy { //Xác định độ sángịnh M1= Max(R,G,B) M2= Min(R,G,B) L= (M1+M2) //Xác định độ bịnh bão hòa If M1=M2 //Trư//Trường hợp không màu S= 0 H= Undefined Else If L <= 0.5 then //Trư//Trường hợp màu S= (M1-M2)/(M1+M2)M2)/(M1+M2) Else S= (M1-M2)/(2M2)/(2-M1-M2)", "order_start": 0, "order_end": 451, "word_count": 84}
{"parent_id": "af87f402-0834-419c-8f9e-d4faea13e024", "subject": "Xulyanh", "section": "Untitled", "title_path": "Untitled", "content": "[Xulyanh / Untitled] Endif //Xác định sắc độ Cr= (M1-R)/(M1-M2) Cg= (M1-G)/(M1-M2) Cb= (M1-B)/(M1-M2) if R=M1 then H= Cb-Cg If G=M1 then H= 2+Cr-Cb If B=M1 then H= 4+Cg-Cr H= H*60 if H<0 then H= H+360 endif }", "order_start": 0, "order_end": 187, "word_count": 35}
{"parent_id": "00cc38cf-40c5-4b1b-be20-fc10892250a6", "subject": "Xulyanh", "section": "Giả mã chuyển đổi từ HSL sang RGB", "title_path": "Giả mã chuyển đổi từ HSL sang RGB", "content": "[Xulyanh / Giả mã chuyển đổi từ HSL sang RGB] Hàm HLS_RGB_Conversion() đi 0 S: Độ bão hòa [0-1] V: Giá trị cường độ { If L <= 0.5 t M2= L*(1+ Else M2= L+S-L*S Endif M1= 2*L-M2 //Kiểm tra độ bão hòa = 0 If S=0 then If H=Undefined R=L G=L B=L Else //Error: Dữ liệu nhập sai Endif Else //Xác định giá trị của RGB RGB(H+120, M1,M2,Value) R= Value RGB(H, M1,M2,Value) G= Value RGB(H-120, M1,M2,Value) B= Value Endif } //Hàm điều chỉnh giá trị của H cho phù hợp khoảng xác định Hàm RGB(H, M1, M2, Value) { If H < 0 then H= H+360 If H < 60 then Value= M1+(M2-M1)*H/60 If H >=60 and H < 180 then Value= M2 If H>= 180 and H < 240 then Value = M1+(M2-M1)*(240-H)/60 If H > 240 and H <= 360 then Value= M1 Return }", "order_start": 0, "order_end": 657, "word_count": 138}
{"parent_id": "80d10eb3-662a-43ff-8ef0-9b2319bea0b9", "subject": "Xulyanh", "section": "2.7. CÂU HỎI ÔN TẬP CHƯƠNG", "title_path": "2.7. CÂU HỎI ÔN TẬP CHƯƠNG", "content": "[Xulyanh / 2.7. CÂU HỎI ÔN TẬP CHƯƠNG] Câu 1: Thế nào là mô hình Raster và Vector? Trình bày sự giống và khác nhau của hai mô hình này. Câu 2: Nêu các định dạng ảnh phổ biến. Trình bày cách nén ảnh của định dạng anh BITMAP. Câu 3: Kỹ thuật khuếch tán lỗi (Error diffusion) là gì? Thực hiện khuếch tán lỗi một chiều với ảnh sau, được biết ngưỡng là 127. Câu 4: Kỹ thuật khuếch tán lỗi hai chiều khác gì với một chiều. Thực hiện khuếch tán lỗi hai chiều với ảnh ở câu 3 sử dụng ma trận khuếch tán lỗi Floyd và Steinberg, được biết ngưỡng là 127. Câu 5: Hệ mầu HSL và HSV được phát triển vì mục đích gì? Dựa theo giả mã đã trình bày ở trên, hãy viết một phần mềm nhỏ có thể chuyển ảnh giữa các hệ mầu RGB, CMY, HSV và HSV.", "order_start": 0, "order_end": 680, "word_count": 150}
{"parent_id": "3b225f51-66ed-4118-96de-0d089debca8f", "subject": "Xulyanh", "section": "3.1.1. Giới thiệu", "title_path": "3.1.1. Giới thiệu", "content": "[Xulyanh / 3.1.1. Giới thiệu] Các phép toán không phụ thuộc không gian là các phép toán không phục thuộc vị trí của điểm ảnh. Ví dụ: Phép tăng giảm độ sáng, phép thống kê tần suất, biến đổi tần suất v.v.. Một trong những khái niệm quan trọng trong xử lý ảnh là biểu đồ tần suất (Histogram): Biểu đồ tần suất của mức xám g của ảnh I là số điểm ảnh có giá trị g của ảnh I. Ký hiệu là h(g)", "order_start": 0, "order_end": 356, "word_count": 80}
{"parent_id": "5d8ec322-faf6-46d6-84c8-4f4599932e69", "subject": "Xulyanh", "section": "3.1.2. Tăng giảm độ sáng", "title_path": "3.1.2. Tăng giảm độ sáng", "content": "[Xulyanh / 3.1.2. Tăng giảm độ sáng] Giả sử ta có ảnh I ~ kích thước m  n và số nguyên c Khi đó, kỹ thuật tăng, giảm độ sáng được thể hiện Nếu c > 0 thì ảnh sáng lên và c < 0 thì ảnh tối đi", "order_start": 0, "order_end": 153, "word_count": 43}
{"parent_id": "36ad1426-3613-4e46-bdb4-2ddb301f00fe", "subject": "Xulyanh", "section": "3.1.3. Tách ngưỡng", "title_path": "3.1.3. Tách ngưỡng", "content": "[Xulyanh / 3.1.3. Tách ngưỡng] Giả sử ta có ảnh I ~ kích thước m  n, hai số Min, Max và ngưỡng  Khi đó, kỹ thuật tách ngưỡng được thể hiện I i, j = I i, j > = ? Max: Min;  (i,j) Nếu Min = 0, Max = 1 thì ảnh thu được sau tách ngưỡng là ảnh đen trắng.", "order_start": 0, "order_end": 226, "word_count": 60}
{"parent_id": "200b77c2-5eba-49ca-ac2d-048dfefe0625", "subject": "Xulyanh", "section": "3.1.4. Cân bằng tần suất", "title_path": "3.1.4. Cân bằng tần suất", "content": "[Xulyanh / 3.1.4. Cân bằng tần suất] Ảnh I được gọi là cân bằng \"lý tưởng\" nếu với mọi mức xám g, g’ ta có h(g) = h(g’) Giả sử, ta có: I ~ kích thước m  n new_level ~ số mức xám mới của ảnh sau cân bằng, thông thường giá trị này có thể bằng đúng số mức xám của ảnh gốc TB  m n  ~ số điểm ảnh trung bình của mỗi mức xám của ảnh đã cân bằng new level_ g t g h i( ) ( ) ~ số điểm ảnh có mức xám  g trên ảnh gốc i 0 Cần xác định hàm f: g  f(g) sao cho: Ví dụ: Cân bằng ảnh sau với new_level = 4 Ảnh sau khi thực hiện cân bằng chưa chắc đã là cân bằng \"lý tưởng \", tuy nhiên chúng ta có thể thấy biểu đồ tần suất của anh sau cân bằng đồng đều hơn rất nhiều so ảnh gốc.", "order_start": 0, "order_end": 634, "word_count": 162}
{"parent_id": "c61b05c5-08d4-4f56-8d34-044d133d7237", "subject": "Xulyanh", "section": "3.1.5. Kỹ thuật tìm tách ngưỡng tự động", "title_path": "3.1.5. Kỹ thuật tìm tách ngưỡng tự động", "content": "[Xulyanh / 3.1.5. Kỹ thuật tìm tách ngưỡng tự động] Ngưỡng  trong kỹ thuật tách ngưỡng thường được cung cấp bởi người sử dụng. Kỹ thuật tìm tách ngưỡng tự động xác định ngưỡng  một cách tự động dựa vào histogram theo một nguyên lý trong vật lý là vật thể có thể tách làm 2 phần nếu tổng độ lệnh trong từng phần là tối thiểu. Giả sử, ta có ảnh  g i h im g . ( ) 1 ( ) ~ mômen quán tính TB có mức xám  g Hàm f: g  f (g ) được định nghĩa là: Ngưỡng  được xác định sao cho: Ví dụ: Tìm ngưỡng tự động của ảnh sau Ngưỡng tìm được  = 1 ứng với f() = 1.66.", "order_start": 0, "order_end": 505, "word_count": 124}
{"parent_id": "7439dd99-328c-453d-a954-d92d9dabb0d3", "subject": "Xulyanh", "section": "3.1.6. Biến đổi cấp xám tổng thể", "title_path": "3.1.6. Biến đổi cấp xám tổng thể", "content": "[Xulyanh / 3.1.6. Biến đổi cấp xám tổng thể] Nếu biết ảnh và hàm biến đổi thì ta có thể tính được ảnh kết quả và do đó ta sẽ có được histogram của ảnh biến đổi. Nhưng thực tế nhiều khi ta chỉ biết histogram của ảnh gốc và hàm biến đổi, câu hỏi đặt ra là liệu ta có thể có được histogram của ảnh biến đổi. Nếu có như vậy ta có thể hiệu chỉnh hàm biến đổi để thu được ảnh kết quả có phân bố histogram như mong muốn. Bài toán đặt ra là biết histogram của ảnh, biết hàm biến đổi hãy vẽ histogram của ảnh mới. Giả sử ta có ảnh gốc I với các mức xám g và biểu đồ tần suất h(g). Phép biến đổi f(g) biến ảnh I thành I' với các mức xám q như vậy q  f (g) . Biểu đồ tần suất h(q) có thể được tính bằng ( ) ( )h q h i .", "order_start": 0, "order_end": 666, "word_count": 161}
{"parent_id": "7439dd99-328c-453d-a954-d92d9dabb0d3", "subject": "Xulyanh", "section": "3.1.6. Biến đổi cấp xám tổng thể", "title_path": "3.1.6. Biến đổi cấp xám tổng thể", "content": "[Xulyanh / 3.1.6. Biến đổi cấp xám tổng thể] các mức xám g và biểu đồ tần suất h(g). Phép biến đổi f(g) biến ảnh I thành I' với các mức xám q như vậy q  f (g) . Biểu đồ tần suất h(q) có thể được tính bằng ( ) ( )h q h i .   ( ) 1i f q Ví dụ:", "order_start": 666, "order_end": 867, "word_count": 58}
{"parent_id": "9a3e6929-cdc1-4434-8bca-12f3a76c3dde", "subject": "Xulyanh", "section": "3.2. CẢI THIỆN ẢNH SỬ DỤNG CÁC TOÁN TỬ KHÔNG GIAN 3.2.1. Phép cửa sổ di chuyển (Moving Window)", "title_path": "3.2. CẢI THIỆN ẢNH SỬ DỤNG CÁC TOÁN TỬ KHÔNG GIAN 3.2.1. Phép cửa sổ di chuyển (Moving Window)", "content": "[Xulyanh / 3.2. CẢI THIỆN ẢNH SỬ DỤNG CÁC TOÁN TỬ KHÔNG GIAN 3.2.1. Phép cửa sổ di chuyển (Moving Window)] Hầu hết các phương pháp xử lý ảnh sử dụng toán tử không gian là phương pháp cửa sổ di chuyển. Về cơ bản phương pháp cửa sổ di chuyển thực hiện biến đổi trên một điểm dựa vào giá trị điểm ảnh nằm trong một cửa sổ bao trùm các điểm ảnh lân cận. Gọi I và J là ảnh sao cho J = T[J]. T[X] là một phép biến đổi sao cho Đây là phép biến đổi cửa sổ di chuyển với kích thước (s+1) x (d+1) và giá trị được biến đổi nằm ở góc trên bên trái cửa sổ.", "order_start": 0, "order_end": 436, "word_count": 103}
{"parent_id": "79e44a94-fa73-4442-8613-3a726cd83c9a", "subject": "Xulyanh", "section": "3.2.2. Phép nhân chập và mẫu", "title_path": "3.2.2. Phép nhân chập và mẫu", "content": "[Xulyanh / 3.2.2. Phép nhân chập và mẫu] Nhân chập là một phép cửa sổ di chuyển, phép biến đổi được định nghĩa thông qua một ma trận (mẫu). Giả sử ta có ảnh I kích thước M  N, mẫu T có kích thước m  n khi đó, ảnh I nhân chập theo mẫu T được xác định bởi công thức. Theo công thức (3.1) thì giá trị được biến đổi nằm ở góc trên bên trái cửa sổ, trong khi đó theo công thức (3.2) thì giá trị được biến đổi nằm ở góc dưới bên phải cửa sổ. Tính theo công thức (3.1) Tính theo công thức (3.2) Trong quá trình thực hiện phép nhân chập có một số thao tác ra ngoài ảnh, ảnh không được xác định tại những vị trí đó dẫn đến ảnh thu được có kích thước nhỏ hơn. Ảnh thực hiện theo công thức 3.1 và 3.2 chỉ sai khác nhau 1 phép dịch chuyển để đơn giản ta sẽ hiểu phép nhân chập là theo công thức 3.", "order_start": 0, "order_end": 746, "word_count": 171}
{"parent_id": "79e44a94-fa73-4442-8613-3a726cd83c9a", "subject": "Xulyanh", "section": "3.2.2. Phép nhân chập và mẫu", "title_path": "3.2.2. Phép nhân chập và mẫu", "content": "[Xulyanh / 3.2.2. Phép nhân chập và mẫu] dẫn đến ảnh thu được có kích thước nhỏ hơn. Ảnh thực hiện theo công thức 3.1 và 3.2 chỉ sai khác nhau 1 phép dịch chuyển để đơn giản ta sẽ hiểu phép nhân chập là theo công thức 3.1", "order_start": 746, "order_end": 926, "word_count": 41}
{"parent_id": "7fa7cb24-0bff-4ef3-bc5a-c31a2713b316", "subject": "Xulyanh", "section": "Một số mẫu nhân chập thông dụng", "title_path": "Một số mẫu nhân chập thông dụng", "content": "[Xulyanh / Một số mẫu nhân chập thông dụng] Dùng để khử nhiễu  Các điểm có tần số cao Ví dụ 1: Áp dụng kỹ thuật cộng hằng số với c = -27, ta có: Dùng để phát hiện các điểm có tần số cao Ví dụ 2:", "order_start": 0, "order_end": 151, "word_count": 40}
{"parent_id": "5d0c0afc-1676-4fc7-ac6e-c7eef248b8ca", "subject": "Xulyanh", "section": "3.2.3. Lọc trung vị", "title_path": "3.2.3. Lọc trung vị", "content": "[Xulyanh / 3.2.3. Lọc trung vị] * Định nghĩa 3.1 (Trung vị) Cho dãy x1; x2...; xn đơn điệu tăng (giả m). Khi đó trung vị của dãy ký hiệu là Med(xn), được định nghĩa: * Mệnh đề 3.1", "order_start": 0, "order_end": 149, "word_count": 33}
{"parent_id": "88606c2a-a995-4f91-a01e-05d90b4f0d8e", "subject": "Xulyanh", "section": "*Chứng minh mệnh đề 3.1", "title_path": "*Chứng minh mệnh đề 3.1", "content": "[Xulyanh / *Chứng minh mệnh đề 3.1] Xét trường hợp n chẵn Ta có: Nếu n lẻ: Bổ sung thêm phần tử   iMed x vào dãy. Theo trường hợp n chẵn ta có:", "order_start": 0, "order_end": 111, "word_count": 28}
{"parent_id": "beb7908e-2ae2-4e71-a31e-e9309a14ba73", "subject": "Xulyanh", "section": "* Kỹ thuật lọc trung vị", "title_path": "* Kỹ thuật lọc trung vị", "content": "[Xulyanh / * Kỹ thuật lọc trung vị] Giả sử ta có ảnh I ngưỡng  cửa sổ W(P) và điểm ảnh P Khi đó kỹ thuật lọc trung vị phụ thuộc không gian bao gồm các bước cơ bản sau: + Bước 1: Tìm trung vị + Bước 2: Gán giá trị Ví dụ: với cửa sổ W(3  3) và  = 2 Giá trị 16, sau phép lọc có giá trị 2, các giá trị còn lại không thay đổi.", "order_start": 0, "order_end": 288, "word_count": 75}
{"parent_id": "9db01017-4f36-4beb-8df1-2bc931c476d8", "subject": "Xulyanh", "section": "* Định nghĩa 3.2 (Trung bình)", "title_path": "* Định nghĩa 3.2 (Trung bình)", "content": "[Xulyanh / * Định nghĩa 3.2 (Trung bình)] Cho dãy x1, x2…, xn khi đó trung bình của dãy ký hiệu AV(xn) được định nghĩa: * Mệnh đề 3.2", "order_start": 0, "order_end": 93, "word_count": 21}
{"parent_id": "ee968ead-b134-460e-8202-f4e2b2032b22", "subject": "Xulyanh", "section": "Kỹ thuật lọc trung bình", "title_path": "Kỹ thuật lọc trung bình", "content": "[Xulyanh / Kỹ thuật lọc trung bình] Giả sử ta có ảnh I, điểm ảnh P, cửa sổ W(P) và ngưỡng . Khi đó kỹ thuật lọc trung bình phụ thuộc không gian bao gồm các bước cơ bản sau: + Bước 1: Tìm trung bình + Bước 2: Gán giá trị Ví dụ: với cửa sổ W(3  3) và  = 2 Giá trị 16 sau phép lọc trung bình có giá trị 4, các giá trị còn lại giữ nguyên sau phép lọc.", "order_start": 0, "order_end": 314, "word_count": 79}
{"parent_id": "6bd3dcca-a7c8-467e-8603-0ecd16fb362d", "subject": "Xulyanh", "section": "3.2.5. Lọc trung bình theo k giá trị gần nhất", "title_path": "3.2.5. Lọc trung bình theo k giá trị gần nhất", "content": "[Xulyanh / 3.2.5. Lọc trung bình theo k giá trị gần nhất] Giả sử ta có ảnh I, điểm ảnh P, cửa sổ W(P), ngưỡng  và số k. Khi đó, lọc trung bình theo k giá trị gần nhất bao gồm các bước sau: + Bước 1: Tìm K giá trị gần nhất + Bước 2: Tính trung bình + Bước 3: Gán giá trị Ví dụ: với cửa sổ W(3  3),  = 2 và k = 3 Nếu k lớn hơn kích thước cửa sổ thì kỹ thuật chính là kỹ thuật lọc trung bình, nếu k là 1 thì ảnh kết quả không thay đổi. Vậy nên chất lượng của kỹ thuật phụ thuộc vào số phân tử lựa chọn k.", "order_start": 0, "order_end": 446, "word_count": 114}
{"parent_id": "452237e2-a70e-4999-9ab5-be257d0bcb0c", "subject": "Xulyanh", "section": "3.3.1. Nhiễu và mô hình nhiễu", "title_path": "3.3.1. Nhiễu và mô hình nhiễu", "content": "[Xulyanh / 3.3.1. Nhiễu và mô hình nhiễu] Ảnh được coi là một miền đồng nhất về mức xám, tức là các điểm ảnh lân cận có sự biến đổi liên tục về mức xám. Như vậy sau quá trình số hoá thì trong mỗi cửa sổ đang xét các điểm ảnh đều có giá trị gần bằng như nhau. Thực tế quan sát có những điểm ảnh có giá trị khác hơn nhiều so với các điểm ảnh xung quanh. Đó chính là nhiễu. Như vậy, nhiễu trong ảnh số được xem như là sự dịch chuyển đột ngột của tín hiệu ảnh trên một khoảng cách nhỏ.", "order_start": 0, "order_end": 439, "word_count": 101}
{"parent_id": "48846e3e-0983-4bd4-a10b-ae3a248337fc", "subject": "Xulyanh", "section": "Mô hình liên tục", "title_path": "Mô hình liên tục", "content": "[Xulyanh / Mô hình liên tục] Hệ thống thu nhận ảnh chuyển các hình ảnh thực của môi trường xung quanh g(x,y) thành dạng tín hiệu ảnh g’(x,y). Tuy nhiên trong quá trình chuyển đổi có nhiều yếu tố tác động tạo thành nhiễu. Do đó tín hiệu g’(x,y) có thể chứa các thành phần nhiễu trong đó. Quá trình thu nhận ảnh có nhiễu có thể mô tả một cách trực quan như sau:", "order_start": 0, "order_end": 330, "word_count": 69}
{"parent_id": "d2f12d21-eaf9-45fc-bc15-800dc427ae95", "subject": "Xulyanh", "section": "Mô hình rời rạc:", "title_path": "Mô hình rời rạc:", "content": "[Xulyanh / Mô hình rời rạc:] Trên cơ sở mô hình nhiễu liên tục, ta có thể xây dựng một mô hình nhiễu rời rạc tương ứng với ảnh số. Khi đó g(x,y) sẽ chuyển thành ảnh rời rạc g[m,n], ảnh liên tục g’(x,y) sẽ chuyển thành ma trận điểm ảnh g’[m,n] và nhiễu cũng phân bố rời rạc tại các điểm ảnh [m,n]. Giả sử H là hàm tuyến tính bất biến trong phạm vi MN (kích thước ảnh) thì ta có: Đối với xử lý số ảnh thì ta chỉ sử dụng mô hình nhiễu rời rạc.", "order_start": 0, "order_end": 413, "word_count": 93}
{"parent_id": "74d12396-06b4-476d-b5c0-fc10519a1f91", "subject": "Xulyanh", "section": "3.3.2.Các loại nhiễu", "title_path": "3.3.2.Các loại nhiễu", "content": "[Xulyanh / 3.3.2.Các loại nhiễu] Các tín hiệu nhiễu thường được chia thành các loại chính như sau:  Nhiễu do thiết bị thu nhận ảnh: là loại nhiễu gây ra do giới hạn nhiễu xạ và quang sai của thấu kính, nhiễu do bộ phận cảm quang, ảnh mờ nhòe do ống kính, nhiễu do rung động thiết bị trong quá trình thu nhận.  Nhiễu nhẫu nhiên độc lập: là các loại nhiễu gây ra do ảnh hưởng của môi trường xung quanh, do ảnh hưởng của khí quyển.  Nhiễu do vật quan sát: là nhiễu gây ra do bề mặt của bản thân vật có độ nhám gồ ghề. Chính nhiễu này gây hiện tượng tán xạ của các tia đơn sắc và sinh ra hiện tượng nhiễu lốm đốm. Thường người ta xấp xỉ các loại nhiễu bằng các quá trình tuyến tính bất biến vì có nhiều công cụ tuyến tính có thể giải quyết vấn đề khôi phục ảnh hơn là các công cụ phi tuyến. Việc xử lý nhiễu bằng cách xấp xỉ tuyến tính cũng giúp cho công việc dễ dàng hơn trong trường hợp dùng cách biến đổi phi tuyến.", "order_start": 0, "order_end": 884, "word_count": 195}
{"parent_id": "6c9f21df-8f74-45eb-9818-07f185afe820", "subject": "Xulyanh", "section": "3.3.3.Các kỹ thuật lọc nhiễu", "title_path": "3.3.3.Các kỹ thuật lọc nhiễu", "content": "[Xulyanh / 3.3.3.Các kỹ thuật lọc nhiễu] Trong phần này ta sẽ xét hai kỹ thuật lọc tuyến tính hay sử dụng là lọc đảo và lọc giả đảo.", "order_start": 0, "order_end": 91, "word_count": 22}
{"parent_id": "cff0939f-4312-4654-9171-c9274e825fc8", "subject": "Xulyanh", "section": "Lọc đảo (inverse filter):", "title_path": "Lọc đảo (inverse filter):", "content": "[Xulyanh / Lọc đảo (inverse filter):] Nguyên lý của lọc đảo là sử dụng hàm ngược của đáp ứng xung h[m,n] để khôi phục lại một ảnh xấp xỉ ảnh nguyên gốc g[m,n] từ ảnh g’[m,n] đã biết nguyên lý này được biễu diễn mô tả theo sơ đồ sau:", "order_start": 0, "order_end": 194, "word_count": 44}
{"parent_id": "658d7730-68a7-4fb9-a5fe-437251280136", "subject": "Xulyanh", "section": "Hình 3.2. Lọc đảo khôi phục ảnh nguyên", "title_path": "Hình 3.2. Lọc đảo khôi phục ảnh nguyên", "content": "[Xulyanh / Hình 3.2. Lọc đảo khôi phục ảnh nguyên] Như vậy ảnh khôi phục g*[m,n] sẽ được tính theo công thức: g*[m,n]= g’[m,n]* h-1 [m,n] Trong đó h-1 [m,n] chính là hàm của bộ lọc đảo. Vì H-1 (H(x)) = x nên ta có giá trị đầu ra là g*[m,n] cũng bằng giá trị đầu vào g[m,n]. Như vậy ta đã khôi phục được ảnh g[m,n] nhờ dùng hàm ngược của đáp ứng xung h[m,n]. Nếu dùng biến đổi Fourier ta có: Qua đó ta thấy, đáp ứng ần số của bộ lọc đảo là nghịch đảo của đáp ứng tần số của hệ thu nhận ảnh. Nếu đánh giá được mức nhiễu ta có thể xấp xỉ gần hơn với ảnh nguyên gốc: [ , ][ , ] [ , ] ' N u vG u v G u v   với N[u,v] là nhiễu ước lượng [ , ][ , ] H u vH u v Nếu H[u,v] bằng 0 hoặc khá nhỏ thì hệ thống khôi phục sẽ không ổn định (hàm HT [u,v] không xác định). Đây chính là nhược điểm của phương pháp lọc đảo. Tuy bộ lọc đảo có khả năng ngăn nhiễu do hệ thống nhận ảnh gây ra khá tốt nhưng việc thiết kế bộ lọc này lại là khá phức tạp.", "order_start": 0, "order_end": 880, "word_count": 212}
{"parent_id": "75c19be6-e771-4f0e-b0d9-d4163545d83b", "subject": "Xulyanh", "section": "Lọc giả đảo (Pseudoinverse filter):", "title_path": "Lọc giả đảo (Pseudoinverse filter):", "content": "[Xulyanh / Lọc giả đảo (Pseudoinverse filter):] Kỹ thuật lọc này khắc phục được nhược điểm của kỹ thuật lọc đảo là làm cho hàm HT [u,v] luôn xác định: Với  là một giá trị cho trước. Trong trường hợp ảnh nguyên gốc g[m,n] chuyển động tịnh tiến theo phương x và y sinh ra hiện tượng nhoè ảnh thì HT [u,v] sẽ được xác định theo các thông số chuyển động, và lọc giả đảo có khả năng khôi phục được ảnh nhoè này.", "order_start": 0, "order_end": 359, "word_count": 79}
{"parent_id": "73209b88-cf7c-4fa7-87f0-7cdb34ed832b", "subject": "Xulyanh", "section": "Lọc nhiễu lốm đốm:", "title_path": "Lọc nhiễu lốm đốm:", "content": "[Xulyanh / Lọc nhiễu lốm đốm:] Ta đã biết nhiễu lốm đốm gây ra do tính chất gồ ghề của bề mặt vật thể gây ra hiện tượng tán xạ các tia đơn sắc. Phần này ta sẽ nghiên cứu một kỹ thuật lọc nhiễu lốm đốm là kỹ thuật trung bình thống kê sử dụng bộ lọc đồng cầu. Kỹ thuật lọc nhiễu trung bình thống kê tiến hành thống kê các cường độ sáng của đối tượng ảnh bị nhiễu lốm đốm bằng N lần thu nhận độc lập và lấy trung bình các cường độ đó. Ta giả thiết hệ thống chỉ có nhiễu lốm đốm và nhiễu này có thể coi như là tổng vô số hạn các pha độc lập và đồng nhất. Ta có thể biễu diễn nhiễu lốm đốm như sau: a[m,n]=aR[m,n]+j.aL[m,n] Với aR và aL là các biến ngẫu nhiên độc lập phân bố theo Gaussian, ứng với mỗi toạ độ [m,n] có trung bình bằng 0 và phương sai  2 . Ta có cường độ S: S[m,n] =  a[m,n]  = aR 2 + Như vậy ảnh thu được trong lần nhận thứ i (1,...,N) sẽ là: gi’[m,n]=g[m,n].", "order_start": 0, "order_end": 843, "word_count": 193}
{"parent_id": "73209b88-cf7c-4fa7-87f0-7cdb34ed832b", "subject": "Xulyanh", "section": "Lọc nhiễu lốm đốm:", "title_path": "Lọc nhiễu lốm đốm:", "content": "[Xulyanh / Lọc nhiễu lốm đốm:] mỗi toạ độ [m,n] có trung bình bằng 0 và phương sai  2 . Ta có cường độ S: S[m,n] =  a[m,n]  = aR 2 + Như vậy ảnh thu được trong lần nhận thứ i (1,...,N) sẽ là: gi’[m,n]=g[m,n].si[m,n] Trị trung bình thống kê của N lần thu nhận ảnh sẽ là: Trong đó sN[m,n] là trị trung bình thống kê của trường cường độ nhiễu lốm đốm", "order_start": 843, "order_end": 1162, "word_count": 72}
{"parent_id": "bb84d7cd-19d3-4f77-9461-d6e45fd4567b", "subject": "Xulyanh", "section": "Lọc đồng cầu (Homomorphic filter):", "title_path": "Lọc đồng cầu (Homomorphic filter):", "content": "[Xulyanh / Lọc đồng cầu (Homomorphic filter):] Nếu lấy logarit 2 vế của biểu thức 3.10 ta thu được: log g’N[m,n]= log g[m,n]+ log sN[m,n] Đặt wN[m,n]= log g’N[m,n], z[m,n]= log g[m,n],N[m,n]= log sN[m,n] Ta có mô hình quan sát có nhiễu lốm đốm như sau: wN[m,n]= z[m,n] +N[m,n] Từ công thức 3.12 ta thấy có thể tìm ra z[m,n] từ wN[m,n] và N[m,n]. Như vậy là có thể tách nhiễu lốm đốm và khôi phục lại ảnh ban đầu. Trong công thức 3.12 thì N[m,n] là nhiễu trắng dừng. Với N≥2 thì N[m,n] có thể mô tả gắn với nhiễu ngẫu nhiên Gauusian với mật độ phổ được định nghĩa như sau:", "order_start": 0, "order_end": 529, "word_count": 106}
{"parent_id": "07550c57-7f71-469c-bb75-521883193b91", "subject": "Xulyanh", "section": "3.4. CÂU HỎI ÔN TẬP CHƯƠNG", "title_path": "3.4. CÂU HỎI ÔN TẬP CHƯƠNG", "content": "[Xulyanh / 3.4. CÂU HỎI ÔN TẬP CHƯƠNG] Câu 1: Biểu đồ tần suất là gì? Hãy tìm biểu đồ tần suất h(g) cho ảnh I sau, được biết các điểm ảnh có giá trị từ 0 đến 9: Câu 2: Thực hiện các phép biến đổi sau với ảnh I ở câu 1. Tăng sáng với c = 4.  Tách ngưỡng với θ = 3.  Cân bằng tần suất với ảnh kết quả có cùng số mức xám với ảnh gốc. Tìm ngưỡng tự động và tách ngưỡng. Lưu ý: Các điểm ảnh chỉ nhận giá trị từ 0 đến 9. Câu 3: Từ biểu đồ tần suất h(g) tính được ở câu 1 hãy tính biểu đồ tần suất h'(g) của ảnh I' sau khi được biến đổi từ ảnh I sử dụng biểu thức: Câu 4: Thực hiện nhân chập ảnh I với ma trận nhân chập H: Câu 5: Thực hiện lọc với cửa sổ 3x3 và θ = 3 sử dụng các phương pháp sau với ảnh I ở câu 1:  Lọc trung vị với.  Lọc trung bình.  Lọc trung bình k giá trị gần nhất với k = 4.", "order_start": 0, "order_end": 755, "word_count": 192}
{"parent_id": "3a400a98-a78d-4f53-bd49-ea43bd171584", "subject": "Xulyanh", "section": "4.1.1. Giới thiệu", "title_path": "4.1.1. Giới thiệu", "content": "[Xulyanh / 4.1.1. Giới thiệu] Biên là vấn đề quan trọng trong trích chọn đặc điểm nhằm tiến tới hiểu ảnh. Cho đến nay chưa có định nghĩa chính xác về biên, trong mỗi ứng dụng người ta đưa ra các độ đo khác nhau về biên, một trong các độ đo đó là độ đo về sự thay đổi đột ngột về cấp xám. Ví dụ: Đối với ảnh đen trắng, một điểm được gọi là điểm biên nếu nó là điểm đen có ít nhất một điểm trắng bên cạnh. Tập hợp các điểm biên tạo nên biên hay đường bao của đối tượng. Xuất phát từ cơ sở này người ta thường sử dụng hai phương pháp phát hiện biên cơ bản: Phát hiện biên trực tiếp: Phương pháp này làm nổi biên dựa vào sự biến thiên mức xám của ảnh. Kỹ thuật chủ yếu dùng để phát hiện biên ở đây là kỹ thuật lấy đạo hàm. Nếu lấy đạo hàm bậc nhất của ảnh ta có các kỹ thuật Gradient, nếu lấy đạo hàm bậc hai của ảnh ta có kỹ thuật Laplace. Ngoài ra còn có một số các tiếp cận khác Phát hiện biên gián tiếp: Nếu bằng cách nào đó ta phân được ảnh thành các vùng thì ranh giới giữa các vùng đó gọi là biên.", "order_start": 0, "order_end": 970, "word_count": 221}
{"parent_id": "3a400a98-a78d-4f53-bd49-ea43bd171584", "subject": "Xulyanh", "section": "4.1.1. Giới thiệu", "title_path": "4.1.1. Giới thiệu", "content": "[Xulyanh / 4.1.1. Giới thiệu] ỹ thuật Laplace. Ngoài ra còn có một số các tiếp cận khác Phát hiện biên gián tiếp: Nếu bằng cách nào đó ta phân được ảnh thành các vùng thì ranh giới giữa các vùng đó gọi là biên. Kỹ thuật dò biên và phân vùng ảnh là hai bài toán đối ngẫu nhau vì dò biên để thực hiện phân lớp đối tượng mà khi đã phân lớp xong nghĩa là đã phân vùng được ảnh và ngược lại, khi đã phân vùng ảnh đã được phân lớp thành các đối tượng, do đó có thể phát hiện được biên. Phương pháp phát hiện biên trực tiếp tỏ ra khá hiệu quả và ít chịu ảnh hưởng của nhiễu, song nếu sự biến thiên độ sáng không đột ngột, phương pháp tỏ ra kém hiệu quả, phương pháp phát hiện biên gián tiếp tuy khó cài đặt, song lại áp dụng khá tốt trong trường hợp này. Sự khác biệt cơ bản giữa hai phương pháp này là: Phương pháp phát hiện biên trực tiếp cho ta kết quả là ảnh biên, còn phương pháp phát hiện biên gián tiếp cho ta kết quả là đường biên.", "order_start": 970, "order_end": 1872, "word_count": 199}
{"parent_id": "8fa18d11-053d-4d5c-ae07-f489cc248f04", "subject": "Xulyanh", "section": "4.1.2. Kỹ thuật phát hiện biên Gradient", "title_path": "4.1.2. Kỹ thuật phát hiện biên Gradient", "content": "[Xulyanh / 4.1.2. Kỹ thuật phát hiện biên Gradient] Theo định nghĩa, gradient là một véctơ có các thành phần biểu thị tốc độ thay đổi giá trị của điểm ảnh, ta có: Trong đó, dx, dy là khoảng cách (tính bằng số điểm) theo hướng x và y. Tuy ta nói là lấy đạo hàm nhưng thực chất chỉ là mô phỏng và xấp xỉ đạo hàm bằng các kỹ thuật nhân chập vì ảnh số là tín hiệu rời rạc nên đạo hàm không tồn tại. Giả sử với dx và dy nhỏ nhất là 1, ta có: Do đó, mặt nạ nhân chập theo hướng x là A= 1 1 Ví dụ:", "order_start": 0, "order_end": 441, "word_count": 106}
{"parent_id": "df51cc21-d1b5-42e1-905c-cd207000f110", "subject": "Xulyanh", "section": "4.1.2.1. Kỹ thuật Prewitt", "title_path": "4.1.2.1. Kỹ thuật Prewitt", "content": "[Xulyanh / 4.1.2.1. Kỹ thuật Prewitt] Kỹ thuật sử dụng 2 mặt nạ nhập chập xấp xỉ đạo hàm theo 2 hướng x và y là: Các bước tính toán của kỹ thuật Prewitt + Bước 1: Tính I  Hx và I  Hy + Bước 2: Tính I  Hx + I  Hy + Bước 3: Phân ngưỡng theo θ để có ảnh biên Ví dụ:", "order_start": 0, "order_end": 228, "word_count": 63}
{"parent_id": "0d5e240c-235d-49f9-9fa5-8c2a2917fa78", "subject": "Xulyanh", "section": "4.1.2.2. Kỹ thuật Sobel", "title_path": "4.1.2.2. Kỹ thuật Sobel", "content": "[Xulyanh / 4.1.2.2. Kỹ thuật Sobel] Tương tự như kỹ thuật Prewitt kỹ thuật Sobel sử dụng 2 mặt nạ nhân chập theo 2 hướng x, y là: Các bước tính toán tương tự Prewitt + Bước 1: Tính I  Hx và I  Hy + Bước 2: Tính I  Hx + I  Hy + Bước 3: Phân ngưỡng theo θ để có ảnh biên", "order_start": 0, "order_end": 236, "word_count": 62}
{"parent_id": "f8db5034-ae8a-43a3-8dce-14b4057ef695", "subject": "Xulyanh", "section": "4.1.2.3. Kỹ thuật la bàn", "title_path": "4.1.2.3. Kỹ thuật la bàn", "content": "[Xulyanh / 4.1.2.3. Kỹ thuật la bàn] Kỹ thuật sử dụng 8 mặt nạ nhân chập eo 8 hướng 00 , 450 , 900 , 1350 , 1800 , 2250 , 2700 , 3150 Các bước tính toán thuật toán La bàn", "order_start": 0, "order_end": 133, "word_count": 35}
{"parent_id": "44d0e519-0744-4d57-ac00-898ba664ed96", "subject": "Xulyanh", "section": "4.1.3. Kỹ thuật phát hiện biên Laplace", "title_path": "4.1.3. Kỹ thuật phát hiện biên Laplace", "content": "[Xulyanh / 4.1.3. Kỹ thuật phát hiện biên Laplace] Các phương pháp đánh giá gradient ở trên làm việc khá tốt khi mà độ sáng thay đổi rõ nét. Khi mức xám thay đổi chậm, miền chuyển tiếp trải rộng, phương pháp cho hiệu quả hơn đó là phương pháp sử dụng đạo hàm bậc hai Laplace. Toán tử Laplace được định nghĩa như sau: Ta có: Tương tự, Vậy: 2 f= f(x+1,y) + f(x,y+1) - 4f(x,y) + f(x-1,y) + f(x,y-1) Dẫn tới: Trong thực tế, người ta thường dùng nhiều kiểu mặt nạ khác nhau để xấp xỉ rời rạc đạo hàm bậc hai Laplace. Dưới đây là ba kiểu mặt nạ thường dùng:", "order_start": 0, "order_end": 501, "word_count": 106}
{"parent_id": "b5184abb-177d-4b1f-9ac2-2b34f8009b0a", "subject": "Xulyanh", "section": "4.1.4. Kỹ thuật Canny", "title_path": "4.1.4. Kỹ thuật Canny", "content": "[Xulyanh / 4.1.4. Kỹ thuật Canny] Đây là một thuật toán được phát triển khá sớm nhưng cho đến nay vẫn là một trong những kỹ thuật được sử dụng rộng rãi, cho các kết quả tương đối tốt, có khả năng đưa ra đường biên mảnh, phân biệt được điểm biên với điểm nhiễu.", "order_start": 0, "order_end": 226, "word_count": 49}
{"parent_id": "c01ccbce-22f3-4bad-a06e-02dbef3fa660", "subject": "Xulyanh", "section": "Thuật toán Canny gồm năm bật bước:", "title_path": "Thuật toán Canny gồm năm bật bước:", "content": "[Xulyanh / Thuật toán Canny gồm năm bật bước:] + Bước 1: Làm trơn ảnh. Chúng ta sử dụng Tính I  H, với: Gọi G là kết quả lọc nhiễu: Gết = I  H +Bước 2: Tính gradient ccủa ản bằng mặt nạ PreWitt (hoặc các mặc ma trận phát hiện biên khác như Roberts, SobeSobe , kết quả đặt vào Gx,Gy. Gx = G  Hx, Gy = G  Hy + Bước3: Tính độộ lớn và hướng của gradient tại mỗi điểm (i,j) cm của ảnh. Độ lớn G(i,j) tại điểm (i,j) được tính dc dựa vào định lý Pitago: Ngoài ra hướng củủa véc tơ gradient được tính với công thức: với atan2 là hàm arctan với hai biến nhằm nhận thêm thông tin hưêm thông hướng và xác định góc trong khoảng 360˚, hàm , atan2 có thể được định nghĩa như sau: Sau đó hướng gradient được làm tròn thành bốn góc 0˚, 45˚, 90˚ và 135˚ đại diện cho chiều dọc, ngang và hai chiều chéo. + Bước 4: Bước này loại bỏ những điểm không phải là cực đại địa phương để xóa bỏ những điểm không thực sự là biên, bước này sẽ giúp biên mỏng hơn. Xét (i,j), (i,j) là hướng gradient tại (i,j). I1, I2 là hai điểm lân cận của (i,j) theo hướng .", "order_start": 0, "order_end": 987, "word_count": 218}
{"parent_id": "c01ccbce-22f3-4bad-a06e-02dbef3fa660", "subject": "Xulyanh", "section": "Thuật toán Canny gồm năm bật bước:", "title_path": "Thuật toán Canny gồm năm bật bước:", "content": "[Xulyanh / Thuật toán Canny gồm năm bật bước:] phương để xóa bỏ những điểm không thực sự là biên, bước này sẽ giúp biên mỏng hơn. Xét (i,j), (i,j) là hướng gradient tại (i,j). I1, I2 là hai điểm lân cận của (i,j) theo hướng . Theo định nghĩa điểm biên cục bộ thì (i,j) là biên nếu I(i,j) cực đại địa phương theo hướng gradient nghĩa là nếu I(i,j) > I1 và I(i,j) > I2 thì mới giữ lại I(i,j) để xét tiếp trong bước sau. + Bước 5: Tại bước này, Canny sử dụng hai ngưỡng cao và thấp. Đầu tiên, Canny lọc các điểm được giữ lại sử dụng ngưỡng cao, chỉ những điểm có độ lớn gradient cao hơn ngưỡng này mới được chọn. Từ những điểm được chọn Canny dò theo biên sử dụng hướng của gradient tại các điểm. Khi thực hiện việc dò theo biên, Canny sử dụng ngưỡng thấp để xác định điểm dừng của biên (nếu giá trị điểm tiếp theo thấp hơn ngưỡng này, việc dò theo biên này sẽ kết thúc) Các kỹ thuật thông thường để có được ảnh biên thường sử dụng một ngưỡng, điểm ảnh có độ lớn gradien lớn hơn ngưỡng này sẽ được chọn làm biên.", "order_start": 987, "order_end": 1951, "word_count": 204}
{"parent_id": "c01ccbce-22f3-4bad-a06e-02dbef3fa660", "subject": "Xulyanh", "section": "Thuật toán Canny gồm năm bật bước:", "title_path": "Thuật toán Canny gồm năm bật bước:", "content": "[Xulyanh / Thuật toán Canny gồm năm bật bước:] ày, việc dò theo biên này sẽ kết thúc) Các kỹ thuật thông thường để có được ảnh biên thường sử dụng một ngưỡng, điểm ảnh có độ lớn gradien lớn hơn ngưỡng này sẽ được chọn làm biên. Tuy nhiên các kỹ thuật sử dụng một ngưỡng không thể vừa chọn biên chính xác và mảnh như Canny, và thông thường sẽ có quá nhiều biên giả hoặc xác định thiếu biên. Đây chính là một trong những điều khiến Canny vẫn là kỹ thuật dò biên tốt nhất hiện nay.", "order_start": 1951, "order_end": 2382, "word_count": 92}
{"parent_id": "8e37496f-e7a1-4b31-99ce-6db4dcc8faec", "subject": "Xulyanh", "section": "4.2.1. Biên và độ biến đổi về mức xám", "title_path": "4.2.1. Biên và độ biến đổi về mức xám", "content": "[Xulyanh / 4.2.1. Biên và độ biến đổi về mức xám] Như đã trình bày ở trên trong thực tế người ta thường dùng hai phương pháp phát hiện biên cơ bản là: Phát hiện biên trực tiếp và gián tiếp. Phần này đề cập đến kỹ thuật dựa vào trung bình cục bộ trên cơ sở đánh giá độ chênh lệch về giá trị mức xám của điểm ảnh so với các điểm lân cận do đó kết hợp được ưu điểm của cả hai khuynh hướng trực tiếp và gián tiếp. Đối với các ảnh màu theo mô hình nào đó đều có thể chuyển sang mô hình gồm 3 thành phần mầu R, G, B. Sau đó dễ dàng chuyển các ảnh màu sang dạng ảnh đa cấp xám. Giá trị xám của điểm ảnh có thể được tính là trung bình cộng của ba thành phân màu R,G và B. Việc xử lý, thao tác trên các ảnh xám có một ưu điểm là dễ xử lý hơn các ảnh màu mà vẫn giữ được các đặc tính của ảnh. Các ảnh trắng đen tuy dễ xử lý nhất nhưng sẽ bị mất nhiều chi tiết sau khi chuyển đổi.", "order_start": 0, "order_end": 819, "word_count": 193}
{"parent_id": "8e37496f-e7a1-4b31-99ce-6db4dcc8faec", "subject": "Xulyanh", "section": "4.2.1. Biên và độ biến đổi về mức xám", "title_path": "4.2.1. Biên và độ biến đổi về mức xám", "content": "[Xulyanh / 4.2.1. Biên và độ biến đổi về mức xám] các ảnh xám có một ưu điểm là dễ xử lý hơn các ảnh màu mà vẫn giữ được các đặc tính của ảnh. Các ảnh trắng đen tuy dễ xử lý nhất nhưng sẽ bị mất nhiều chi tiết sau khi chuyển đổi. Một cách lý tưởng đồ thị biến thiên mức xám của điểm ảnh khi qua biên phải có dạng: Trong thực tế dạng đồ thị này chỉ gặp trong các ảnh trắng đen (ảnh xám có hai màu), còn với các ảnh thực thì đồ thị của nó có dạng: Khó khăn cho việc phân tích các ảnh trên thực tế là ở chỗ sự biến thiên về mức xám của điểm ảnh không phải chỉ được thể hiện theo một hướng duy nhất mà phải xét theo cả tám hướng của các điểm ảnh láng giềng, tại các vùng biên và lân cận biên sự biến thiên mức xám của các điểm ảnh thường không đột ngột mà trải qua một khoảng biến thiên không đều nhưng có tốc độ biến thiên nhanh. Chúng ta có thể xác định được các đường biên như thế này bằng kỹ thuật Laplace nhưng như ở trên đã nói kỹ thuật này rất nhạy cảm với nhiễu mà nhiễu hầu như lại là vấn đề mà ở trong bức ảnh nào cũng có.", "order_start": 819, "order_end": 1797, "word_count": 225}
{"parent_id": "8e37496f-e7a1-4b31-99ce-6db4dcc8faec", "subject": "Xulyanh", "section": "4.2.1. Biên và độ biến đổi về mức xám", "title_path": "4.2.1. Biên và độ biến đổi về mức xám", "content": "[Xulyanh / 4.2.1. Biên và độ biến đổi về mức xám] ịnh được các đường biên như thế này bằng kỹ thuật Laplace nhưng như ở trên đã nói kỹ thuật này rất nhạy cảm với nhiễu mà nhiễu hầu như lại là vấn đề mà ở trong bức ảnh nào cũng có. Ngoài ra, trong thực tế khi dò biên cho các ảnh xám tùy theo mục đích xử lý sau này mà người ta có thể muốn lấy biên của tất cả các đối tượng trong ảnh hoặc chỉ một số đối t ư ợng chính trong ảnh. Các kỹ thuật đạo hàm do sử dụng các mặt nạ là các ma trận nhân chập nên khó điều chỉnh độ chi tiết của ảnh biên thu được. Muốn làm được điều này lại phải tính toán lại các giá trị của các phần tử trong ma trận theo các công thức nhất định, rất phức tạp và tốn kém. Không những thế ảnh thu được sau khi lọc không làm mất đi được tất cả các điểm không thuộc đường biên mà chỉ làm nổi lên các điểm nằm trên biên và muốn nhận dạng được các đối tượng thì ta còn phải xử lý thêm một vài bước nữa thì mới thu được ảnh biên thực sự. Có thể nhận thấy là các thuật toán dò biên truyền thống mà chúng ta hay dùng vẫn chưa đạt được sự hoàn thiện như mong muốn.", "order_start": 1797, "order_end": 2823, "word_count": 236}
{"parent_id": "28ac54d4-c193-491a-842d-879a7a81d384", "subject": "Xulyanh", "section": "4.2.2. Phát hiện biên dựa vào trung bình cục bộ", "title_path": "4.2.2. Phát hiện biên dựa vào trung bình cục bộ", "content": "[Xulyanh / 4.2.2. Phát hiện biên dựa vào trung bình cục bộ] Ý tưởng chính của thuật toán được đề xuất là: Xác định tất cả các điểm nằm trên biên không theo hướng tìm kiếm và sử dụng các ma trận lọc, thông qua việc so sánh độ chênh lệch về mức xám của nó so với mức xám chung của các điểm ảnh lân cận (mức xám nền). Trước hết giá trị xám trung bình của các điểm ảnh nằm trong phạm vi của ma trận 3×3 hoặc 5×5 có tâm là điểm ảnh đang xét sẽ được tính toán. Nếu như độ chênh lệch mức xám giữa điểm đang xét với giá trị xám trung bình thỏa mãn lớn hơn một mức tối thiểu δ1 nào đó (PTB+ δ1< P) thì chúng ta sẽ coi nó là điểm biên và ghi nhận lại, còn các điểm không thỏa mãn điều kiện trên sẽ được coi là điểm nền. a) Ma trận điểm ảnh trước khi lọc b) Ma trận điểm ảnh sau khi lọc", "order_start": 0, "order_end": 715, "word_count": 165}
{"parent_id": "c91e23f4-54d4-41db-8ff2-96533503dcd0", "subject": "Xulyanh", "section": "Thuật toán có thể được mô tả như sau:", "title_path": "Thuật toán có thể được mô tả như sau:", "content": "[Xulyanh / Thuật toán có thể được mô tả như sau:] for (i=0; i< biHeight; i++){ for (j=0; j< biWidth; j++){ tt_GrayScale=0; for (ii=i-1; ii<=i+1; ii++) for (jj=j-1; jj<=j+1; j++) tt_GrayScale+=GetPoint pOrgImg,ii,jj); } } if (tt_GrayScal e>9*GetP int(pOrgImg,i,j)+δ ){ SetPoint(pBdImg ,i,j,BLACK); } } Trong đó:  biWidth, biHeight: là chiều rộng và chiều cao của ảnh tính theo đơn vị Pixel.  pOrgImg, pBdImg: lần lượt là các con trỏ trỏ đến các vùng dữ liệu của ảnh gốc và ảnh biên.  tt_GrayScale: là tổng giá trị độ xám của các điểm ảnh thuộc ma trận 3×3 có tâm là điểm ảnh đang xét.  δ1: là độ chênh lệch mức xám của điểm ảnh đang xét so với giá trị xám trung bình của ma trận.  SetPoint() và GetPoint(): là các hàm đọc, ghi giá trị điểm ảnh. Chúng ta có thể so sánh được hiệu quả của thuật toán phát hiện biên này so với các thuật toán phát hiện biên truyền thống thông qua các hình minh họa dưới đây. Hình 4.3a là ảnh gốc, Hình 4.3b là ảnh biên qua lọc Sobel Hx, Hình 4.3c là ảnh biên qua lọc Sobel Hy, Hình 4.3d là ảnh biên qua lọc Kirsh, Hình 4.2e là ảnh biên qua lọc Laplace. Hình 4.", "order_start": 0, "order_end": 1044, "word_count": 205}
{"parent_id": "c91e23f4-54d4-41db-8ff2-96533503dcd0", "subject": "Xulyanh", "section": "Thuật toán có thể được mô tả như sau:", "title_path": "Thuật toán có thể được mô tả như sau:", "content": "[Xulyanh / Thuật toán có thể được mô tả như sau:] 4.3a là ảnh gốc, Hình 4.3b là ảnh biên qua lọc Sobel Hx, Hình 4.3c là ảnh biên qua lọc Sobel Hy, Hình 4.3d là ảnh biên qua lọc Kirsh, Hình 4.2e là ảnh biên qua lọc Laplace. Hình 4.3 là các ảnh biên thu được khi sử dụng thuật toán phát hiện biên đề xuất dựa vào trung bình cục bộ với giá trị δ1 khác nhau. Hình 4.3a là ảnh biên thu được với δ1= 25, Hình 4.3b là ảnh biên thu được với δ1= 250. Hình 4.3. Các ảnh biên theo các thuật toán phát hiện biên truyền thống Chúng ta có nhận xét là ảnh gốc sử dụng trong chương trình có mầu nền khá tối và có rất nhiều nhiễu. Các bộ lọc sử dụng trong minh họa trên đều mắc phải vấn đề này. Thuật toán dò biên sử dụng trong chương trình tuy đã hạn chế được nhiều nhiễu so với việc sử dụng các bộ lọc và làm nổi rõ các đường biên nhưng vẫn không loại bỏ được hầu hết các nhiễu. Khi áp dụng thuật toán trên chúng ta vẫn có thể làm giảm bớt nhiễu đi nhiều hơn nữa bằng cách tăng giá trị của hệ số δ1 lên. Nhưng khi đó các đường biên thu được cũng bị đứt đoạn và mờ đi nhiều. Thuật toán có độ phức tạp tỷ lệ với kích thước ảnh và kích thước cửa sổ.", "order_start": 1044, "order_end": 2125, "word_count": 243}
{"parent_id": "c91e23f4-54d4-41db-8ff2-96533503dcd0", "subject": "Xulyanh", "section": "Thuật toán có thể được mô tả như sau:", "title_path": "Thuật toán có thể được mô tả như sau:", "content": "[Xulyanh / Thuật toán có thể được mô tả như sau:] g cách tăng giá trị của hệ số δ1 lên. Nhưng khi đó các đường biên thu được cũng bị đứt đoạn và mờ đi nhiều. Thuật toán có độ phức tạp tỷ lệ với kích thước ảnh và kích thước cửa sổ. Độ phức tạp của thuật toán là O(n2 ) nên nó thực hiện việc tìm biên khá nhanh, ảnh biên thu được chỉ gồm các điểm ảnh và điểm biên nên dễ xử lý, bản thân thuật toán này cũng ít chịu ảnh hưởng của nhiễu hơn là kỹ thuật Sobel mặc dù nó có khả năng phát hiện khá tốt các vùng biên nhiễu. Nhưng cũng giống các phương pháp phát hiện biên trực tiếp khác là nó cho kết quả đường biên có độ dày không đều.", "order_start": 2125, "order_end": 2703, "word_count": 132}
{"parent_id": "49824b43-78f5-4f6f-a5f0-2d3ee1a825d0", "subject": "Xulyanh", "section": "4.3.1. Một số khái niệm cơ bản *Ảnh và điểm ảnh", "title_path": "4.3.1. Một số khái niệm cơ bản *Ảnh và điểm ảnh", "content": "[Xulyanh / 4.3.1. Một số khái niệm cơ bản *Ảnh và điểm ảnh] Ảnh số là một mảng số thực 2 chiều (Iij) có kích thước (MN), trong đó mỗi phần tử Iij(i = 1,...,M; j = 1,...,N) biểu thị mức xám của ảnh tại (i,j) tương ứng. Ảnh được gọi là ảnh nhị phân nếu các giá trị Iij chỉ nhận giá trị 0 hoặc 1. Ở đây ta chỉ xét tới ảnh nhị phân vì ảnh bất kỳ có thể đưa về dạng nhị phân bằng kỹ thuật phân ngưỡng. Ta ký hiệu  là tập các điểm vùng (điểm đen) và  là tập các điểm nền (điểm trắng).", "order_start": 0, "order_end": 421, "word_count": 99}
{"parent_id": "b196def9-897e-40d8-b5a5-b624624c1fce", "subject": "Xulyanh", "section": "*Các điểm 4 và 8-láng giềng", "title_path": "*Các điểm 4 và 8-láng giềng", "content": "[Xulyanh / *Các điểm 4 và 8-láng giềng] Giả sử (i,j) là một điểm ảnh, các điểm 4-láng giềng là các điểm kề trên, dưới, trái, phải của (i,j): và những điểm 8-láng giềng gồm: Trong Hình 3.1 biểu diễn ma trận 8 láng giềng kề nhau, các điểm P0, P2, P4, P6 là các 4-láng giềng của điểm P, còn các điểm P0, P1, P 2, P3, P4, P5, P6, P7 là các 8-láng giềng của P.", "order_start": 0, "order_end": 315, "word_count": 70}
{"parent_id": "c15362a7-c407-40ee-88ac-e6f6e38c7bd1", "subject": "Xulyanh", "section": "*Đối tượng ảnh", "title_path": "*Đối tượng ảnh", "content": "[Xulyanh / *Đối tượng ảnh] Hai điểm Ps, Pe  E, E   hoặc  được gọi là 8-liên thông (hoặc 4-liên thông) trong E nếu tồn tại tập các điểm được gọi là đường đi (io,jo)...(in,jn) sao cho (io,jo)= Ps, (in,jn)= Pe, (ir,jr)  E và (ir,jr) là 8-láng giềng (hoặc 4-láng giềng tương ứng) của (ir-1,jr-1) với r = 1,2,...,n Quan hệ k-liên thông trong E (k=4,8) là một quan hệ phản xạ, đối xứng và bắc cầu. Bởi vậy đó là một quan hệ tương đương. Mỗi lớp tương đương được gọi là một thành phần k-liên thông của ảnh. Về sau ta sẽ gọi mỗi thành phần k-liên thông của ảnh là một đối tượng ảnh.", "order_start": 0, "order_end": 552, "word_count": 116}
{"parent_id": "daad11e1-044e-4595-8b82-2c3072ed5f96", "subject": "Xulyanh", "section": "4.3.2. Chu tuyến của một đối tượng ảnh Định nghĩa 4.1: [Chu tuyến]", "title_path": "4.3.2. Chu tuyến của một đối tượng ảnh Định nghĩa 4.1: [Chu tuyến]", "content": "[Xulyanh / 4.3.2. Chu tuyến của một đối tượng ảnh Định nghĩa 4.1: [Chu tuyến]] Chu tuyến của một đối tượng ảnh là dãy các điểm của đối tượng ảnh P1,,Pn sao cho Pi và Pi+1 là các 8-láng giềng của nhau (i=1,...,n-1) và P1 là 8-láng giềng của Pn, i Q không thuộc đối tượng ảnh và Q là 4-láng giềng của Pi. Kí hiệu <P1P2..Pn>. Tổng các khoảng cách giữa hai điểm kế tiếp của chu tuyến là độ dài của chu tuyến và kí hiệu Len(C) và hướng PiPi+1 là hướng chẵn nếu Pi và Pi+1 là các 4 – láng giềng (trường hợp còn lại thì PiPi+1 là hướng lẻ). Hình 4.6 dưới đây biểu diễn chu tuyến của ảnh, trong đó, P là điểm khởi đầu chu tuyến.", "order_start": 0, "order_end": 544, "word_count": 118}
{"parent_id": "4ef7506d-c632-44eb-9670-7d1396cb04df", "subject": "Xulyanh", "section": "Định nghĩa 4.2 [Chu tuyến đối ngẫu]", "title_path": "Định nghĩa 4.2 [Chu tuyến đối ngẫu]", "content": "[Xulyanh / Định nghĩa 4.2 [Chu tuyến đối ngẫu]] Hai chu tuyến C= <P1P2..Pn> và C = <Q1Q2..Qm> được gọi là đối ngẫu của nhau nếu và chỉ nếu i j sao cho: (i) Pi và Qj là 4-láng giềng của nhau. (ii) Các điểm Pi là vùng thì j là nền và ngược lại.", "order_start": 0, "order_end": 197, "word_count": 46}
{"parent_id": "18129f7f-7b20-4d1a-aa2c-df5450f9f2fd", "subject": "Xulyanh", "section": "Định nghĩa 4.3 [Chu tuyến ngoài]", "title_path": "Định nghĩa 4.3 [Chu tuyến ngoài]", "content": "[Xulyanh / Định nghĩa 4.3 [Chu tuyến ngoài]] Chu tuyến C được gọi là chu tuyến ngoài (Hình 4.7a) nếu và chỉ nếu (i) Chu tuyến đối ngẫu C là chu tuyến của các điểm nền (ii) Độ dài của C nhỏ hơn độ dài C", "order_start": 0, "order_end": 158, "word_count": 38}
{"parent_id": "f22db221-b312-4d0c-a6d9-18790108f196", "subject": "Xulyanh", "section": "Định nghĩa 4.4 [Chu tuyến trong]", "title_path": "Định nghĩa 4.4 [Chu tuyến trong]", "content": "[Xulyanh / Định nghĩa 4.4 [Chu tuyến trong]] Chu tuyến C được gọi là chu tuyến trong (Hình 4.7b) nếu và chỉ nếu: (i) Chu tuyến đối ngẫu C là chu tuyến của các điểm nền (ii) Độ dài của C lớn hơn độ dài C", "order_start": 0, "order_end": 159, "word_count": 38}
{"parent_id": "f882b7c8-24fc-496b-af59-2ee2c6035d70", "subject": "Xulyanh", "section": "Định nghĩa 4.5 [Điểm trong và điểm ngoài chu tuyến]", "title_path": "Định nghĩa 4.5 [Điểm trong và điểm ngoài chu tuyến]", "content": "[Xulyanh / Định nghĩa 4.5 [Điểm trong và điểm ngoài chu tuyến]] Giả sử C= <P1P2..Pn> là chu tuyến của một đối tượng ảnh và P là một điểm ảnh. Khi đó: (i) Nếu nửa đường thẳng xuất phát từ P sẽ cắt chu tuyến C tại số lẻ lần, thì P được gọi là điểm trong chu tuyến C và kí hiệu in(P,C) (ii) Nếu PC và P không phải là điểm trong của C, thì P được gọi là điểm ngoài chu tuyến C và kí hiệu out(P,C).", "order_start": 0, "order_end": 330, "word_count": 78}
{"parent_id": "46587ca1-4da4-4fc1-8d7b-4cbbcd930651", "subject": "Xulyanh", "section": "Bổ đề 4.1 [Chu tuyến đối ngẫu]", "title_path": "Bổ đề 4.1 [Chu tuyến đối ngẫu]", "content": "[Xulyanh / Bổ đề 4.1 [Chu tuyến đối ngẫu]] Giả sử E   là một đối tượng ảnh và C= < P1P2..Pn> là chu tuyến của E, C =<Q1Q2..Qm> là chu tuyến đối ngẫu tương ứng. Khi đó: (i) Nếu C là chu tuyến trong thì in(Qi,C) i (i=1,....,m) (ii) Nếu C là chu tuyến ngoài thì in(Pi,C ) i (i=1,...,n)", "order_start": 0, "order_end": 245, "word_count": 53}
{"parent_id": "6653eea1-8915-4a10-82f8-7b7b9c40c94a", "subject": "Xulyanh", "section": "Bổ đề 4.2 [Phần trong/ngoài của chu tuyến]", "title_path": "Bổ đề 4.2 [Phần trong/ngoài của chu tuyến]", "content": "[Xulyanh / Bổ đề 4.2 [Phần trong/ngoài của chu tuyến]] Giả sử E   là một đối tượng ảnh và C là chu tuyến của E. Khi đó: (i) Nếu C là chu tuyến ngoài thì x  E sao cho xC, ta có in(x,C) (ii) Nếu C là chu tuyến trong thì x  E sao cho xC, ta có out(x,C)", "order_start": 0, "order_end": 202, "word_count": 53}
{"parent_id": "1301e298-9b88-490a-a64f-c2b949bd9de4", "subject": "Xulyanh", "section": "Định lý 4.1 [Tính duy nhất của chu tuyến ngoài]", "title_path": "Định lý 4.1 [Tính duy nhất của chu tuyến ngoài]", "content": "[Xulyanh / Định lý 4.1 [Tính duy nhất của chu tuyến ngoài]] Giả sử E   là một đối tượng ảnh và CE là chu tuyến ngoài của E. Khi đó CE là duy nhất.", "order_start": 0, "order_end": 88, "word_count": 24}
{"parent_id": "de2f1000-b0be-43e3-977d-2d9008be7bb4", "subject": "Xulyanh", "section": "4.3.3. Thuật toán dò biên tổng quát", "title_path": "4.3.3. Thuật toán dò biên tổng quát", "content": "[Xulyanh / 4.3.3. Thuật toán dò biên tổng quát] Biểu diễn đối tượng ảnh heo chu tuyến thường dựa trên các kỹ thuật dò biên. Có hai kỹ thuật dò biên cơ bản. Kỹ thuật thứ nhất xét ảnh biên thu được từ ảnh vùng sau một lần duyệt như một đồ thị, sau đó áp dụng các thuật toán duyệt cạnh đồ thị. Kỹ thuật thứ hai dựa trên ảnh vùng, kết hợp đồng th quá trình dò biên và tách biên. Ở đây ta quan tâm cách tiếp cận thứ hai. Trước hết, giả sử ảnh được xét chỉ bao gồm một vùng ảnh 8-liên thông , được bao bọc bởi một vành đai các điểm nền. Dễ thấy  là một vùng 4-liên thông chỉ là một trường riêng của trường hợp trên. Về cơ bản, các thuật toán dò biên trên một vùng đều bao gồm các bước sau:  Xác định điểm biên xuất phát  Dự báo và xác định điểm biên tiếp theo  Lặp bước 2 cho đến khi gặp điểm xuất phát Do xuất phát từ những tiêu chuẩn và định nghĩa khác nhau về điểm biên, và quan hệ liên thông, các thuật toán dò biên cho ta các đường biên mang các sắc thái rất khác nhau. Kết quả tác động của toán tử dò biên lên một điểm biên ri là điểm biên ri+1 (8-láng giềng của ri).", "order_start": 0, "order_end": 1024, "word_count": 231}
{"parent_id": "de2f1000-b0be-43e3-977d-2d9008be7bb4", "subject": "Xulyanh", "section": "4.3.3. Thuật toán dò biên tổng quát", "title_path": "4.3.3. Thuật toán dò biên tổng quát", "content": "[Xulyanh / 4.3.3. Thuật toán dò biên tổng quát] ng, các thuật toán dò biên cho ta các đường biên mang các sắc thái rất khác nhau. Kết quả tác động của toán tử dò biên lên một điểm biên ri là điểm biên ri+1 (8-láng giềng của ri). Thông thường các toán tử này được xây dựng như một hàm đại số Boolean trên các 8-láng giềng của ri. Mỗi cách xây dựng các toán tử đều phụ thuộc vào định nghĩa quan hệ liên thông và điểm biên. Do đó sẽ gây khó khăn cho việc khảo sát các tính chất của đường biên. Ngoài ra, vì mỗi bước dò biên đều phải kiểm tra tất cả các 8-láng giềng của mỗi điểm nên thuật toán thường kém hiệu quả. Để khắc phục các hạn chế trên, thay vì sử dụng một điểm biên ta sử dụng cặp điểm biên (một thuộc , một thuộc ), các cặp điểm này tạo nên tập nền vùng, kí hiệu là NV và phân tích toán tử dò biên thành 2 bước: Xác định cặp điểm nền vùng tiếp theo.  Lựa chọn điểm biên Trong đó bước thứ nhất thực hiện chức năng của một ánh xạ trên tập NV lên NV và bước thứ hai thực hiện chức năng chọn điểm biên.", "order_start": 1024, "order_end": 1985, "word_count": 214}
{"parent_id": "77edf53f-5306-41fd-8f64-3a7b0095d91f", "subject": "Xulyanh", "section": "Thuật toán dò biên tổng quát", "title_path": "Thuật toán dò biên tổng quát", "content": "[Xulyanh / Thuật toán dò biên tổng quát] Bước 1: Xác định cặp nền-vùng xuất phát Bước 2: Xác định cặp nền-vùng tiếp theo Bước 3: Lựa chọn điểm biên vùng Bước 4: Nếu gặp lại cặp xuất phát thì dừng, nếu không quay lại bước 2 Việc xác định cặp nền-vùng xuất phát được thực hiện bằng cách duyệt ảnh lần lượt từ trên xuống dưới và từ trái qua phải rồi kiểm tra điều kiện lựa chọn cặp nền-vùng. Do việc chọn điểm biên chỉ mang tính chất quy ước, nên ta gọi ánh xạ xác định cặp nền-vùng tiếp theo là toán tử dò biên.", "order_start": 0, "order_end": 468, "word_count": 100}
{"parent_id": "64f6a991-e1ed-4160-85e0-17267eb2f085", "subject": "Xulyanh", "section": "Định nghĩa 4.6 [Toán tử dò biên]", "title_path": "Định nghĩa 4.6 [Toán tử dò biên]", "content": "[Xulyanh / Định nghĩa 4.6 [Toán tử dò biên]] Giả sử T là một ánh xạ như sau NV  NV Gọi T là một toán tử dò biên cơ sở nếu nó thoả mãn điều kiện: b’,r’ là các 8-láng giềng của r. Giả sử (b,r)  NV; gọi K(b,r) là hàm chọn điểm biên. Biên của một dạng  có thể định nghĩa theo một trong ba cách:  Tập những điểm thuộc  có mặt trên NV, tức là K(b,r)= r  Tập những điểm thuộc  có trên NV, tức là K(b,r)= b Tập những điểm ảo nằm giữa cặp nền-vùng, tức là K(b,r) là những điểm nằm giữa hai điểm b và r. Cách định nghĩa thứ ba tương ứng mỗi cặp nền-vùng với một điểm biên. Còn đối với cách định nghĩa thứ nhất và thứ hai một số cặp nền-vùng có thể có chung một điểm biên. Bởi vậy, quá trình chọn điểm biên được thực hiện như sau: i:= 1; (bi,ri):= (bo,ro); While K(bi,ri)<>K(bn,rn) and i8 do Begin (bi+1,ri+1)= T(bi,ri); i:= i+1; End; Điều kiện dừng: Cặp nền-vùng thứ n trùng với cặp nền vùng xuất phát: (bn,rn)= (bo,ro)", "order_start": 0, "order_end": 872, "word_count": 188}
{"parent_id": "206b3d8e-38f4-479e-acac-ee43ad4b6e76", "subject": "Xulyanh", "section": "* Xác định cặp nền – vùng xuất phát", "title_path": "* Xác định cặp nền – vùng xuất phát", "content": "[Xulyanh / * Xác định cặp nền – vùng xuất phát] Cặp nền vùng xuất phát được xác định bằng cách duyệt ảnh lần lượt từ trên xuống dưới và từ trái sang phải điểm đem đầu tiên gặp được cùng với điểm trắng trước đó (theo hướng 4) để tạo nên cặp nền vùng xuất phát.", "order_start": 0, "order_end": 211, "word_count": 46}
{"parent_id": "de6eaff5-33b1-4c86-8f71-62b12978554a", "subject": "Xulyanh", "section": "* Xác định cặp nền vùng tiếp theo", "title_path": "* Xác định cặp nền vùng tiếp theo", "content": "[Xulyanh / * Xác định cặp nền vùng tiếp theo] Đầu vào: pt, dir Ví dụ: (3, 2) 4 Point orient []= (1,0);(1;-1);(0;-1);(-1;-1);(-1;0);(-1,1);(0,1);(1,1); //Hàm tìm hướng có điểm đen gần nhất BYTE GextNextDir(POINT pt, BYTE dir) { BYTE pdir= (dir + 7)%8; do{ if(getpixel(pt. x+orient pdir. x,pt.y+orient pdir. y))==BLACK) return pdir; pdir = (pdir + 7) %8; }while(pdir ! = dir); return. ERR; //Điểm cô lập } pdir = GetNextDir(pt, dir); if(pdir==ERR) //Kiểm tra return. ERR; //Điểm cô pt. x = pt. x + orient pdir. x; pt. y = pt. y + o rient pdir. y; Để tính giá trị cho hướng tiếp theo ta lập bảng dựa trên giá trị pdir đã tính được trước đó theo các khả năng có thể xảy ra:  Do đó công thức để tính hướng tiếp theo sẽ là:", "order_start": 0, "order_end": 682, "word_count": 128}
{"parent_id": "8965ec07-f548-48c0-8fa8-f21302b1270d", "subject": "Xulyanh", "section": "4.4.1. Các phép toán hình thái c1. cơ bản", "title_path": "4.4.1. Các phép toán hình thái c1. cơ bản", "content": "[Xulyanh / 4.4.1. Các phép toán hình thái c1. cơ bản] Hình thái là thuật ngữ chỉ sự nghiật nghiên cứu về cấu trúc hay hình hình học topo của đối tượng trong ảnh. Phần lớn các pphép toán của \"Hình thái\" được định nghĩa từ hai phép toán cợc nghĩa hai cơ bản là phép \"giãn nở\" (Dilation) vở\" và phép \"co\" (Erosion). Các phép toán này đưđược định nghĩa như sau: Giả thiết ta có đối tả thiết tượng X và phần tử cấu trúc (mẫu) B trong không gian Euclide hai chiều. Kấu Kí hiệu Bx là ddịch chuyển của B tới vị trí x.", "order_start": 0, "order_end": 455, "word_count": 97}
{"parent_id": "613718c2-c6ee-4463-bcca-1c58f26ea370", "subject": "Xulyanh", "section": "Định nghĩa 4.7 (DILATION)", "title_path": "Định nghĩa 4.7 (DILATION)", "content": "[Xulyanh / Định nghĩa 4.7 (DILATION)] Phép \"giãn nở\" của X theo mẫu B lở\" là hợp của tất cả các Bx vớiới x thuộc X. Ta có:", "order_start": 0, "order_end": 84, "word_count": 22}
{"parent_id": "0d4e3b94-d6b0-42b0-acd2-31034076296e", "subject": "Xulyanh", "section": "Định nghĩa 4.7 (EROSION)", "title_path": "Định nghĩa 4.7 (EROSION)", "content": "[Xulyanh / Định nghĩa 4.7 (EROSION)] Phép \"co\" của X theo B lủa là tập hợp tất cả các điểm x sao cho Bm x Bx nằm trong X. Ta có:", "order_start": 0, "order_end": 91, "word_count": 25}
{"parent_id": "b39d6ae6-cd32-4864-8d02-84d04ef068bd", "subject": "Xulyanh", "section": "Đình nghĩa 4.9 (OPEN)", "title_path": "Đình nghĩa 4.9 (OPEN)", "content": "[Xulyanh / Đình nghĩa 4.9 (OPEN)] Phép toán mở (OPEN) của X theo cấu trúc B lở là tập hợp cácập các điểm của ảnh X sau khi đểm đã co và giãn nở liên liếp theo B. Ta có: Ví dụ: Với tập X và B trong ví ddụ trên ta có", "order_start": 0, "order_end": 180, "word_count": 47}
{"parent_id": "5a857a4d-4a63-4b8f-ab76-2127356ca76a", "subject": "Xulyanh", "section": "Định nghĩa 4.10 (CLOSECLOSE)", "title_path": "Định nghĩa 4.10 (CLOSECLOSE)", "content": "[Xulyanh / Định nghĩa 4.10 (CLOSECLOSE)] Phép toán đóng (CLOSE) ccủa X theo cấu trúc B là tập hợp các điểm của ảnh X sau ập các ảnh khi đã giãn nở và co liên tià tiếp theo B. Ta có: CLOSE(X,B) = (X  B)  B Theo ví dụ trên ta có:", "order_start": 0, "order_end": 188, "word_count": 48}
{"parent_id": "48a3ecd0-6069-461b-aa50-6b35e2e95a70", "subject": "Xulyanh", "section": "4.4.2. Một số tính chất của phép toán hột hình thái * Mệnh đề 4.1 [Tính gia tăngtăng]:", "title_path": "4.4.2. Một số tính chất của phép toán hột hình thái * Mệnh đề 4.1 [Tính gia tăngtăng]:", "content": "[Xulyanh / 4.4.2. Một số tính chất của phép toán hột hình thái * Mệnh đề 4.1 [Tính gia tăngtăng]:] (i) X  X’  X  B  X’  B B X  B  X’  B B (ii) B  B'  X  B  X B' X X  B  X  B’ X Chứng minh:", "order_start": 0, "order_end": 109, "word_count": 43}
{"parent_id": "357ca77e-5a3e-4684-bef1-2ed6ad8443a7", "subject": "Xulyanh", "section": "Untitled", "title_path": "Untitled", "content": "[Xulyanh / Untitled] (i) X  B = B  B x  x   B' xX x X ' X  B = x / Bx = X’  B  x / Bx  X ' (ii) X  B = B  x   B' X B'  x x Theo định nghĩa:", "order_start": 0, "order_end": 139, "word_count": 55}
{"parent_id": "92f49189-2ee5-4d08-b1fb-7f0f4bd34330", "subject": "Xulyanh", "section": "*Mệnh đề 4.2 [Tính phân phTính phối với phép ]:", "title_path": "*Mệnh đề 4.2 [Tính phân phTính phối với phép ]:", "content": "[Xulyanh / *Mệnh đề 4.2 [Tính phân phTính phối với phép ]:] (i) X  (B  B') = (X  B)  (X  B') (ii) X (B  B') = (X  B)  (X B')", "order_start": 0, "order_end": 74, "word_count": 26}
{"parent_id": "eb507716-fe98-4dd3-ad62-142146acd4a8", "subject": "Xulyanh", "section": "Chứng minh:", "title_path": "Chứng minh:", "content": "[Xulyanh / Chứng minh:] (i) X  (B  B’) = (X  B)  (X  B’) Ta có: B  B’  B X  (B  B’)  X  B (tính gia tăng) Tương tự: Mặt khác, (ii) X  (B  B’) = (X  B)  (X  B’) Ta có: B  B’  B  X  (B  B’)  X  (tính gia g) Tương tự: X  (B  B’)  X  B’  X  (B  B’)  (X  B)  (X  B’) Mặt khác, * Ý nghĩa: Ta có thể phân tích các mẫu phức tạp trở thành các mẫu đơn giản thuận tiện cho việc cài đặt. * Mệnh đề 4.3 [Tính phân phối với phép ]:", "order_start": 0, "order_end": 428, "word_count": 131}
{"parent_id": "334d2030-74d9-40ce-810c-3ce0ea1bc475", "subject": "Xulyanh", "section": "Chứng minh:", "title_path": "Chứng minh:", "content": "[Xulyanh / Chứng minh:] Ta có, X  Y  X  (X  Y)  B  X  B Tương tự: (X  Y)  B  Y  B Mặt khác, * Mệnh đề 4.4 [Tính kết hợp] (i) (X  B)  B' = X  (B  B') (ii) (X  B)  B' = X  (B  B')", "order_start": 0, "order_end": 172, "word_count": 61}
{"parent_id": "f1cf5f9b-7e2d-435a-9b34-e4a8d7785429", "subject": "Xulyanh", "section": "Chứng minh:", "title_path": "Chứng minh:", "content": "[Xulyanh / Chứng minh:] (i) (X  B)  B' = X  (B'  B) (i) (X  B)  B' = X  (B  B') Trước hết ta đi chứng minh: ' Bx  X  B  B B x( ) '   X Thật vậy, do ' Bx  X  B nên y ' Bx  yX  B Mặt khác, B B x( ) '   X  ( ' Bx  B)  X Do đó, ' B  X  B", "order_start": 0, "order_end": 236, "word_count": 88}
{"parent_id": "44c455f4-ef93-4cdd-8701-188d9fc780f1", "subject": "Xulyanh", "section": "* Định lý 4.2 [X bị chặn bởi các cận OPEN và CLOSE]", "title_path": "* Định lý 4.2 [X bị chặn bởi các cận OPEN và CLOSE]", "content": "[Xulyanh / * Định lý 4.2 [X bị chặn bởi các cận OPEN và CLOSE]] Giả sử, X là một đối tượng ảnh, B là mẫu, khi đó, X sẽ bị chặn trên bởi tập CLOSE của X theo B và bị chặn dưới bởi tập OPEN của X theo B. Tức là: (X  B)  B  X  (X  B)  B", "order_start": 0, "order_end": 175, "word_count": 51}
{"parent_id": "405b8942-1239-4e89-bcce-76b0703519b8", "subject": "Xulyanh", "section": "Chứng minh:", "title_path": "Chứng minh:", "content": "[Xulyanh / Chứng minh:] Mặt khác, Suy ra: X  (X  B)  B Từ (4.7) và (4.8) Ta có: (X  B)  B  X  (X  B)  B.", "order_start": 0, "order_end": 89, "word_count": 30}
{"parent_id": "42107008-4702-4077-8632-8dd3cd3bfc52", "subject": "Xulyanh", "section": "*Hệ quả 4.1 [Tính bất biến]:", "title_path": "*Hệ quả 4.1 [Tính bất biến]:", "content": "[Xulyanh / *Hệ quả 4.1 [Tính bất biến]:] (i) ((X  B) B)  B = X  B (ii) ((X  B)  B)  B = XB", "order_start": 0, "order_end": 57, "word_count": 21}
{"parent_id": "80233048-19a7-4358-a5fc-37fd0c35c7d3", "subject": "Xulyanh", "section": "Chứng minh:", "title_path": "Chứng minh:", "content": "[Xulyanh / Chứng minh:] (i) Thật vậy, từ định lý 4.2 ta có X  (X  B) Ө B  X  B  ((X  B) B)  B (do tính chất gia tăng) Mặt khác, cũng từ định lý 4.2 ta có (X  B)  B  X X Do đó, thay X bởi X  B ta có, ((X  B) B)  B  X  B Từ (4.9) và (4.10) Ta có: ((X  B) B)  B = X  B (ii) Thật vậy, từ định lý 4.2 ta có (X  B)  B  X Mặt khác, cũng từ định lý 4.2 ta có X  (X  B) Ө B X Do đó, thay X bởi X  B ta có, XB  ((X  B)  B)  B Từ (4.11) và (4.12) Ta có: ((X  B)  B)  B = XB (đpcm).", "order_start": 0, "order_end": 484, "word_count": 153}
{"parent_id": "3e9024ff-b71d-4247-b0a5-3410b115a340", "subject": "Xulyanh", "section": "4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh", "title_path": "4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh", "content": "[Xulyanh / 4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh] Biên là vấn đề quan trọng trong xử lý ảnh và nhận dạng, vì các đặc điểm trích chọn trong quá trình nhận dạng chủ yếu dựa vào biên. Trong thực tế người ta thường dùng hai phương pháp pháp hiện biên cơ bản là: Phát hiện biên trực tiếp và gián tiếp. Phần này đề cập đến một tiếp cận mới trong phát hiện biên dựa vào các phép toán hình thái thông qua các kỹ thuật xấp xỉ trên và xấp xỉ dưới đối tượng. Cũng đã có một vài tác giả đề cập đến kỹ thuật phát hiện biên dựa vào phép toán hình thái. Nhưng các kỹ thuật phát hiện biên trực tiếp, gián tiếp và dựa vào các phép toán hình thái kể trên đều xuất phát từ quan điểm biên của đối tượng là một tập hợp con của đối tượng. Trong thực tế chúng ta thường hiểu đường biên là khu vực ranh giới bao gồm cả hai phần thuộc đối tượng và không thuộc đối tượng. Ở phần dưới đây, chúng tôi đề xuất một kỹ thuật phát hiện biên dựa vào phép toán hình thái theo quan niệm này, xuất phát từ cơ sở định lý 4.2 đã được chứng minh ở trên. Biên (hay đường biên) có thể hiểu đơn giản là các đường bao của các đối tượng trong ảnh chính là ranh giới giữa đối tượng và nền.", "order_start": 0, "order_end": 1094, "word_count": 240}
{"parent_id": "3e9024ff-b71d-4247-b0a5-3410b115a340", "subject": "Xulyanh", "section": "4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh", "title_path": "4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh", "content": "[Xulyanh / 4.4.3. Xấp xỉ trên và xấp xỉ dưới đối tượng ảnh] át từ cơ sở định lý 4.2 đã được chứng minh ở trên. Biên (hay đường biên) có thể hiểu đơn giản là các đường bao của các đối tượng trong ảnh chính là ranh giới giữa đối tượng và nền. Việc xem ranh giới là phần được tạo lập bởi các điểm thuộc đối tượng và thuộc nền cho phép ta xác định biên dựa trên các phép toán hình thái. Theo định lý 4.2 ta có: (XB)B  X B Như vậy, tập CLOSE(X,B) = (XB)B có thể được xem như là xấp xỉ trên của tập X theo mẫu B (Hình 4.8).", "order_start": 1094, "order_end": 1557, "word_count": 105}
{"parent_id": "93eb8fbb-1435-4500-89b6-08fa97b56a73", "subject": "Xulyanh", "section": "Hình 4.8. Xấp xỉ trên và dưới theo mẫu B của X", "title_path": "Hình 4.8. Xấp xỉ trên và dưới theo mẫu B của X", "content": "[Xulyanh / Hình 4.8. Xấp xỉ trên và dưới theo mẫu B của X] Cũng theo định lý 4.2 ta có, (XB)B  X B Do vậy, tập OPEN(X,B) = (XB)B có thể được xem như là xấp xỉ dưới của tập X theo mẫu B. Từ đó, tập CLOSE(X,B)\\ OPEN(X,B) có thể được xem như là xấp xỉ biên của tập X theo mẫu và quá trình xấp xỉ biên của X theo mẫu B kí hiệu là X B. Để tăng độ chính xác, người ta thường xem B là dãy các phần tử cấu trúc. B = {Bi, 1 i  n } Và xấp xỉ biên của X theo tập cấu trúc B được xác định:", "order_start": 0, "order_end": 427, "word_count": 106}
{"parent_id": "87b466d1-4856-45d2-9d2b-f1793a706f05", "subject": "Xulyanh", "section": "4.4.4. Thuật toán phát hiện biên dựa vào phép toán hình thái", "title_path": "4.4.4. Thuật toán phát hiện biên dựa vào phép toán hình thái", "content": "[Xulyanh / 4.4.4. Thuật toán phát hiện biên dựa vào phép toán hình thái] Vào : Ảnh X và dãy mẫu B= {Bi, 1 i  n }; Ra : Biên của đối tượng theo mẫu B Phương pháp: Bước 1: Tính X  Bi i=1,n Bước 2: Tính Trong Hình 4.9a dưới đây là ảnh gốc với 256 mức xám, Hình 4.9b là ảnh biên thu được qua phát hiện biên bằng Sobel, Hình 4.9c là ảnh biên thu được qua phát hiện biên bằng Laplace. Hình 4.9d là ảnh biên kết quả thực hiện bởi thuật toán phát hiện biên bằng các phép toán hình thái với ngưỡng tách  = 128 và các mẫu tách biên Bi là: Hình 4.9. Phát hiện biên bởi thuật toán dựa vào phép toán hình thái", "order_start": 0, "order_end": 528, "word_count": 121}
{"parent_id": "e9cc78db-caa3-4e41-8dd0-bde29c6986f1", "subject": "Xulyanh", "section": "4.5. CÂU HỎI ÔN TẬP CHƯƠNG", "title_path": "4.5. CÂU HỎI ÔN TẬP CHƯƠNG", "content": "[Xulyanh / 4.5. CÂU HỎI ÔN TẬP CHƯƠNG] Câu 1: Điểm biên được định nghĩa như thế nào? Kỹ thuật phổ biến nhất để phát hiện biên là gì? Câu 2: Thực hiện cài đặt phương pháp tách biên Canny. Đầu vào của hệ thống là một ma trận ảnh đa cấp xám (0-255)và đầu ra là ảnh với chỉ hai loại điểm ảnh, điểm nền có giá trị là 0 và điểm biên có giá trị là 255. Câu 3: Thực hiện phép co và dãn hình X với một phần tử cấu trúc B sau để được hai hình X1 và X2. Thực hiên phép trừ để tìm ảnh biên. Được biết tâm của B là ở chính giữa. Câu 4: Thực hiện phép đóng và mở hình X với một phần tử cấu trúc B ở câu 3 để T được hai hình X1 và X2. Thực hiên phép trừ để tìm ảnh biên. Được biết tâm của B là ở chính giữa.", "order_start": 0, "order_end": 653, "word_count": 158}
{"parent_id": "b12f8c62-f66b-4cb1-b06c-7ce865c41a3a", "subject": "Xulyanh", "section": "5.1. GIỚI THIỆU", "title_path": "5.1. GIỚI THIỆU", "content": "[Xulyanh / 5.1. GIỚI THIỆU] Xử lý ảnh bao gồm các bước: thu nhận ảnh, tiền xử lý, phân đoạn ảnh, biểu diễn và giải thích, nhận dạng và mô tả (tuy nhiên không phải ứng dụng xử lý ảnh nào cũng phải có đầy đủ tất cả các bước trên). Trong các bước đó, bước phân đoạn ảnh là bước quan trọng nhất nhưng và cũng khó khăn nhất. Mặt khác, có nhiều ứng dụng quan trọng cần đến kỹ thuật phân đoạn: ảnh màu hoặc đa mức xám thì cần phải phân ngưỡng; muốn nhận dạng được các đối tượng thì trước hết cần phải phân ảnh thành các vùng khác nhau chứa các đối tượng trong ảnh: tách ra vùng là chữ, số trên bì thư hoặc fax trong phân loại thư, fax tự động; tách ra các vùng là chữ, hình ảnh, bảng biểu … trong các ứng dụng nhập dữ liệu tự động; tách ra vùng bị bỏng để đánh giá phần trăm diện tích bỏng trên da; tách ra vùng rừng bị cháy trong ảnh chụp từ máy bay, vệ tinh để phát hiện cháy rừng; tách ra ao, hồ, cây xanh từ ảnh chụp thành phố từ vệ tinh để đánh giá tỷ lệ ao hồ, cây xanh, nhà cửa của thành phố v.v.. Hình dáng của một đối tượng có thể được miê u tả hoặc bởi các tham số của đường biên hoặc các tham số của vùng mà nó chiếm giữ.", "order_start": 0, "order_end": 1097, "word_count": 246}
{"parent_id": "b12f8c62-f66b-4cb1-b06c-7ce865c41a3a", "subject": "Xulyanh", "section": "5.1. GIỚI THIỆU", "title_path": "5.1. GIỚI THIỆU", "content": "[Xulyanh / 5.1. GIỚI THIỆU] á tỷ lệ ao hồ, cây xanh, nhà cửa của thành phố v.v.. Hình dáng của một đối tượng có thể được miê u tả hoặc bởi các tham số của đường biên hoặc các tham số của vùng mà nó chiếm giữ. Sự miêu tả hình dáng dựa trên thông tin đường biên yêu cầu việc phát hiện biên. Sự mô tả hình dáng dựa vào vùng đòi hỏi việc phân đoạn ảnh thành một số vùng đồng nhất. Như vậy, phát hiện biên và phân vùng là hai cách tiếp cận đối ngẫu trong việc phân tích ảnh. Các vùng ảnh yêu cầu phải có các đặc tính đồng nhất (ví dụ như: cường độ, kết cấu) giúp phân biệt được từng vùng. Các đặc tính này tạo nên các vectơ đặc trưng (feature vectors) để phân biệt một vùng với các vùng khác. Các đặc trưng được sử dụng tron suốt quá trình phân đoạn theo các nguyên tắc kiểm tra tính đồng nhất của vùng. Chúng ta hãy giả sử rằng một miền ảnh X phải được phân đoạn thành N vùng khác nhau: R1, …, RN và nguyên tắc phân đoạn là một vị từ của công thức P(R). Cả miền ảnh X và các vùng của nó R1, …, RN có thể được miêu tả một cách tiện lợi bởi các tập con của plane ảnh (image plane) Z2.", "order_start": 1097, "order_end": 2147, "word_count": 235}
{"parent_id": "b12f8c62-f66b-4cb1-b06c-7ce865c41a3a", "subject": "Xulyanh", "section": "5.1. GIỚI THIỆU", "title_path": "5.1. GIỚI THIỆU", "content": "[Xulyanh / 5.1. GIỚI THIỆU] uyên tắc phân đoạn là một vị từ của công thức P(R). Cả miền ảnh X và các vùng của nó R1, …, RN có thể được miêu tả một cách tiện lợi bởi các tập con của plane ảnh (image plane) Z2. Việc phân đoạn ảnh chia tập X thành các tập con Ri, i = 1..N có những tính chất sau: Những vùng Ri, i=1..N phải lấp kín hoàn toàn ảnh, nó được thể hiện trong tính chất (5.1). Tính chất (5.2) đảm bảo rằng hai vùng khác nhau là những tập hợp rời nhau. Vị từ P(Ri) phải là TRUE trên mỗi vùng Ri để bảo đảm tính đồng nhất của vùng, có thể được thấy ở 5.3. Cuối cùng, vị từ P(RiRj) (i  j) phải là FALSE, bởi vì RiRj, i  j tương ứng với một vùng ảnh không đồng nhất. Công thức của vị từ phân đoạn P và những đặc trưng mà nó sử dụng đóng vai trò quan trọng trong kết quả phân đoạn. P thường là một vị từ của công thức P(R,x,t), trong đó x là vectơ đặc trưng gắn với một điểm ảnh và t là một tập hợp các tham số (thường là các ngưỡng). Các đặc trưng cấu trúc thường được chứa trong vectơ đặc trưng. Trong trường hợp đơn giản nhất, vectơ đặc trưng x chỉ có cường độ ảnh f(k,l) và vectơ ngưỡng chỉ gồm một ngưỡng T.", "order_start": 2147, "order_end": 3237, "word_count": 244}
{"parent_id": "b12f8c62-f66b-4cb1-b06c-7ce865c41a3a", "subject": "Xulyanh", "section": "5.1. GIỚI THIỆU", "title_path": "5.1. GIỚI THIỆU", "content": "[Xulyanh / 5.1. GIỚI THIỆU] ). Các đặc trưng cấu trúc thường được chứa trong vectơ đặc trưng. Trong trường hợp đơn giản nhất, vectơ đặc trưng x chỉ có cường độ ảnh f(k,l) và vectơ ngưỡng chỉ gồm một ngưỡng T. Một nguyên tắc phân đoạn đơn giản có công thức: P(R): f(k,l) < T Trong trường hợp các ảnh màu, vectơ đặc trưng x có thể là ba thành phần ảnh RGB [fR(k,l), fG(k,l), fB(k,l)]T. Một nguyên tắc phân đoạn ảnh đơn giản có thể có công thức: Trong nhiều ứng dụng, sự liên thông của vùng đóng vai trò quan trọng trong việc phân đoạn ảnh. Một vùng R được gọi là liên thông nếu bất kỳ hai điểm (xA,yA) và (xB,yB) thuộc vào R có thể được nối bởi một đường (xA,yA)... (xi-1,yi-1), (xi,yi), (xi+1,yi+1)... (xB,yB), mà các điểm (xi,yi) thuộc vào R và bất kỳ điểm (xi,yi) nào đều kề sát với điểm trước (xi-1,yi- 1) và điểm tiếp theo (xi+1,yi+1) trên đường đó. Một điểm (xk,yk) được gọi là kề với điểm (xl,yl) nếu (xl,yl) thuộc vào láng giềng trực tiếp của (xk,yk). Chúng ta có thể định nghĩa hai loại láng giềng.", "order_start": 3237, "order_end": 4214, "word_count": 194}
{"parent_id": "b12f8c62-f66b-4cb1-b06c-7ce865c41a3a", "subject": "Xulyanh", "section": "5.1. GIỚI THIỆU", "title_path": "5.1. GIỚI THIỆU", "content": "[Xulyanh / 5.1. GIỚI THIỆU] (xi+1,yi+1) trên đường đó. Một điểm (xk,yk) được gọi là kề với điểm (xl,yl) nếu (xl,yl) thuộc vào láng giềng trực tiếp của (xk,yk). Chúng ta có thể định nghĩa hai loại láng giềng. 4-láng giềng của một điểm (x,y) là một tập hợp bao gồm láng giềng dọc và láng giềng ngang của nó: 8-láng giềng của (x,y) là một tập cha của 4-láng giềng và bao gồm láng giềng ngang, dọc và chéo: Các đường được xác định bằng cách sử dụng 4-láng giềng gồm có các vệt dọc và ngang với x = y = 1. Những đường sử dụng 8-láng giềng có thêm các vệt chéo với khoảng cách 2 . Các kỹ thuật phân đoạn có thể chia thành ba lớp khác nhau. Các kỹ thuật cục bộ (Local techniques) dựa vào các thuộc tính cục bộ của các điểm và láng giềng của nó. Các kỹ thuật toàn thể (global) phân ảnh dựa trên thông tin chung của toàn bộ ảnh (ví dụ bằng cách sử dụng lược đồ xám của ảnh – image histogram). Các kỹ thuật tách (split), hợp (merge) và growing sử dụng cả khái niệm đồng nhất và gần về hình học. Hai vùng có thể được hợp lại nếu chúng giống nhau (nếu P(RiRj) = TRUE) và kề nhau.", "order_start": 4214, "order_end": 5256, "word_count": 220}
{"parent_id": "b12f8c62-f66b-4cb1-b06c-7ce865c41a3a", "subject": "Xulyanh", "section": "5.1. GIỚI THIỆU", "title_path": "5.1. GIỚI THIỆU", "content": "[Xulyanh / 5.1. GIỚI THIỆU] kỹ thuật tách (split), hợp (merge) và growing sử dụng cả khái niệm đồng nhất và gần về hình học. Hai vùng có thể được hợp lại nếu chúng giống nhau (nếu P(RiRj) = TRUE) và kề nhau. Một vùng không đồng nhất có thể bị chia thành những vùng nhỏ hơn. Một vùng có thể mở rộng bằng cách thêm các điểm sao cho nó vẫn đồng nhất, P(Ri) = TRUE. Các chương tiếp theo sẽ trình bày một số phương pháp phân đoạn ảnh cụ thể.", "order_start": 5256, "order_end": 5665, "word_count": 88}
{"parent_id": "55bae005-60d9-4ec5-ac27-8fa14c281802", "subject": "Xulyanh", "section": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ", "title_path": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ", "content": "[Xulyanh / 5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ] Trong hầu hết các trường hợp, ngưỡng được chọn từ lược đồ độ sáng của vùng hay ảnh cần phân đoạn. Có rất nhiều kỹ thuật chọn ngưỡng tự động xuất phát từ lược đồ xám {h[b] | b = 0, 1,..., B-1} đã được đưa ra, B là số mức xám của ảnh, với ảnh grayscale B=256. Những kỹ thuật phổ biến sẽ được trình bày dưới đây. Những kỹ thuật này có thể tận dụng những lợi thế do sự làm trơn dữ liệu lược đồ ban đầu mang lại nhằm loại bỏ những dao động nhỏ về độ sáng. Tuy nhiên các thuật toán làm trơn cần phải cẩn thận, không được làm dịch chuyển các vị trí đỉnh của lược đồ. Nhận xét này dẫn đến thuật toán làm trơn dưới đây: Trong đó,  W thường được chọn là số lẻ (3 hoặc 5).", "order_start": 0, "order_end": 662, "word_count": 149}
{"parent_id": "55bae005-60d9-4ec5-ac27-8fa14c281802", "subject": "Xulyanh", "section": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ", "title_path": "5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ", "content": "[Xulyanh / 5.2. PHÂN VÙNG ẢNH THEO NGƯỠNG BIÊN ĐỘ] ơn cần phải cẩn thận, không được làm dịch chuyển các vị trí đỉnh của lược đồ. Nhận xét này dẫn đến thuật toán làm trơn dưới đây: Trong đó,  W thường được chọn là số lẻ (3 hoặc 5).  hsmooth[b] là giá trị tần xuất của độ sáng b sau khi làm trơn  hraw[b] là giá trị tần xuất của độ sáng b gốc", "order_start": 662, "order_end": 954, "word_count": 68}
{"parent_id": "fef4194b-5351-4367-ba5d-8fe37f3dd8d6", "subject": "Xulyanh", "section": "5.2.1. Thuật toán đẳng liệu", "title_path": "5.2.1. Thuật toán đẳng liệu", "content": "[Xulyanh / 5.2.1. Thuật toán đẳng liệu] Đây là kỹ thuật chọn ngưỡng theo kiểu lặp do Ridler và Calvard đưa ra. Trước hết, lược đồ sẽ được phân đoạn thành hai phần bằng một giá trị ngưỡng khởi động với 0 = B/2 tức là bằng phân nửa thang độ xám động của ảnh. Sau đó, các trung bình mẫu (mf,0) của những điểm ảnh thuộc đối tượng và (mb,0) của những điểm ảnh nền sẽ được tính toán. Một giá trị ngưỡng mới 1 sẽ được tính kế đó bằng cách lấy giá trị trung bình của hai trung bình mẫu n i trê Quá trình này cứ ế sẽ được tiếp tục với ngưỡng mới cho đến khi nào giá trị ngưỡng không thay đổi nữa thì dừng lại. Nếu biểu diễn dưới dạng công thức toán học, chúng ta có: với mf,k+1 thì Bmin = 0 và Bmax = θk  mb,k+1 thì Bmin = θk và Bmax = B - 1 Thực hiện cho tới khi \u0000\u0000 = \u0000\u0000\u0000\u0000", "order_start": 0, "order_end": 727, "word_count": 167}
{"parent_id": "69dd5f83-bfdf-408d-943a-e5fb90231e56", "subject": "Xulyanh", "section": "5.2.2. Thuật toán đối xứng nền", "title_path": "5.2.2. Thuật toán đối xứng nền", "content": "[Xulyanh / 5.2.2. Thuật toán đối xứng nền] Kỹ thuật này dựa trên sự giả định là tồn tại hai đỉnh phân biệt trong lược đồ nằm đối xứng nhau qua đỉnh có giá trị lớn nhất trong phần lược đồ thuộc về các điểm ảnh nền. Kỹ thuật này có thể tận dụng ưu điểm của việc làm trơn được mô tả trong phương trình (5.9). Đỉnh cực đại maxp tìm được nhờ tiến hành tìm giá trị cực đại trong lược đồ. Sau đó thuật toán sẽ được áp dụng ở phía không phải là điểm ảnh thuộc đối tượng ứng với giá trị cực đại đó nhằm tìm ra giá trị độ sáng a ứng với giá trị phần trăm p% mà: P(a) = p%, trong đó P(a) là hàm phân phối xác suất về độ sáng.", "order_start": 0, "order_end": 571, "word_count": 132}
{"parent_id": "7e59d094-5511-4aae-aa35-e0cbebd879bd", "subject": "Xulyanh", "section": "Định nghĩa: [Hàm phân phối xác suất về độ sáng]", "title_path": "Định nghĩa: [Hàm phân phối xác suất về độ sáng]", "content": "[Xulyanh / Định nghĩa: [Hàm phân phối xác suất về độ sáng]] Hàm phân phối xác suất P(a) thể hiện xác suất chọn được một giá trị độ sáng từ một vùng ảnh cho trước, sao cho giá trị này không vượt quá một giá trị sáng cho trước a. Khi a biến thiên từ - đến +, P(a) sẽ nhận các giá trị từ 0 đến 1. P(a) là hàm đơn điệu không giảm theo a, do vậy \u0000\u0000 ≥ 0.", "order_start": 0, "order_end": 290, "word_count": 70}
{"parent_id": "a8b4b765-541a-4f0c-ab15-5a6b00032f1b", "subject": "Xulyanh", "section": "Hình 5.1 Minh hoạ thuật toán đối xứng nền", "title_path": "Hình 5.1 Minh hoạ thuật toán đối xứng nền", "content": "[Xulyanh / Hình 5.1 Minh hoạ thuật toán đối xứng nền] Ở đây ta đang giả thiết là ảnh có các đối tượng tối trên nền sáng. Giả sử độ chắc chắn P là 95%, thì có nghĩa là ta phải ở bên phải đỉnh maxp một giá trị a sao cho P(a)=95%. Do tính đối xứng đã giả định ở trên, chúng ta lấy đối xứng qua maxp để có được ngưỡng T: Kỹ thuật này thực hiện ngược lại với tình huống ảnh có các đối tượng sáng trên một nền tối.", "order_start": 0, "order_end": 354, "word_count": 83}
{"parent_id": "7a8e77eb-bac3-46c4-8474-c5b44419cc79", "subject": "Xulyanh", "section": "5.2.3. Thuật toán tam giác", "title_path": "5.2.3. Thuật toán tam giác", "content": "[Xulyanh / 5.2.3. Thuật toán tam giác] Thuật toán này do Zack đề xuất. Hình 5.2 minh hoạ thuật toán này. Các bước của thuật toán như sau: Nối đường thẳng  từ điểm Hmax của lược đồ (điểm có histogram lớn nhất, có mức xám bmax) đến điểm Hmin của lược đồ (điểm ứng với độ sáng nhỏ nhất bmin). Với mỗi độ sáng b trong khoảng [bmax, bmin], chúng ta đi tính khoảng cách d từ điểm Hb của lược đồ (ứng với giá trị độ sáng b) đến . Giá trị b0 ứng với khoảng cách d lớn nhất sẽ được chọn làm giá trị ngưỡng T. Kỹ thuật này đặc biệt hiệu quả khi các điểm ảnh thuộc đối tượng tạo nên một đỉnh yếu trong lược đồ ảnh.", "order_start": 0, "order_end": 566, "word_count": 126}
{"parent_id": "37f94094-a7e2-4893-9689-cae34c42ab95", "subject": "Xulyanh", "section": "5.2.4. Chọn ngưỡng đối với Bimodal Histogram", "title_path": "5.2.4. Chọn ngưỡng đối với Bimodal Histogram", "content": "[Xulyanh / 5.2.4. Chọn ngưỡng đối với Bimodal Histogram] Nếu ảnh chứa một đối tượng và một nền có cường độ đồng nhất, nó thường có một histogram hai mốt (bimodal histogram) như một trường hợp trình bày trong hình 5.3. Ngưỡng T được chọn ở tại vị trí cực tiểu địa phương của histogram nằm giữa hai đỉnh của histogram. Điểm cực đại địa phương của histogram có thể dễ dàng được phát hiện bằng cách sử dụng biến đổi chóp mũ (top hat) do Meyer đưa ra: Phụ thuộc vào tình huống chúng ta đang phải làm việc là với nhưng đối tượng sáng trên nền tối hay đối tượng tối trên nền sáng mà phép biến đổi top hat sẽ có một trong hai dạng sau: a) Các đối tượng sáng: b) Các đối tượng tối: Việc tính toán giá trị cực tiểu địa phương của histogram thì khó nếu histogram nhiễu. Do đó, trong trường hợp này nên làm trơn histogram, ví dụ sử dụng thuật toán (5.9). Trong một số ứng dụng nhất định, cường độ của đối tượng hay nền thay đổi khá chậm. Trong trường hợp này, histogram ảnh có thể không chứa hai thuỳ phân biệt rõ ràng, vì vậy có thể phải dùng ngưỡng thay đổi theo không gian.", "order_start": 0, "order_end": 1007, "word_count": 209}
{"parent_id": "37f94094-a7e2-4893-9689-cae34c42ab95", "subject": "Xulyanh", "section": "5.2.4. Chọn ngưỡng đối với Bimodal Histogram", "title_path": "5.2.4. Chọn ngưỡng đối với Bimodal Histogram", "content": "[Xulyanh / 5.2.4. Chọn ngưỡng đối với Bimodal Histogram] của đối tượng hay nền thay đổi khá chậm. Trong trường hợp này, histogram ảnh có thể không chứa hai thuỳ phân biệt rõ ràng, vì vậy có thể phải dùng ngưỡng thay đổi theo không gian. Hình ảnh được chia thành những khối hình vuông, histogram và ngưỡng được tính cho mỗi khối tương ứng. Nếu histogram cục bộ không phải là bimodal histogram thì ngưỡng được tính bằng cách nội suy ngưỡng của các khối láng giềng. Khi ngưỡng cục bộ đã có thì áp dụng thuật toán phân ngưỡng ở hình 5.3 cho khối này.", "order_start": 1007, "order_end": 1496, "word_count": 98}
{"parent_id": "ce53cf0c-bdbe-451e-9302-e08d2109e906", "subject": "Xulyanh", "section": "5.3.1. Giới thiệu", "title_path": "5.3.1. Giới thiệu", "content": "[Xulyanh / 5.3.1. Giới thiệu] Kỹ thuật phân đoạn ảnh thành các miền đồng nhất dựa vào các thuộc tính quan trọng nào đó của miền. Mỗi một thuộc tính khi sử dụng thì có một tiêu chuẩn phân đoạn tương ứng. Một số thuộc tính tiêu biểu là: mức xám, màu sắc (đối với ảnh màu), kết cấu sợi... Ta có thể dùng logic vị từ để làm tiêu chuẩn đánh giá phân đoạn. Giả sử ảnh X phải phân thành n vùng khác nhau: Z1, Z2,..., Zn và lôgic vị từ có dạng P(Z). Việc phân vùng phải thoả mãn các tính chất sau: Kết quả của việc phân đoạn ảnh phụ thuộc vào dạng của vị từ P và các đặc tính biểu diễn bởi vectơ đặc tính. hường vị từ P có dạng P(Z, X, t), với X là véc tơ đặc tính, t là ngưỡng. Trường hợp đơn giản nhất, véc tơ đặc tính chỉ chứa giá trị mức xám của ảnh I(k, t) và ngưỡng chỉ đơn thuần là giá trị T. P(Z): I (k, I) <T. Với ảnh màu, véc tơ đặc tính X có thể là thành phần ba màu R, G, B và IR(k,l), IG(k,l), IB(k, l) là các thành phần tương ứng.", "order_start": 0, "order_end": 906, "word_count": 207}
{"parent_id": "ce53cf0c-bdbe-451e-9302-e08d2109e906", "subject": "Xulyanh", "section": "5.3.1. Giới thiệu", "title_path": "5.3.1. Giới thiệu", "content": "[Xulyanh / 5.3.1. Giới thiệu] ngưỡng chỉ đơn thuần là giá trị T. P(Z): I (k, I) <T. Với ảnh màu, véc tơ đặc tính X có thể là thành phần ba màu R, G, B và IR(k,l), IG(k,l), IB(k, l) là các thành phần tương ứng. Lúc đó luật phân ngưỡng có dạng: Có ba cách tiếp cận chủ yếu trong phân vùng ảnh theo miền đồng nhất và độc lập với tiêu chuẩn lựa chọn tính đồng nhất: Phương pháp phân tách – cây tứ phân (split – quad trees)  Phương pháp hợp (merge). Phương pháp tách - hợp (split – merge). Mức độ hiệu quả của các phương pháp là phụ thuộc vào việc lựa chọn tiêu chuẩn đánh giá độ thuần nhất. Trên thực tế người ta hay sử dụng trung bình số học, và độ lệch chuẩn i cho vùng Zi có n điểm: Hai vùng Zi và Zj có thể hợp nhất nếu | mi-mj | < ki. Hoặc có thể dựa vào mức xám để xét tiêu chuẩn miền đồng nhất. Giả sử max và min là giá trị mức xám lớn nhất và nhỏ nhất trong miền đang xét.", "order_start": 906, "order_end": 1755, "word_count": 193}
{"parent_id": "ce53cf0c-bdbe-451e-9302-e08d2109e906", "subject": "Xulyanh", "section": "5.3.1. Giới thiệu", "title_path": "5.3.1. Giới thiệu", "content": "[Xulyanh / 5.3.1. Giới thiệu] Zj có thể hợp nhất nếu | mi-mj | < ki. Hoặc có thể dựa vào mức xám để xét tiêu chuẩn miền đồng nhất. Giả sử max và min là giá trị mức xám lớn nhất và nhỏ nhất trong miền đang xét. Khi đó, tiêu chuẩn để miền đang xét là đồng nhất có thể là: | max-min | <θ với θ là một ngưỡng hoặc tiêu chuẩn là độ lệch bình phương trung bình nhỏ hơn θ \u0000̅ là giá trị trung bình trong vùng ảnh đang", "order_start": 1755, "order_end": 2135, "word_count": 90}
{"parent_id": "b6be792f-8d59-4727-8bf2-a5d3d56c272b", "subject": "Xulyanh", "section": "5.3.2. Phương pháp tách cây tứ phân (quad tree)", "title_path": "5.3.2. Phương pháp tách cây tứ phân (quad tree)", "content": "[Xulyanh / 5.3.2. Phương pháp tách cây tứ phân (quad tree)] Về nguyên tắc phương pháp này kiểm tra tính hợp thức của tiêu chuẩn đồng nhất một cách tổng thể trên miền lớn. Nếu tiê chuẩn được thoả việc phân đoạn coi như kết thúc. Trong trường hợp ngược l chia miề đang xét thành 4 miền nhỏ hơn, ta lại áp dụng đệ quy bằng phương pháp trên ch o mỗi miền nhỏ hơn cho đến khi tất cả các miền đều thoả mãn. Phương pháp này có mô tả bằng thuật toán sau: Procedure PhanDoan( e Mi n) Begin If miền đang xét không thoả Then Begin Chia miền đang xét thành 4 miền: Z1, Z2, Z3, Z4 For i=1 to 4 Do PhanDoan(Zi) End Else Exit End; Nếu miền đang xét không thoả mãn tiêu chuẩn thì không phải là miền đồng nhất và sẽ được chia thành 4 phần.", "order_start": 0, "order_end": 662, "word_count": 143}
{"parent_id": "1850deb0-df3e-4387-bca1-20d30a57b88a", "subject": "Xulyanh", "section": "Thuật toán kiểm tra tiêu chuẩn theo (5.19) có thể được viết:", "title_path": "Thuật toán kiểm tra tiêu chuẩn theo (5.19) có thể được viết:", "content": "[Xulyanh / Thuật toán kiểm tra tiêu chuẩn theo (5.19) có thể được viết:] Fuction Examin_Criteria(I,N1,M1,N2, M2, T) /* Giả sử là ảnh có tối đa 255 mức xám. (N1,M1), (N2, M2) là toạ độ điểm đầu và điểm cuối của miền, T là ngưỡng. */ Begin 1. Max = 0; Min = 255; 2. For i = N1 to N2 do For j = N1 to N2 do If I(i,j) < Min Then Min = I(i,j); If I(i,j) >Max Then Max = I(i,j); 3. If ABS(max - min) < T Then Examin_Criteria = 0 Else Examin_Criteria = 1; End", "order_start": 0, "order_end": 379, "word_count": 86}
{"parent_id": "3ab498ab-243c-46f5-a21a-693c1c8ad0f5", "subject": "Xulyanh", "section": "Thuật toán kiểm tra tiêu chuẩn theo (5.20) được viết:", "title_path": "Thuật toán kiểm tra tiêu chuẩn theo (5.20) được viết:", "content": "[Xulyanh / Thuật toán kiểm tra tiêu chuẩn theo (5.20) được viết:] Fuction Examin_Criteria(I,N1,M1,N2, M2, T) /* Giả sử là ảnh có tối đa 255 mức xám. (N1,M1),(N2, M2) là toạ độ điểm đầu điểm cuối của miền, T là ngưỡng.*/ Begin 1. xtb = 0; e=0; n = (N2-N1)*(M2-M1) 2. For i = N1 to N2 do For j = N1 to do xtb = xtb + ,j)/n 3. For i = N1 t do 4. If e < T Then Examin_Criteria = 0 Else Examin_Criteria = 1; End Nếu hàm trả về giá trị 0, có nghĩa vùng đang xét là đồng nhất, trường hợp ngược lại nghĩa là mức không đồng nhất. Trong giải thuật trên, khi miền là đồng nhất cần tính lại giá trị trung bình và cập nhật lại ảnh đầu ra. Giá trị trung bình được tính bởi: Tổng giá trị mức xám/ tổng số điểm. Thuật toán này tạo nên một cây mà mỗi nút cha có 4 nút con ở mọi mức, trừ mức ngoài cùng. Vì thế cây này có tên là cây tứ phân. Một vùng thoả tiêu chuẩn tạo nên một nút lá, nếu không sẽ tạo nên một nút trong và 4 nút con tương ứng của việc chia làm 4 vùng. Mỗi nút lá của cây biểu diễn một vùng đã phân chia theo tiêu chuẩn. Hình 5.", "order_start": 0, "order_end": 962, "word_count": 220}
{"parent_id": "3ab498ab-243c-46f5-a21a-693c1c8ad0f5", "subject": "Xulyanh", "section": "Thuật toán kiểm tra tiêu chuẩn theo (5.20) được viết:", "title_path": "Thuật toán kiểm tra tiêu chuẩn theo (5.20) được viết:", "content": "[Xulyanh / Thuật toán kiểm tra tiêu chuẩn theo (5.20) được viết:] tạo nên một nút lá, nếu không sẽ tạo nên một nút trong và 4 nút con tương ứng của việc chia làm 4 vùng. Mỗi nút lá của cây biểu diễn một vùng đã phân chia theo tiêu chuẩn. Hình 5.4 a-e minh họa thuật toán tách cây tứ phân: ảnh gốc (a) được chia thành 4 phần được kết quả phân mức 1 (b), tiếp tục thực hiện đối với các phần nhỏ, ta được phân mức 2, 3. Tiêu chuẩn phân vùng ở đây là màu sắc. Nếu mọi điểm của vùng là màu trắng sẽ tạo nên một nút lá trắng và tương tự như vậy với nút lá đen. Nút màu ghi có nghĩa là vùng không thuần nhất và phải tiếp tục chia.", "order_start": 962, "order_end": 1519, "word_count": 129}
{"parent_id": "2b3544e9-49f4-42ca-85d8-a703a79900e8", "subject": "Xulyanh", "section": "5.3.3. Các phương pháp phân vùng bởi hợp", "title_path": "5.3.3. Các phương pháp phân vùng bởi hợp", "content": "[Xulyanh / 5.3.3. Các phương pháp phân vùng bởi hợp] Ý tưởng của phương pháp này là xem xét ảnh từ các miền nhỏ nhất rồi hợp chúng lại nếu thoả mãn tiêu chuẩn để được một miền đồng nhất lớn hơn. Ta lại tiếp tục với miền thu được cho đến khi không thể hợp được nữa. Số miền còn lại cho ta kết quả phân đoạn ảnh. Miền nhỏ nhất của bước xuất phát là điểm ảnh. Việc hợp 2 vùng được thực hiện theo nguyên tắc sau:  Hai vùng phải đáp ứng tiêu chuẩn, như cùng màu hay cùng mức xám.  Chúng phải kế cận nhau Trong xử lý ảnh người ta dùng khái niệm liên thông để xác định kế cận. Với 4 liên thông một điểm ảnh I (x,y) sẽ có 4 kế cận theo hướng x, y. Trong khi đó với 8 liên thông, điểm ảnh I(x, y) sẽ có 4 liên thông theo hai hướng x và y và 4 liên thông khác theo hướng chéo 45˚. Giả sử chúng ta sử dụng độ lệch tiêu chuẩn làm tiêu chí đánh giá tính đồng nhất. Lớp Ri có n điểm có giá trị trung bình mi và độ lệch tiêu chuẩn Hai vùng R1 và R2 có thể hợp nếu | m1 - m2 | < T và điểm I(k, l) hợp với vùng Ri nếu nếu| I(k,l) - mi | < T, với T là một ngưỡng. Đầu tiên chúng ta cố gắng hợp điểm (k, l) với một trong các vùng lân cận Ri.", "order_start": 0, "order_end": 1071, "word_count": 255}
{"parent_id": "2b3544e9-49f4-42ca-85d8-a703a79900e8", "subject": "Xulyanh", "section": "5.3.3. Các phương pháp phân vùng bởi hợp", "title_path": "5.3.3. Các phương pháp phân vùng bởi hợp", "content": "[Xulyanh / 5.3.3. Các phương pháp phân vùng bởi hợp] ợp nếu | m1 - m2 | < T và điểm I(k, l) hợp với vùng Ri nếu nếu| I(k,l) - mi | < T, với T là một ngưỡng. Đầu tiên chúng ta cố gắng hợp điểm (k, l) với một trong các vùng lân cận Ri. Nếu việc hợp không thành công thì ta hợp với các vùng khác đã có. Nếu vẫn không thành công hoặc không có vùng lân cận tồn tại thì điểm này được coi là một vùng mới. Nếu hợp R  (k, l) là thành công, cập nhật lại giá trị trung bình và độ lệch tiêu chuẩn: Nếu có nhiều hơn một vùng lân cận thoả mãn thì hợp điểm với vùng Ri có sự khác biệt | I(k,l) - mi | nhỏ nhất.", "order_start": 1071, "order_end": 1615, "word_count": 133}
{"parent_id": "cee75d27-75a6-42b0-b6bf-c026a7776eb4", "subject": "Xulyanh", "section": "5.3.4. Phương pháp tách hợp (split-merge)", "title_path": "5.3.4. Phương pháp tách hợp (split-merge)", "content": "[Xulyanh / 5.3.4. Phương pháp tách hợp (split-merge)] Hai phương pháp vừa xét ở trên có một số nhược điểm. Phương pháp tách tạo nên một cấu trúc phân cấp và thiết lập mối quan hệ giữa các vùng. Tuy nhiên nó thực hiện việc chia quá chi tiết. Phương pháp hợp cho phép làm giảm số miền liên thông xuống tối thiểu nhưng cấu trúc hàng ngang dàn trải, không cho ta thấy mối liên hệ giữa các vùng. Chính vì nhược điểm này mà ta nghĩ đến phương pháp phối hợp cả 2 phương pháp. Trước tiên dùng phương pháp tách để tạo nên cây tứ phân, phân đoạn theo hướng từ gốc đến lá. Tiếp theo tiến hành duyệt cây theo chiều ngược lại và hợp các vùng có cùng tiêu chuẩn. Với phương pháp này ta thu được miêu tả cấu trúc của ảnh với các miền liên thông có kích thước tối đa.", "order_start": 0, "order_end": 697, "word_count": 150}
{"parent_id": "d0cdc078-0798-4747-bcac-65b479304254", "subject": "Xulyanh", "section": "Giải thuật trên gồm một số bước sau:", "title_path": "Giải thuật trên gồm một số bước sau:", "content": "[Xulyanh / Giải thuật trên gồm một số bước sau:] 1. Kiểm tra tiêu chuẩn đồng nhất i. Nếu không thoả và số điểm trong vùng lớn hơn một điểm, tách làm 4 vùng (trên, dưới, trái, phải) bằng cách gọi đệ quy. Nếu kết quả tách xong và không tách được nữa chuyển sang bước ii. ii. Nếu tiêu chuẩn đồng nhất là thoả thì tiến hành hợp vùng và cập nhật giá trị trung bình cho vùng. 2. Hợp vùng Cần kiểm tra 4 lân cận đã nêu trên. Có thể có nhiều vùng thoả mãn khi đó ta chọn vùng tối ưu rồi tiến hành hợp. Phương pháp này thu được kết quả số vùng là nhỏ hơn phương pháp tách và ảnh được làm trơn hơn.", "order_start": 0, "order_end": 539, "word_count": 120}
{"parent_id": "584b3991-57d1-4a49-81fe-f3736489db9d", "subject": "Xulyanh", "section": "5.4. PHÂN VÙNG DỰA THEO ĐƯỜNG BIÊN", "title_path": "5.4. PHÂN VÙNG DỰA THEO ĐƯỜNG BIÊN", "content": "[Xulyanh / 5.4. PHÂN VÙNG DỰA THEO ĐƯỜNG BIÊN] Việc phân đoạn ảnh dựa vào biên được tiến hành qua một số bước:  Phát hiện biên và làm nổi biên  Làm mảnh biên  Nhị phân hoá đường biên  Miêu tả đường biên", "order_start": 0, "order_end": 159, "word_count": 37}
{"parent_id": "a88aeda5-d6e9-4b1c-a75c-36f633197fec", "subject": "Xulyanh", "section": "5.4.1. Phát hiện biên", "title_path": "5.4.1. Phát hiện biên", "content": "[Xulyanh / 5.4.1. Phát hiện biên] Về mặt toán học, người ta coi điểm biên của ảnh là điểm có sự biến đổi đột ngột về độ xám, như trong hình 5.5 sau đây: Có nhiều định nghĩa về đường biên, điển hình có ba loại đường biên chính:  Đường biên lý tưởng (Hình 5.5 a) được định nghĩa là sự thay đổi giá trị cấp xám tại một vị trí xác định. Vị trí của đường biên chính là vị trí thay đổi cấp xám.  Đường biên bặc thang (Hình 5.5 b) xuất hiện khi sự thay đổi cấp xám trải rộng qua nhiều điểm ảnh. Vị trí của đường biên được xem như vị trí chính giữa của đường nối giữa cấp xám thấp và cấp xám cao. Đường biên thực (Hình 5.5 c): Đó là sự thay đổi cấp xám tại nhiều điểm nhưng không trơn. Định nghĩa toán học của biên ở trên là cơ sở cho các kỹ thuật phát hiện biên. Điểm quan trọng là biến thiên giữa các điểm ảnh thường là nhỏ, trong khi đó biến thiên độ sáng của điểm biên (khi qua biên) lại khá lớn.", "order_start": 0, "order_end": 860, "word_count": 192}
{"parent_id": "e985ea43-f4da-4944-a6c4-1634eba35148", "subject": "Xulyanh", "section": "5.4.2. Làm mảnh biên", "title_path": "5.4.2. Làm mảnh biên", "content": "[Xulyanh / 5.4.2. Làm mảnh biên] Làm mảnh biên là việc làm nổi biên với độ rộng chỉ 1 pixel. Trong phần trên, ta thấy, kỹ thuật Laplace dùng trong việc phát hiện biên cho kết quả trực tiếp biên ảnh với độ rộng 1 pixel. Còn với các kỹ thuật khác, ví dụ như kỹ thuật Gradient thì không như vậy, ta phải có bước làm mảnh biên để thu được biên với độ rộng 1 pixel. Khi thực hiện đạo hàm một ảnh, ta thu được những điểm cực trị cục bộ. Theo kỹ thuật Gradient, những điểm cực trị cục bộ có thể coi n ư biên. Do vậy cần tách biệt những điểm cực trị đó để xác định chính xác biên ảnh và để giảm độ rộng biên ảnh. Một trong những phương pháp hay dùng đó là phương pháp “Loại bỏ các điểm không cực đại”.", "order_start": 0, "order_end": 660, "word_count": 146}
{"parent_id": "93e8d078-3dbd-4395-a760-2d34e894532e", "subject": "Xulyanh", "section": "5.4.3. Nhị phân hóa đường biên", "title_path": "5.4.3. Nhị phân hóa đường biên", "content": "[Xulyanh / 5.4.3. Nhị phân hóa đường biên] Nhị phân hóa đường biên là giai đoạn then chốt trong quá trình trích chọn vì nó xác định đường bao nào thực sự cần và đường bao nào có thể loại bỏ. Nói chung, người ta thường nhị phân hóa đường biên theo cách thức làm giảm nhiễu hoặc tránh hiện tượng kéo sợi trên ảnh. Điều này cũng giải thích tại sao phân đoạn dựa theo biên có hiệu quả khi ảnh có độ tương phản tốt. Trong trường hợp ngược lại, có thể sẽ bị mất một phần đường bao hay đường bao có chân, không khép kín, v.v.., do đó sẽ bất lợi cho biểu diễn sau này. Một phương pháp hay được dùng là chọn ngưỡng thích nghi. Với cách chọn này, ngưỡng sẽ phụ thuộc vào hướng của gradient nhằm làm giảm sự xoắn của biên. Đầu tiên, người ta định ra một ngưỡng nào đó và sau đó sử dụng một hệ số sinh thích nghi thông qua lời giải toán tử đạo hàm theo hướng tìm được để tinh chỉnh.", "order_start": 0, "order_end": 827, "word_count": 178}
{"parent_id": "3ae3c621-ce5e-47cc-b3c8-25747222a3f4", "subject": "Xulyanh", "section": "5.4.4. Miêu tả đường biên", "title_path": "5.4.4. Miêu tả đường biên", "content": "[Xulyanh / 5.4.4. Miêu tả đường biên] Khi đã có bản đồ biên ảnh, ta cần phải biểu diễn nó dưới dạng thích hợp phục vụ cho việc phân tích và làm giảm lượng thông tin dùng để miêu tả, lưu trữ đối tượng. Người ta thường thực hiện theo nguyên tắc: tách riêng từng biên và gán cho mỗi biên một mã. Có nhiều phương pháp miêu tả đường biên khác nhau, mỗi phương pháp thích hợp với một loại ứng dụng. Việc tách các đường bao có thể phải bổ xung thêm các điều kiện nhằm loại bỏ các đường bao không khép kín, hoặc bỏ đi các chân rết bám theo các đường bao kín. Có nhiều cách mã hóa đường bao, có thể biểu diễn chính xác đường bao hay xấp xỉ nhờ nội suy. Một số cấu trúc cơ sở mã hóa đường bao thường dùng là: điểm, đoạn thẳng, cung, đường cong. Có một số phương pháp mã hóa đường bao hay dùng như: mã hóa theo tọa độ Đề các, mã hóa Freeman, xấp xỉ bởi đoạn thẳng, xấp xỉ đa thức.", "order_start": 0, "order_end": 831, "word_count": 182}
{"parent_id": "f17b7539-aa51-4346-9907-02d512d5ea51", "subject": "Xulyanh", "section": "5.5. PHÂN VÙNG THEO KẾT CẤU BỀ MẶT", "title_path": "5.5. PHÂN VÙNG THEO KẾT CẤU BỀ MẶT", "content": "[Xulyanh / 5.5. PHÂN VÙNG THEO KẾT CẤU BỀ MẶT] Kết cấu thường được nhận biết trên bề mặt của các đối tượng như gỗ, cát, vải vóc…Kết cấu là thuật ngữ phản ánh sự lặp lại của các phần tử sợi (texel) cơ bản. Sự lặp lại này có thể ngẫu nhiên hay có tính chu kì hoặc gần chu kì. Một texel chứa rất nhiều điểm ảnh. Trong phân tích ảnh, kết cấu được chia làm hai loại chính là: loại thống kê và loại cấu trúc.", "order_start": 0, "order_end": 355, "word_count": 79}
{"parent_id": "c15e199a-6989-49b0-8ac7-f850ee06e5d1", "subject": "Xulyanh", "section": "5.4.1. Phương pháp thống kê", "title_path": "5.4.1. Phương pháp thống kê", "content": "[Xulyanh / 5.4.1. Phương pháp thống kê] Tính kết cấu ngẫu nhiên rất phù hợp với các đặc trưng thống kê. Vì vậy, người ta có thể dùng các đặc trưng ngẫu nhiên để đo nó như: Hàm tự tương quan (AutoCorrelation Function- ACF), các biến đổi mật độ gờ, ma trận tương tranh,… Theo cách tiếp cận bằng hàm tự tương quan, độ thô của kết cấu sợi tỉ lệ với độ rộng của ACF, được biểu diễn bởi khoảng cách x0, yo sao cho r(x0,0) = r(0, y0) = 1. Người ta cũng dùng cách đo nhánh của ACF nhờ hàm khởi nh moment: Các đặc trưng của kế cấu sợi như đ ộ thô, độ mịn hay hướng có thể ước lượng nhờ các biến đổi ảnh bằng kỹ thuậ lọc tuyến tính. Một mô hình đơn giản trong trường hợp ngẫu nhiên cho việc phân tính kết cấu đựoc mô tả trong hình dưới đây:", "order_start": 0, "order_end": 690, "word_count": 152}
{"parent_id": "452008a1-367a-4b02-9ac3-33bf437cd1f8", "subject": "Xulyanh", "section": "Hình 5.6. Phân tích kết cấu sợi bằng dải tương quan", "title_path": "Hình 5.6. Phân tích kết cấu sợi bằng dải tương quan", "content": "[Xulyanh / Hình 5.6. Phân tích kết cấu sợi bằng dải tương quan] Trong mô hình này, trường kết cấu sợi trước tiên được giải chập bởi bộ lọc lấy từ đầu ra của ACF. Như vậy, nếu r(m,n) là ACF thì: là trường ngẫu nhiên không tương quan. Lưu ý rằng, bộ lọc là không duy nhất, có thể là nhân quả, bán nhân quả hay không nhân quả. Các ACF hay dùng như M(0,2), M(2,0), M(1,1), M(2,2). Các đặc trưng của lược đồ bậc một của ε (m,n) chẳng hạn như trung bình m1, độ phân tán 2 μ cũng hay được sử dụng. Ngoài các đặc trưng trên, có thể đưa thêm một số khái niệm và định nghĩa các đại lượng dựa trên đó như: lược đồ mức xám (Histogram Grey Level Difference), ma trận xuất hiện mức xám (Grey Level Occurrence Matrices).", "order_start": 0, "order_end": 641, "word_count": 134}
{"parent_id": "773c1d52-cf5f-4432-9ba0-ec7096f56483", "subject": "Xulyanh", "section": "Lược đồ hiệu mức xám:", "title_path": "Lược đồ hiệu mức xám:", "content": "[Xulyanh / Lược đồ hiệu mức xám:] Lược đồ hiệu mức xám dùng để mô tả các thông tin mang tính không gian và được định nghĩa như sau. Cho d=(d1, d2) là vecto dịch chuyển giữa 2 điểm ảnh và g(d) là hiệu mức xám với khoảng cách d: với hàm f(k, l) cho giá trị mức xám tại tọa độ (k, l). Gọi hg(g, d) là lược đồ của hiệu mức xám khoảng cách d. Với mỗi khoảng cách d ta có một lược đồ mức xám riêng. Với một miền ảnh có kết cấu thô, lược đồ hg(g, d) có khuynh hướng tập trung xung quanh g=0 với khoảng cách d nhỏ. Trái lại, với một miền ảnh có kết cấu mịn, hg(g, d) sẽ phân nhánh dù với vecto dịch chuyển d khá nhỏ. Dựa trên lược đồ này, người ta định nghĩa lại một số đại lượng:  Trung bình:  Phương sai: c .)  Độ tương phản: Phương sai đo độ tản mát của hiệu mức xám tại một khoảng cách d nào đấy. Kết cấu tất định thường có phươ g sai d σ tương đối nhỏ. Độ tương phản cd chính là mômen của lược đồ hg(g,d) xung quanh g=0 và đo độ tương phản của hiệu mức xám. Người ta sử dụng entropy để đo độ đồng nhất của lược đồ hg: Ưu điểm cơ bản của lược đồ hiệu mức xám là tính toán đơn giản.", "order_start": 0, "order_end": 1046, "word_count": 240}
{"parent_id": "773c1d52-cf5f-4432-9ba0-ec7096f56483", "subject": "Xulyanh", "section": "Lược đồ hiệu mức xám:", "title_path": "Lược đồ hiệu mức xám:", "content": "[Xulyanh / Lược đồ hiệu mức xám:] g,d) xung quanh g=0 và đo độ tương phản của hiệu mức xám. Người ta sử dụng entropy để đo độ đồng nhất của lược đồ hg: Ưu điểm cơ bản của lược đồ hiệu mức xám là tính toán đơn giản. Ngoài ra còn có khả năng cho ta tổ chức kết cấu không gian.", "order_start": 1046, "order_end": 1286, "word_count": 56}
{"parent_id": "094c25bc-0bea-43c0-961f-3074407292fc", "subject": "Xulyanh", "section": "Ma trận xuất hiện liên hiệp mức xám", "title_path": "Ma trận xuất hiện liên hiệp mức xám", "content": "[Xulyanh / Ma trận xuất hiện liên hiệp mức xám] Giả sử P(k,l,d) là xác suất liên hiệp của hai điểm ảnh fk và f1 với các mức xám k,l tương ứng cách nhau một khoảng d. Xác suất này dễ dàng tính được nhờ việc tính số lần xuất hiện nk,l của cặp điểm ảnh (fk, f1) có mức xám k và l với khoảng cách d. Gọi n là tổng số cặp liên hiệp có thể với khoảng cách d trong ảnh. Các phần tử ck,l của ma trận xuất hiện liên hiệp mức xám cd được tính như sau: cd = (ck,l) Ma trận xuất hiện liên hiệp mức xám Cd là ma trận vuông NN phần tử (N là số mức xám của ảnh). Ma trận này chứa các thông tin hữu ích về tổ chức kết cấu không gian. Nếu kết cấu tương đối thô thì các phần tử của ma trận tập trung xung quanh đường chéo chính. Ngược lại, nếu kết cấu bề mặt mịn, giá trị các phần tử của cd sẽ phân rải tương đối rõ. Dựa trên khái niệm này người ta định nghĩa về một số độ đo:  Xác suất cực đại:  Entropy: Dễ dàng thấy được entropy cực đại khi xác suất liên hiệp P(k,l,d) có phân phối đều. Mô men bậc m: Id cực tiểu khi các phân tử của ma trận C tập trung trên đường chéo chính vì khoảng cách |k-l|m rất nhỏ, Id nhỏ có nghĩa là kết cấu khá thô.", "order_start": 0, "order_end": 1081, "word_count": 249}
{"parent_id": "094c25bc-0bea-43c0-961f-3074407292fc", "subject": "Xulyanh", "section": "Ma trận xuất hiện liên hiệp mức xám", "title_path": "Ma trận xuất hiện liên hiệp mức xám", "content": "[Xulyanh / Ma trận xuất hiện liên hiệp mức xám] (k,l,d) có phân phối đều. Mô men bậc m: Id cực tiểu khi các phân tử của ma trận C tập trung trên đường chéo chính vì khoảng cách |k-l|m rất nhỏ, Id nhỏ có nghĩa là kết cấu khá thô. Người ta cũng còn đưa vào một số độ đo khác như hàm tự tương quan, phổ năng lượng. Để áp dụng cách tiếp cận này, cần cài đặt các giải thuật tính các đại lượng đo trên.", "order_start": 1081, "order_end": 1429, "word_count": 79}
{"parent_id": "37c36010-2e7f-4672-b97b-da5bb725ade8", "subject": "Xulyanh", "section": "5.4.2. Phương pháp cấu trúc", "title_path": "5.4.2. Phương pháp cấu trúc", "content": "[Xulyanh / 5.4.2. Phương pháp cấu trúc] Kết cấu sợi có cấu trúc thuần nhất là những texels xác định, mà sự xuất hiện lặp đi lặp lại tuân theo một luật tất định hay ngẫu nhiên nào đấy. Một texel về thực tế là một nhóm các điểm ảnh có cùng một số tính chất bất biến lặp trên ảnh. Một texel cũng có định nghĩa theo mức xám, theo bề mặt hay tính đồng nhất đối với một số các tính chất như kích thước, hướng, lược đồ bậc hai (ma trận tương tranh). Với các texel được phân bố ngẫu nhiên, tính kết cấu sợi tương ứng của nó được coi là yếu (Weak) ngược với luật phân bố tất định gọi là khỏe (Strong). Khi tính kết cấu sợi là yếu, luật phân bố có thể đo bởi:  Mật độ gờ  Các loạt dài của các xel liên thông tối đa  Mật độ cực trị tương đối; số pixel trên một đơn vị diện tích có mức xám cực trị địa phương so với các lân cận. Ngoài hai cách tiếp cận trên, người ta còn dùng cách tiếp cận khác bằng cách lấy tổ hợp 2 cách trên và gọi là kỹ thuật mosaic. Mô hình này biểu diễn các quá trình học ngẫu nhiên, ví dụ như khảm ngẫu nhiên hay đều của một mặt phẳng vào các đường cong lồi sẽ làm nổi lên tính kết cấu tế bào.", "order_start": 0, "order_end": 1069, "word_count": 242}
{"parent_id": "0f9d1079-e482-434b-9731-a1efebf1b224", "subject": "Xulyanh", "section": "5.4.3. Tiếp cận theo tính kết cấu", "title_path": "5.4.3. Tiếp cận theo tính kết cấu", "content": "[Xulyanh / 5.4.3. Tiếp cận theo tính kết cấu] Khi đối tượng xuất hiện trên một nền có tính kết cấu cao, việc phân đoạn dựa vào tính kết cấu trở nên quan trọng. Nguyên nhân là kết cấu sợi thường chứa mật độ cao các gờ (edge) làm cho phân đoạn theo biên kém hiệu quả, trừ phi ta loại tính kết cấu. Việc phân đoạn dựa vào miền đồng nhất cũng có thể áp dụng cho các đặc trưng kết cấu và có thể dùng để phân đoạn các miền có tính kết cấu. Nhìn chung, việc phân loại và phân vùng dựa vào kết cấu là một vấn đề phức tạp. Ở đây, tài liệu chỉ mang tính chất giới thiệu. Có thể giải quyết vấn đề này trong thực tế nếu ta biết trước các loại kết cấu (dựa vào quy luật hay các phân bố của nó).", "order_start": 0, "order_end": 635, "word_count": 143}
{"parent_id": "0a6ee9a9-3ac8-48c3-9f2e-439f2b28bca2", "subject": "Xulyanh", "section": "5.6. CÂU HỎI ÔN TẬP CHƯƠNG", "title_path": "5.6. CÂU HỎI ÔN TẬP CHƯƠNG", "content": "[Xulyanh / 5.6. CÂU HỎI ÔN TẬP CHƯƠNG] Câu 1: Thuật toán đối xứng nền là thuật toán gì? Thuật toán đối xứng nền cho kết quả tốt nhất khi nào? Câu 2: Thực hiện tìm ngưỡng phân vùng với thuật toán đối xứng nền với biều đồ tần suất sau. Được biết độ chính xác cần tính là 88%. Câu 3: Thực hiện tìm ngưỡng tự động với thuật toán đẳng liệu cho bức ảnh I có biểu đồ tần suất sau: Mô tả từng bước cho đến khi tìm được ngưỡng mong muốn. Được biết ảnh có 10 mức xám.", "order_start": 0, "order_end": 418, "word_count": 94}
{"parent_id": "cec7af76-03cb-4ce5-8bb8-398e71ddf758", "subject": "Xulyanh", "section": "6.1. GIỚI THIỆU", "title_path": "6.1. GIỚI THIỆU", "content": "[Xulyanh / 6.1. GIỚI THIỆU] Nhận dạng là quá trình phân loại các đối tượng biểu diễn theo một mô hình nào đó và gán chúng vào một lớp (gán cho đối tượng một tên gọi) dựa theo những guy luật và các mẫu chuẩn. Quá trình nhận dạng dựa vào những mẫu học biết trước gọi là nhận dạng có thầy hay Học có giám sát; trong trường hợp ngược lại gọi là Học không giám sát. Quá trình nhận dạng gồm 3 giai đoạn chính:  Lựa chọn mô hình biểu diễn đối tượng.  Lựa chọn luật ra quyết định (phương pháp nhận dạng) và suy diễn quá trình học.  Học nhận dạng. Khi mô hình biểu diễn đối tượng đã được xác định, có thể là định lượng (mô hình tham số) hay định tính (mô hình cấu trúc), quá trình nhận dạng chuyển sang giai đoạn học. Học là giai đoạn rất quan trọng. Thao tác học nhằm cải thiện, điều chỉnh việc phân hoạch tập đối tượng thành các lớp. Việc nhận dạng chính là tìm ra quy luật và các thuật toán để có thể gán đối tượng vào một lớp hay nói một cách khác gán cho đối tượng một tên.", "order_start": 0, "order_end": 944, "word_count": 205}
{"parent_id": "5e0e00c4-cbf5-40c5-8bde-431549d77007", "subject": "Xulyanh", "section": "Học có giám sát (supervised learning", "title_path": "Học có giám sát (supervised learning", "content": "[Xulyanh / Học có giám sát (supervised learning] Kỹ thuật phân loại nh kiến thức biết trước gọi là Học có giám sát. Đặc điểm cơ bản của kỹ thuật này là người ta có một thư viện các mẫu chuẩn. Mẫu cần nhận dạng sẽ được đem sánh với mẫu chuẩn để xem nó thuộc loại nào. Ví dụ như trong một ảnh viễn thám, người ta muốn phân biệt một cánh đồng lúa, một cánh rừng hay một vùng đất hoang mà đã có các miêu tả về các đối tượng đó. Vấn đề chủ yếu là thiết kế một hệ thống để có thể đối sánh đối tượng trong ảnh với mẫu chuẩn và quyết định gán cho chúng vào một lớp. Việc đối sánh nhờ vào các thủ tục ra quyết định dựa trên một công cụ gọi là hàm phân lớp hay hàm ra quyết định.", "order_start": 0, "order_end": 620, "word_count": 143}
{"parent_id": "73344e07-bbbf-44fa-bd73-77990307cc6d", "subject": "Xulyanh", "section": "Học không giám sát (unsupervised learning)", "title_path": "Học không giám sát (unsupervised learning)", "content": "[Xulyanh / Học không giám sát (unsupervised learning)] Kỹ thuật học này phải tự định ra các lớp khác nhau và xác định các tham số đặc trưng cho từng lớp. Học không giám sát đương nhiên là khó khăn hơn. Một mặt, do số lớp không được biết trước, mặt khác những đặc trưng của các lớp cũng không biết trước. Kỹ thuật này nhằm tiến hành mọi cách gộp nhóm có thể và chọn lựa cách tốt nhất. Bắt đầu từ tập dữ liệu, nhiều thủ tục xử lý khác nhau nhằm phân lớp và nâng cấp dần để đạt được một phương án phân loại. Nhìn chung, dù là mô hình nào và kỹ thuật nhận dạng ra sao, một hệ thống nhận dạng có thể tóm tắt theo sơ đồ sau:", "order_start": 0, "order_end": 563, "word_count": 127}
{"parent_id": "60ad2b03-030c-437c-9f40-4d90a1ec9116", "subject": "Xulyanh", "section": "6.2. NHẬN DẠNG DỰA THEO MIỀN KHÔNG GIAN", "title_path": "6.2. NHẬN DẠNG DỰA THEO MIỀN KHÔNG GIAN", "content": "[Xulyanh / 6.2. NHẬN DẠNG DỰA THEO MIỀN KHÔNG GIAN] Trong kỹ thuật này, các đối tượng nhận dạng là các đối tượng định lượng. Mỗi đối tượng được biểu diễn bởi một véctơ nhiều chiều. Trước tiên, ta xem xét một số khái niệm như: phân hoạch không gian, hàm phân biệt sau đó sẽ đi vào một số kỹ thuật cụ thể.", "order_start": 0, "order_end": 251, "word_count": 54}
{"parent_id": "e44633c3-985e-4a55-bd4a-b298167a1efe", "subject": "Xulyanh", "section": "6.2.1. Phân hoạch không gian", "title_path": "6.2.1. Phân hoạch không gian", "content": "[Xulyanh / 6.2.1. Phân hoạch không gian] Giả sử không gian đối tượng X được định nghĩa: X = {Xi, i=1, 2,...,m}, Xi là một véctơ. Người ta nói P là một phân hoạch của không gian X thành các lớp Ci, Ci  X nếu: Nói chung, đây là trường hợp lý tưởng: tập X tách được hoàn toàn. Trong thực tế, thường gặp không gian biểu diễn tách được từng phần. Như vậy phân loại là dựa vào việc xây dựng một ánh xạ f: X  P", "order_start": 0, "order_end": 364, "word_count": 83}
{"parent_id": "670161dc-ebaa-471f-9cbf-3daf05bb024e", "subject": "Xulyanh", "section": "6.2.2. Hàm phân lớp hay hàm ra quyết định", "title_path": "6.2.2. Hàm phân lớp hay hàm ra quyết định", "content": "[Xulyanh / 6.2.2. Hàm phân lớp hay hàm ra quyết định] Để phân đối tượng vào các lớp, ta phải xác định số lớp và ranh giới giữa các lớp đó. Hàm phân lớp hay hàm phân biệt là một công cụ rất quan trọng. Gọi {gi} là lớp các hàm phân lớp. Lớp hàm này được định nghĩa như sau: nếu  i  k, gk(X) > gi(X) thì ta quyết định X  lớp k. Như vậy để phân biệt k lớp, ta cần k-1 hàm phân biệt. Hàm phân biệt g của một lớp nào đó thường dùng là hàm tuyến tính, có nghĩa là: trong đó: Wi là các trọng số gán cho các thành phần Xi.  W0 là trọng số để viết cho gọn. Trong trường hợp g là tuyến tính, người ta nói là việc phân lớp là tuyến tính hay siêu phẳng (Hyperplane). Các hàm phân biệt thường được xây dựng dựa trên khái niệm khoảng cách hay dựa vào xác suất có điều kiện. Lẽ tự nhiên, khoảng cách là một công cụ rất tốt để xác định xem đối tượng có \"gần nhau\" hay không. Nếu khoảng cách nhỏ hơn một ngưỡng  nào đấy ta coi 2 đối tượng là giống nhau và gộp chúng vào một lớp. Ngược lại, nếu khoảng cách lớn hơn ngưỡng, có nghĩa là chúng khác nhau và ta tách thành 2 lớp. Trong một số trường hợp, người ta dựa vào xác suất có điều kiện để phân lớp cho đối tượng.", "order_start": 0, "order_end": 1097, "word_count": 248}
{"parent_id": "670161dc-ebaa-471f-9cbf-3daf05bb024e", "subject": "Xulyanh", "section": "6.2.2. Hàm phân lớp hay hàm ra quyết định", "title_path": "6.2.2. Hàm phân lớp hay hàm ra quyết định", "content": "[Xulyanh / 6.2.2. Hàm phân lớp hay hàm ra quyết định] lại, nếu khoảng cách lớn hơn ngưỡng, có nghĩa là chúng khác nhau và ta tách thành 2 lớp. Trong một số trường hợp, người ta dựa vào xác suất có điều kiện để phân lớp cho đối tượng. Lý thuyết xác suất có điều kiện được Bayes nghiên cứu khá kỹ và chúng ta có thể áp dụng lý thuyết này để phân biệt đối tượng. Gọi: P(X/Ci) là xác suất để có X biết rằng có xuất hiện lớp Ci P(Ci /X) là xác suất có điều kiện để X thuộc lớp Ci. với X là đối tượng nhận dạng, Ci là các lớp đối tượng. Quá trình học cho phép ta xác định P(X/Ci) và nhờ công thức Bayes về sác xuất có điều kiện áp dụng trong điều kiện nhiều biến, chúng ta sẽ tính được P(Ci/X) theo công ( / ) ( )( / ) ( ) P X C P CP X C P C i ii i thức: P(Ci /X) = ( / ) ( )n P C X P Ci i ( )P X 1i Nếu P(Ci /X) > P(Ck /X) với i # k thì X  Ci. Tuỳ theo các phương pháp nhận dạng khác nhau, hàm phân biệt sẽ có các dạng khác nhau.", "order_start": 1097, "order_end": 1971, "word_count": 215}
{"parent_id": "1a1e5975-5127-4828-8ddd-09a67bf73339", "subject": "Xulyanh", "section": "6.2.3. Nhận dạng thống kê", "title_path": "6.2.3. Nhận dạng thống kê", "content": "[Xulyanh / 6.2.3. Nhận dạng thống kê] Nếu các đối tượng nhận dạng tuân theo luật phân bố Gauss, mà hàm mật độ sác suất cho bởi: Người ta có dùng phương pháp ra quyết định dựa vào lý thuyết Bayes. Lý thuyết Bayes thuộc loại lý thuyết thống kê nên phương pháp nhận dạng.dựa trên lý thuyết Bayes có tên là phương pháp thống kê.", "order_start": 0, "order_end": 286, "word_count": 59}
{"parent_id": "82b2e4ab-38ec-4464-ac08-906d2a81b666", "subject": "Xulyanh", "section": "Quy tắc Bayes", "title_path": "Quy tắc Bayes", "content": "[Xulyanh / Quy tắc Bayes] - Cho không gian đối tượng X = {Xl, l=1, 2,..., L}, với Xl= {x1, x2,..., xp} - Cho không gian diễn dịch  = { C1, C2,..., Cr}, r là số lớp Quy tắc Bayes phát biểu như sau: : X   sao cho X  Ck nếu P(Ck /X) > P(Cl /X) l <> k, l=1, 2,...,r. Trường hợp lý tưởng là nhận dạng luôn đúng, có nghĩa là không có sai số. Thực tế, luôn tồn tại sai số  trong quá trình nhận dạng. Vấn đề ở đây là xây dựng quy tắc nhận dạng với sai số  là nhỏ nhất.", "order_start": 0, "order_end": 442, "word_count": 107}
{"parent_id": "6f501c23-2bd3-48ec-84af-b736e7ed4dd6", "subject": "Xulyanh", "section": "Phương pháp ra quyết định với  tối thiểu", "title_path": "Phương pháp ra quyết định với  tối thiểu", "content": "[Xulyanh / Phương pháp ra quyết định với  tối thiểu] Ta xác định X  Ck nhờ xác suất P(Ck/X). Vậy nếu có sai số, sai số sẽ được tính bởi 1 - P(Ck/X). Để đánh giá sai số trung bình, người ta xây dựng một ma trận L(r,r) giả thiết là có n lớp. Ma trận L được định nghĩa như sau: Như vậy, sai số trung bình của sự phân lớp sẽ là: Để sai số là nhỏ nhất ta cần có rk là min. Từ công thức 6.2 và 6.4 ta có: Vậy, quy tắc ra quyết định dựa trên lý thuyết Bayes có tính đến sai số được phát biểu như sau: với  k là rk(X). Trường hợp đặc biệt với 2 lớp C1 và C2, ta dễ dàng có: X  C1 nếu P(X/C1) > ( / )( ) 212 22 2 P X CP Cl l ( )21 111 P Cl l Giả sử thêm rằng xác suất phân bố là đều (P(C1) = P(C2), sai số là như nhau ta có:", "order_start": 0, "order_end": 667, "word_count": 169}
{"parent_id": "ce70171b-7fec-49fe-972e-42e925af0300", "subject": "Xulyanh", "section": "6.2.4. Một số thuật toán nhận dạng tiêu biểu trong tự học", "title_path": "6.2.4. Một số thuật toán nhận dạng tiêu biểu trong tự học", "content": "[Xulyanh / 6.2.4. Một số thuật toán nhận dạng tiêu biểu trong tự học] Thực tế có nhiều thuật toán nhận dạng Học không giám sát. Ở đây, chúng ta xem xét 3 thuật toán hay được sử dụng: Thuật toán nhận dạng dựa vào khoảng cách lớn nhất, thuật toán K- trung bình (K mean) và thuật toán ISODATA. Chúng ta lần lượt xem xét các thuật toán này vì chúng có bước tiếp nối, cải tiến từ thuật toán này qua thuật toán khác.", "order_start": 0, "order_end": 340, "word_count": 72}
{"parent_id": "8f33eff5-62bf-45be-89db-30af2c937e9f", "subject": "Xulyanh", "section": "6.2.4.1. Thuật toán dựa vào khoảng cách lớn nhất a) Nguyên tắc", "title_path": "6.2.4.1. Thuật toán dựa vào khoảng cách lớn nhất a) Nguyên tắc", "content": "[Xulyanh / 6.2.4.1. Thuật toán dựa vào khoảng cách lớn nhất a) Nguyên tắc] Cho một tập gồm m đối tượng. Ta xác định khoảng cách giữa các đối tượng và khoảng cách lớn nhất ứng với phần tử xa nhất tạo nên lớp mới. Sự phân lớp được hình thành dần dần dựa vào việc xác định khoảng cách giữa các đối tượng và các lớp.", "order_start": 0, "order_end": 237, "word_count": 53}
{"parent_id": "1ad92189-1d4c-4eb5-ae17-34bae1e8919a", "subject": "Xulyanh", "section": "Bước 1", "title_path": "Bước 1", "content": "[Xulyanh / Bước 1]  Chọn hạt nhân ban đầu: giả sử X1  C1 gọi là lớp g1. Gọi Z1 là phần tử trung tâm của g1.  Tính tất cả các khoảng cách Dj1 = D(Xj,Z1) với j =1, 2,..., m  Tìm Dk1= maxj Dj1. Xk là phần tử xa nhất của nhóm g1. Như vậy Xk là phần tử trung tâm của lớp mới g2, kí hiệu Z2.  Tính d1 = D12 = D(Z1,Z2).", "order_start": 0, "order_end": 298, "word_count": 75}
{"parent_id": "edbd028e-76d7-4eec-b36d-c993b264e314", "subject": "Xulyanh", "section": "Nguyên tắc chọn", "title_path": "Nguyên tắc chọn", "content": "[Xulyanh / Nguyên tắc chọn]  Nếu Dk (2) <  d1 kết thúc thuật toán. Phân lớp xong.  Nếu không, sẽ tạo nên nhóm thứ ba. Gọi Xk là phần tử trung tâm của g3, kí hiệu Z3. o Tính d3 = (D12 + D13 + D23)/3 với  là ngưỡng cho trước và D13 = D(Z1,Z3), D23 = D(Z2,Z3). Quá trình cứ lặp lại như vậy cho đến khi phân xong. Kết quả là ta thu được các lớp với các đại diện là Z1, Z2,..., Zm.", "order_start": 0, "order_end": 352, "word_count": 85}
{"parent_id": "b8b793aa-7602-4c2a-a374-12889892beed", "subject": "Xulyanh", "section": "6.2.4.2. Thuật toán K trung bình (giả sử có K lớp) a) Nguyên tắc", "title_path": "6.2.4.2. Thuật toán K trung bình (giả sử có K lớp) a) Nguyên tắc", "content": "[Xulyanh / 6.2.4.2. Thuật toán K trung bình (giả sử có K lớp) a) Nguyên tắc] Khác với thuật toán trên, ta xét K phần tử đầu tiên trong không gian đối tượng, hay nói một cách khác ta cố định K lớp. Hàm để đánh giá là hàm khoảng cách Euclide: Jk là hàm chỉ tiêu với lớp Ck. Việc phân vùng cho k hạt nhân đầu tiên được tiến hành theo nguyên tắc khoảng cách cực tiểu. Ở đây, ta dùng phương pháp đạo hàm để tính cực tiểu. Xét  0 kJ với Zk là biến. Ta dễ dàng có (6.9) min khi: Công thức 6.10 là giá trị trung bình của lớp Ck và điều này lý giải tên của phương pháp.", "order_start": 0, "order_end": 484, "word_count": 110}
{"parent_id": "4e50d00d-ad27-4220-acab-0f9842cb1493", "subject": "Xulyanh", "section": "b)Thuật toán", "title_path": "b)Thuật toán", "content": "[Xulyanh / b)Thuật toán]  Chọn Nc phần tử (giả thiết có Nc lớp) của tập T. Gọi các phần tử trung tâm của các lớp đó là: X1, X2,..., XNc và ký hiệu là Z1, Z2,..., ZNc. • Thực hiện phân lớp X  Ck nếu D(X,Zk) = Min D(X,Zj) (1), j =1,..., Nc. (1) là lần lặp thứ nhất. Tính tất cả Zk theo công thức 6.10. Tiếp tục như vậy cho đến bước q. X  Gk(q-1) nếu D(X,Zk(q-1)) = min l D(X,Zl(q-1)). Nếu Zk (q-1) = Zk (q) thuật toán kết thúc, nếu không ta tiếp tục thực hiện phân lớp.", "order_start": 0, "order_end": 445, "word_count": 101}
{"parent_id": "2757ef38-f311-45d2-9f6b-7b996094dcc2", "subject": "Xulyanh", "section": "6.2.4.3. Thuật toán ISODATA", "title_path": "6.2.4.3. Thuật toán ISODATA", "content": "[Xulyanh / 6.2.4.3. Thuật toán ISODATA] ISODATA là viết tắt của từ Iteractive Self Organizing Data Analysis. Nó là thuật toán khá mềm dẻo, không cần cố định các lớp trước. Các bước của thuật toán được mô tả như sau: Lựa chọn một phân hoạch ban đầu dựa trên các tâm bất kỳ. Thực nghiệm đã chứng minh kết quả nhận dạng không phụ thuộc vào phân lớp ban đầu. Phân vùng bằng cách sắp các điểm vào tâm gần nhất dựa vàp khoảng cách Euclide.  Tách đôi lớp ban đầu nếu khoảng cách lớn hơn ngưỡng t1.  Xác định phân hoạch mới trên cơ sở các tâm vừa xác định lại và tiếp tục xác định tâm mới.  Tính tất cả các khoảng cách đến tâm mới.  Nhóm các vùng với tâm theo ngưỡng t2.  Lặp các thao tác tác trên cho đến khi thoả tiêu chuẩn phân hoạch.", "order_start": 0, "order_end": 694, "word_count": 150}
{"parent_id": "1020b04b-595f-4a1d-9841-a55b9066a7db", "subject": "Xulyanh", "section": "6.3.1. Biểu diễn định tính", "title_path": "6.3.1. Biểu diễn định tính", "content": "[Xulyanh / 6.3.1. Biểu diễn định tính] Ngoài cách biễn diễn theo định lượng như đã mô tả ở trên, tồn tại nhiều kiểu đối tượng mang tính định tính. Trong cách biểu diễn này, người ta quan tâm đến các dạng và mối quan hệ giữa chúng. Giả thiết rằng mỗi đối tượng được biểu diễn bởi một dãy ký tự. Các đặc tính biểu diễn bởi cùng một số ký tự. Phương pháp nhận dạng ở đây là nhận dạng lô gíc, dựa và hàm phân biệt là hàm Bool. Cách nhận dạng là nhận dạng các từ có cùng độ dài. Giả sử hàm phân biệt cho mọi ký hiệu là ga(x), gb(x),..., tương ứng với các ký hiệu a, b,.... Để dễ dàng hình dung, ta giả sử có từ \"abc\" được biểu diễn bởi một dãy ký tự X = {x1, x2, x3, x4}. Tính các hàm tương ứng với 4 ký tự và có: Các phép cộng ở đây chỉ phép toán OR. Trên cơ sở tính giá trị cực đại của hàm phân biệt, ta quyết định X có thuộc lớp các từ \"abc\" hay không. Trong cách tiếp cận này, đối tượng tương đương với câu.", "order_start": 0, "order_end": 867, "word_count": 197}
{"parent_id": "65e32010-4b43-4388-a8eb-662310239f4e", "subject": "Xulyanh", "section": "6.3.2. Phương pháp ra quyết định dựa vào cấu trúc 6.3.2.1. Một số khái niệm", "title_path": "6.3.2. Phương pháp ra quyết định dựa vào cấu trúc 6.3.2.1. Một số khái niệm", "content": "[Xulyanh / 6.3.2. Phương pháp ra quyết định dựa vào cấu trúc 6.3.2.1. Một số khái niệm] Thủ tục phân loại và nhận dạng ở đây gồm 2 giai đoạn: Giai đoạn đầu là giai đoạn xác định các quy tắc xây dựng, tương đương với việc nghiên cứu một văn phạm trong một ngôn ngữ chính thống. Giai đoạn tiếp theo khi đã có văn phạm là xem xét tập các dạng có được sinh ra từ các dạng đó không? Nếu nó thuộc tập đó coi như ta đã phân loại xong. Tuy nhiên, văn phạm là một vấn đề lớn. Trong nhận dạng cấu trúc, ta mới chỉ sử dụng được một phần rất nhỏ mà thôi. Như trên đã nói, mô hình cấu trúc tương đương một văn phạm G:G = {Vn, Vt, P, S}. Có rất nhiều kiểu văn phạm khác nhau từ chính tắc, phi ngữ cảnh,... Ở đây, xin giới thiệu một ngôn ngữ có thể được áp dụng trong nhận dạng cấu trúc: đó là ngôn ngữ PLD (Picture Language Description). Ví dụ: Ngôn ngữ PLD Trong ngôn ngữ này, các từ vựng là các vạch có hướng. Có 4 từ vựng cơ bản: Các từ vựng trên các quan hệ được định nghĩa như sau: Văn phạm sinh ra các mô tả trong ngôn ngữ được định nghĩa bởi: với Vn = {A, B, C, D, E} và VT = {a, b, c, . S là ký hiệu bắt đầu và P là tập luật sản xuất. Ngôn ngữ này thường dùng nhận dạng các mạch điện.", "order_start": 0, "order_end": 1090, "word_count": 249}
{"parent_id": "ddfcce24-2ac0-497a-a355-779638b1119f", "subject": "Xulyanh", "section": "6.3.2.2. Phương pháp nhận dạng", "title_path": "6.3.2.2. Phương pháp nhận dạng", "content": "[Xulyanh / 6.3.2.2. Phương pháp nhận dạng] Các đối tượng cần nhận dạng theo phương pháp này được biểu diễn bởi một câu trong ngôn ngữ L(G). Khi đó thao tác phân lớp chính là xem xét một đối tượng có thuộc văn phạm L(G) không? Nói c ch khác nó có được sinh ra bởi các luật của văn phạm G không? Như vậy sự phân l ớp là theo cách tiếp cận cấu trúc đòi hỏi phải xác định:  Tập Vt chung cho mọi đối tượng.  Các quy tắc sinh P để sản sinh ra một câu và chúng khác nhau đối với mỗi lớp.  Quá trình học với các câu biểu diễn các đối tượng mẫu l nhằm xác định văn phạm G.  Quá trình ra quyết định: xác định một đối tượng X được biểu diễn bởi một câu lx. Nếu lx nhận biết bởi ngôn ngữ L(Gx) thì ta nói rằng X Ck. Nói cách khác, việc ra quyết định phân lớp là dựa vào phân tích câu Gk biểu diễn lớp Ck. pháp của văn phạm. Cũng như trong phân tích cú pháp ngôn ngữ, có phân tích trên xuống, dưới lên, việc nhận dạng theo cấu trúc cũng có thể thực hiện theo cách tương tự.", "order_start": 0, "order_end": 922, "word_count": 210}
{"parent_id": "d81d1735-2f1f-4094-8214-531364cb55cd", "subject": "Xulyanh", "section": "6.4. NHẬN DẠNG DỰA THEO MẠNG NƠRON", "title_path": "6.4. NHẬN DẠNG DỰA THEO MẠNG NƠRON", "content": "[Xulyanh / 6.4. NHẬN DẠNG DỰA THEO MẠNG NƠRON] Mạng nơ ron là hệ thống bao gồm nhiều phần tử xử lý đơn giản (nơ ron) hoạt động song song. Tính năng của hệ thống này tuỳ thuộc vào cấu trúc của hệ, các trọng số liên kết nơ ron và quá trình tính toán tại các nơ ron đơn lẻ. Mạng nơ ron có thể học từ dữ liệu mẫu và tổng quát hóa dựa trên các dữ liệu mẫu học.Trong mạng nơ ron, các nơ ron đón nhận tín hiệu vào gọi là nơ ron vào và các nơ ron đưa thông tin ra gọi là nơ ron ra.", "order_start": 0, "order_end": 426, "word_count": 102}
{"parent_id": "9e052eb7-7514-43a4-9cfc-ed109b3a6e47", "subject": "Xulyanh", "section": "6.4.1. Mạng Hopfield", "title_path": "6.4.1. Mạng Hopfield", "content": "[Xulyanh / 6.4.1. Mạng Hopfield] Năm 1982 nhà vật lý người Mỹ J.J. Hopfield đã đề xuất mô hình mạng nơ ron một lớp NN cho phép tạo ánh xạ dữ liệu từ tín hiệu vào sang tín hiệu ra theo kiểu tự kết hợp (auto-association) tức là nếu tín hiệu vào là X thuộc miền giá trị D nào đó thì ra kết quả Y cũng thuộc vào miền D đó. Nhờ vậy, một vectơ tín hiệu vào X bị thiếu thông tin hoặc biến dạng có thể được phục hồi dạng nguyên bản của mình. Trong ứng dụng, mạng Hopfield đã mô phỏng được khả năng tự kết hợp (hồi tưởng) của bộ não người, nhận ra người quen sau khi nhận thấy những nét quen thuộc trên khuôn mặt. Ngoài ra, với một số cải biên mạng Hopfield còn được dùng để giải quyết các bài toán tối ưu, bài toán xử lý dữ liệu trong điều khiển tự ộng.", "order_start": 0, "order_end": 712, "word_count": 158}
{"parent_id": "57b31432-3a80-4de8-b702-a1a86cbc08b6", "subject": "Xulyanh", "section": "a) Kiến trúc mạng", "title_path": "a) Kiến trúc mạng", "content": "[Xulyanh / a) Kiến trúc mạng] Mạng Hopfield có một lớp ra, với số nơ ron bằng số tín hiệu vào. Các liên kết nơ ron là đầy đủ. Nếu có m tín hiệu vào thì ma trận trọng số W sẽ có kích cỡ m x m: W=(wij) trong đó wij là trọng số liên kết nơ ron thứ j ở lớp vào sang nơ ron thứ i ở lớp ra (Các hàng tương ứng với nơ ron ra, các cột tương ứng với nơ ron vào). Mạng nơ ron Hopfield yêu cầu các tín hiệu vào có giá trị lưỡng cực -1 và 1. Trường hợp đầu vào x nhị phân có thể dùng hàm biến đổi x'=2x-1. Hàm kích hoạt được dùng tại các nơ ron là hàm dấu.", "order_start": 0, "order_end": 514, "word_count": 126}
{"parent_id": "74a0d7e7-1c4d-4d6e-af1c-3b831bfa991c", "subject": "Xulyanh", "section": "b) Huấn luyện mạng", "title_path": "b) Huấn luyện mạng", "content": "[Xulyanh / b) Huấn luyện mạng] Mạng Hopfield HF học dựa trên nguyên tắc có giám sát. Giả sử có p mẫu học tương ứng với các vectơ tín hiệu vào Xs, s=1,p. Mạng sẽ xác định bộ trọng số W sao cho Ta xây dựng ma trận trọng số W như sau: W = (w ij) với ở đây Xs = (xs1,...,xsm). Một cách trực quan, trọng số liên kết ji sẽ tăng thêm một lượng là 1 (tương ứng với số hạng xsj.xsi) nếu cả hai thành phần thứ i và thứ j của mẫu học Xs bằng nhau. Khi có mẫu học mới Xp+1 ta chỉ cần xét các thành phần thứ i và thứ j của nó để cập nhật giá trị cho wji (6.13). Có thể chứng minh được với ma trận W được xác định như trong (6.12), ta sẽ có được (6.11). Nói cách khác, mạng đã \"học thuộc\" các ví dụ mẫu {Xs}.", "order_start": 0, "order_end": 664, "word_count": 155}
{"parent_id": "d29da1d0-4156-4552-84cf-67c1cd25fee1", "subject": "Xulyanh", "section": "c) Sử dụng mạng", "title_path": "c) Sử dụng mạng", "content": "[Xulyanh / c) Sử dụng mạng] Giả sử đưa vào mạng vectơ tín hiệu X. Sử dụng mạng để tính đầu ra tương ứng với tín hiệu vào X là quá trình lặp bao gồm các bước:  Ban đầu, đặt X(0) = X. Gọi Y(t) l vectơ tín hiệu ra tương ứng với một lần cho X(t) lan truyền trong mạng. Y(t) = out(t) = Tinh (HF, X Nếu Y(t)  X(t) thì tiếp tục bước lặp với t=t+1 và X(t+1) = Y(t) = out(t) Nếu Y(t) = X(t) thì dừng và khi đó X(t) được coi là kết quả xử lý của mạng khi có tín hiệu vào X. Điểm chú ý quan trọng là ma trận W không thay đổi trong quá trình sử dụng mạng.", "order_start": 0, "order_end": 517, "word_count": 123}
{"parent_id": "62bd600e-e292-4285-81aa-8dc694ff7f1a", "subject": "Xulyanh", "section": "Một vài tình huống nảy sinh", "title_path": "Một vài tình huống nảy sinh", "content": "[Xulyanh / Một vài tình huống nảy sinh] 1. Mạng không hội tụ. Mạng có thể đưa ra luân phiên một vài mẫu học (hoặc ảnh ngược của chúng). 2. Mạng hội tụ và X(t) = X. Vectơ X đã được đoán nhận đúng dựa trên mẫu học {Xs} hay nói cách khác, X có thể suy ra từ mẫu học. 3. Mạng hội tụ và X(t) = Xs với Xs là mẫu nào đó đã học. Mạng đã phục hồi dạng nguyên bản Xs của X. 4. Mạng hội tụ với X(t)  Xs với mọi mẫu học Xs. chỉ ra một vectơ mới, có thể xem là mẫu học và sẽ được dùng để cập nhật ma trận trọng số. 5. Mạng hội tụ với X(t) nào đó như trong mục 2, 3, 4. nhưng là ảnh ngược (1 thành - 1 và ngược lại).", "order_start": 0, "order_end": 563, "word_count": 139}
{"parent_id": "7c30d740-f437-4d0f-a138-972a0f9cd7be", "subject": "Xulyanh", "section": "6.4.2. Mạng Kohonen", "title_path": "6.4.2. Mạng Kohonen", "content": "[Xulyanh / 6.4.2. Mạng Kohonen] Cách xử lý thông tin trong các mạng ở trên thường chỉ quan tâm tới giá trị và dấu của các thông tin đầu vào, mà chưa quan tâm khai thác các mối liên hệ có tính chất cấu trúc trong lân cận của các vùng dữ liệu mẫu hay toàn thể không gian mẫu. Chẳng hạn, với 2 thành phần: 1 tam giác, 1 hình chữ nhật, ta có thể tạo thành hình ngôi nhà khi chúng được phân bố kề giáp với nhau theo một trật tự nhất định. Teuvo Kohonen (1989) đã đề xuất một ý tưởng rất đáng chú ý về ánh xạ các đặc trưng topo tự tổ chức (theo nghĩa không cần có mẫu học) nhằm bảo toàn trật tự sắp xếp các mẫu trong không gian biểu diễn nhiều chiều sang một không gian mới các mảng nơ ron (một hoặc hai chiều). Trong mạng Kohonen, các vectơ tín hiệu vào gần nhau sẽ được ánh xạ sang các nơ ron trong mạng lân cận nhau.", "order_start": 0, "order_end": 781, "word_count": 173}
{"parent_id": "4977802c-9d08-417e-baa3-1642e7b066e1", "subject": "Xulyanh", "section": "a) Cấu trúc mạng", "title_path": "a) Cấu trúc mạng", "content": "[Xulyanh / a) Cấu trúc mạng] Mạng Kohonen rất gần gũi với kiểu cấu trúc mạng nơ ron sinh học cả về cấu tạo lẫn cơ chế học. Mạng Kohonen thuộc vào nhóm mạng một lớp các nơ ron được phân bố trong mặt phẳng hai chiều theo kiểu lưới vuông, hay lưới lục giác. Phân bố này phải thoả mãn yêu cầu; Mỗi nơ ron có cùng số nơ ron trong từng lớp láng giềng. ý tưởng cơ bản của Kohonen là các đầu vào tương tự nhau sẽ kích hoạt các nơ ron gần nhau về khoảng không gian. Mối quan hệ tương tự (theo khoảng cách) có thể tổng quát hoá cho một lớp tương đối rộng các quan hệ tương tự giữa các tín hiệu đầu vào. Một cách trực quan, có thể xem thuật giải huấn luyện mạng Kohonen nhằm biến đổi không gian tín hiệu vào sang mạng nơ ron giống như các thủ tục kiểu như \"làm trơn\" hay \"tạo hình\" dữ liệu. Để đáp ứng yêu cầu các nơ ron có cùng số nơ ron lân cận trong mỗi lớp láng giềng, người ta thường dùng các phép cuộn chỉ số để đạt được hiệu ứng cái săm xe.", "order_start": 0, "order_end": 907, "word_count": 201}
{"parent_id": "4977802c-9d08-417e-baa3-1642e7b066e1", "subject": "Xulyanh", "section": "a) Cấu trúc mạng", "title_path": "a) Cấu trúc mạng", "content": "[Xulyanh / a) Cấu trúc mạng] hay \"tạo hình\" dữ liệu. Để đáp ứng yêu cầu các nơ ron có cùng số nơ ron lân cận trong mỗi lớp láng giềng, người ta thường dùng các phép cuộn chỉ số để đạt được hiệu ứng cái săm xe. Chẳng hạn, toạ độ (xi, yi) của các nơ ron thuộc lớp láng giềng thứ k của nơ ron có toạ độ (x, y) trong mảng nơ ron 2 chiều có kích thước pq được cho trong thủ tục sau: for i:=-k to k do for j:=-k to k do begin xi:=mod(x+i+p-1,p) + 1; yi:=mod(y+j+q-1,q) + 1; if (i=k) or (j=k) then nơ ron (xi, yi) thuộc vào lớp láng giềng thứ k else nơ ron (xi, yi) thuộc vào lớp láng giềng thứ r r<k; r được xác định bởi max(xi,yi) end; Trường hợp lớp nơron Kohonen là một dãy, cách cuộn tròn mảng nơ ron tạo thành một đường tròn. Tất cả các nơ ron ở lớp kích hoạt có liên kết đầy đủ với lớp vào. Điểm quan trọng nhất trong mạng Kohonen là với một vectơ tín hiệu vào, nó chỉ cho phép các phản hồi mang tính chất địa phương nghĩa là đầu ra của mỗi nơ ron không được nối với tất cả các nơ ron khác mà chỉ với một số nơ ron lân cận.", "order_start": 907, "order_end": 1902, "word_count": 224}
{"parent_id": "4977802c-9d08-417e-baa3-1642e7b066e1", "subject": "Xulyanh", "section": "a) Cấu trúc mạng", "title_path": "a) Cấu trúc mạng", "content": "[Xulyanh / a) Cấu trúc mạng] ectơ tín hiệu vào, nó chỉ cho phép các phản hồi mang tính chất địa phương nghĩa là đầu ra của mỗi nơ ron không được nối với tất cả các nơ ron khác mà chỉ với một số nơ ron lân cận. Sự phản hồi mang tính địa phương của những điều chỉnh (nếu có) tạo ra hiệu ứng là các nơ ron gần nhau về vị trí sẽ có hành vi tương tự khi có những tín hiệu giống nhau được đưa vào.", "order_start": 1902, "order_end": 2264, "word_count": 85}
{"parent_id": "b8e35af1-58f0-4aaf-a2fc-cc2ede672ac2", "subject": "Xulyanh", "section": "b) Huấn luyện mạng", "title_path": "b) Huấn luyện mạng", "content": "[Xulyanh / b) Huấn luyện mạng] Quá trình học được sử dụng trong mạng Kohonen dựa trên kỹ thuật cạnh tranh, không cần có tập mẫu học. Khác với trường hợp học có giám sát, các tín hiệu đầu ra có thể không biết được một cách chính xác. Tại mỗi thời điểm chỉ có một nơ ron duy nhất C trong lớp kích hoạt được lựa chọn sau khi đã đưa vào mạng các tín hiệu Xs. Nơ ron này được chọn theo một trong hai nguyên tắc sau: Nguyên tắc 1 Nơ ron c có tín hiệu ra cực đại outc  max(outj) = max ((xsi wji) Nguyên tắc 2 Vectơ trọng số của nơ ron c gần với tín hiệu vào nhất errc  min(errj) = min ((xsi - wji) 2 ) Sau khi xác định được nơ ron c, các trọng số wci được hiệu chỉnh nhằm làm cho đầu ra của nó lớn hơn hoặc gần hơn giá trị trọng số mong muốn. Do vậy, nếu tín hiệu vào xsi với trọng số wci tạo kết qủa ra quá lớn thì phải giảm trọng số và ngược lại. Các trọng số của các nơron láng giềng j cũng phải được hiệu chỉnh giảm, tuỳ thuộc vào khoảng cách tính từ c. Ta đưa vào hàm tỷ lệ a(.) = a(dcj), ở đây dcj là khoảng cách topo giữa nơ ron trung tâm c và nơ ron j đang xét. Trên thực tế hàm a(.", "order_start": 0, "order_end": 1056, "word_count": 243}
{"parent_id": "b8e35af1-58f0-4aaf-a2fc-cc2ede672ac2", "subject": "Xulyanh", "section": "b) Huấn luyện mạng", "title_path": "b) Huấn luyện mạng", "content": "[Xulyanh / b) Huấn luyện mạng] hỉnh giảm, tuỳ thuộc vào khoảng cách tính từ c. Ta đưa vào hàm tỷ lệ a(.) = a(dcj), ở đây dcj là khoảng cách topo giữa nơ ron trung tâm c và nơ ron j đang xét. Trên thực tế hàm a(.) có thể là hằng số, hàm tỷ lệ nghịch hoặc hàm có điểm uốn. Để đảm bảo yêu cầu, do có nhiều mẫu tham gia quá trình huấn luyện, ta đưa vào hệ số  (t): Tuỳ thuộc vào nơ ron trung tâm c được lựa chọn theo nguyên tắc 1 hoặc nguyên tắc 2 ta có cách hiệu chỉnh các trọng số wji tương ứng: n Sau đó, chuẩn hoá các trọng số sao cho: 2 w ji 1 1i Theo kinh nghiệm, cần phải tạo ra phân bố ngẫu nhiên các trọng số trong khoảng - 0.1 đến 0.1 hoặc -1/m đến 1/m, ở đây m là số trọng số của mạng và chuẩn hoá dữ liệu vào, ra bằng -1 hoặc 1. Tuy nhiên cũng phải chú ý một điều là việc lựa chọn tiêu chuẩn chuẩn hoá, định cỡ dữ liệu phụ thuộc rất nhiều vào bản chất bài toán.", "order_start": 1056, "order_end": 1898, "word_count": 197}
{"parent_id": "5af644e6-c0ae-482f-a521-bed57e8650d6", "subject": "Xulyanh", "section": "c) Sử dụng mạng", "title_path": "c) Sử dụng mạng", "content": "[Xulyanh / c) Sử dụng mạng] Giả sử đã huấn luyệ ạng để nhận được ma trận trọng số W. Khi đưa vào mạng một vector X, toàn bộ ma trận W lại được cập nhật theo các công thức (6.17) hoặc (6.18) tuỳ thuộc vào sử dụng ngu tắc 1 hay nguyên tắc 2.P Như vậy, mạng Kohone cho chúng ta biết được sự phân bố và quan hệ tương đối về mặt \"địa lý\" giữa các mẫu trong không gian biểu diễn.", "order_start": 0, "order_end": 345, "word_count": 78}
{"parent_id": "9f087269-92db-41de-9a45-dfaa8a6914be", "subject": "Xulyanh", "section": "7.1. GIỚI THIỆU", "title_path": "7.1. GIỚI THIỆU", "content": "[Xulyanh / 7.1. GIỚI THIỆU] Nén dữ liệu nhằm làm giảm lượng thông tin “dư thừa” trong dữ liệu gốc và do vậy, lượng thông tin thu được sau khi nén thường nhỏ hơn dữ liệu gốc rất nhiều. Với dữ liệu ảnh, kết quả thường là 10:1. Một số phương pháp còn cho kết quả cao hơn. Theo kết quả nghiên cứu được công bố gần đây tại Viện Kỹ thuật Georfie, kỹ thuật nén fratal cho tỉ số nén là 30:1. Ngoài thuật ngữ “nén dữ liệu”, do bản chất của kỹ thuật này nó còn có một số tên gọi khác như: giảm độ dư thừa, mã hóa ảnh gốc. Từ hơn hai thập kỷ nay, có rất nhiều kỹ thuật nén đã được công bố trên các tài liệu về nén và các phần mềm nén dữ liệu đã xuất hiện ngày càng nhiều trên thương trường. Tuy nhiên, chưa có phương pháp nén nào được coi là phương pháp vạn năng (Universal) vì nó phụ thuộc vào nhiều yếu tố và bản chất của dữ liệu gốc. Trong bài tập này, chúng ta không thể hy vọng xem xét tất cả các phương pháp nén. Hơn thế nữa, các kỹ thuật nén dữ liệu chung đã được trình bày trong nhiều tài liệu chuyên ngành. Ở đây, chúng ta chỉ đề cập các phương pháp nén có đặc thù riêng cho dữ liệu ảnh.", "order_start": 0, "order_end": 1057, "word_count": 234}
{"parent_id": "9f087269-92db-41de-9a45-dfaa8a6914be", "subject": "Xulyanh", "section": "7.1. GIỚI THIỆU", "title_path": "7.1. GIỚI THIỆU", "content": "[Xulyanh / 7.1. GIỚI THIỆU] n. Hơn thế nữa, các kỹ thuật nén dữ liệu chung đã được trình bày trong nhiều tài liệu chuyên ngành. Ở đây, chúng ta chỉ đề cập các phương pháp nén có đặc thù riêng cho dữ liệu ảnh. Có nhiều cách phân loại các phương pháp nén khác nhau. Cách thứ nhất dựa vào nguyên lý nén. Cách này phân các phương pháp én thành hai họ lớn:  Nén chính xác hay nén không mất thông tin: họ này bao gồm các phương pháp nén mà sau khi giải n n ta thu được chính xác dữ liệu gốc. Nén có mất thông tin: họ này bao gồm các phương pháp mà sau khi giải nén ta không thu được dữ liệu như bản gốc. Phương pháp này lợi dụng tính chất của mắt người, chấp nhận một số vặn xoắn trong ảnh khi khôi phục lại. Tất nhiên, các phương pháp này chỉ có hiệu quả khi mà độ vặn xoắn chấp nhận được bằng mắt thường hay với dung sai nào đấy. Cách phân loại thứ hai dựa vào cách thức thực hiện nén. Theo cách này, người ta cũng phân thành hai họ: Phương pháp không gian (Spatial Data Compression): Các phương pháp thuộc họ này thực hiện nén bằng các tác động trực tiếp lên việc lấy mẫu của ảnh trong miền không gian.", "order_start": 1057, "order_end": 2129, "word_count": 231}
{"parent_id": "9f087269-92db-41de-9a45-dfaa8a6914be", "subject": "Xulyanh", "section": "7.1. GIỚI THIỆU", "title_path": "7.1. GIỚI THIỆU", "content": "[Xulyanh / 7.1. GIỚI THIỆU] nh hai họ: Phương pháp không gian (Spatial Data Compression): Các phương pháp thuộc họ này thực hiện nén bằng các tác động trực tiếp lên việc lấy mẫu của ảnh trong miền không gian.  Phương pháp sử dụng biến đổi (Transform Coding): gồm các phương pháp tác động lên sự biến đổi của ảnh gốc mà không tác động trực tiếp như họ trên. Có một cách phân loại khác nữa, cách phân loại thứ ba, dựa vào triết lý của sự mã hóa. Cách này cũng phân các phương pháp nén thành hai họ: Các phương pháp nén thế hệ thứ nhất: Gồm các phương pháp mà mức độ tính toán là đơn giản, ví dụ việc lấy mẫu, gán từ mã,.v.v.  Các phương pháp nén thế hệ thứ hai: dựa vào độ bão hòa của tỷ lệ nén.", "order_start": 2129, "order_end": 2796, "word_count": 143}
{"parent_id": "29b77d4f-baf0-42ab-82f9-e07cd20c2ec4", "subject": "Xulyanh", "section": "7.2.1. Phương pháp mã hóa loạt dài", "title_path": "7.2.1. Phương pháp mã hóa loạt dài", "content": "[Xulyanh / 7.2.1. Phương pháp mã hóa loạt dài] Phương pháp mã hóa loạt dài lúc đầu được phát triển dành cho ảnh số 2 mức: mức đen (1), và mức trắng (0) như các văn bản trên nền trắng, trang in, các bản vẽ kỹ thuật. Nguyên tắc của phương pháp là phát hiện một loạt các bít lặp lại, ví dụ như một loạt các bít 0 nằm giữa hai bít 1, hay ngược lại, một loạt bít 1 nằm giữa hai bít 0. Phương pháp này chỉ có hiệu quả khi chiều dài dãy lặp lớn hơn một ngưỡng nào đó. Dãy các bít lặp gọi là loạt hay mạch (run). Tiếp theo, thay thế chuỗi đó bởi một chuỗi mới gồm 2 thông tin: chiều dài chuỗi và bít lặp (ký tự lặp). Như vậy, chuỗi thay thế sẽ có chiều dài ngắn hơn chuỗi cần thay. Cần lưu ý rằng, đối với ảnh, chiều dài của chuỗi lặp có thể lớn hơn 255. Nếu ta dùng 1 byte để mã hóa thí sẽ không đủ. Giải pháp được dùng là tách các chuỗi đó thành hai chuỗi: một chuỗi có chiều dài 255, chuỗi kia là số bít còn lại. Phương pháp RLC được sử dụng trong việc mã hóa lưu trữ các ảnh Bitmap theo dạng PCX, BMP. Phương pháp RLC có thể chia thành 2 phương pháp nhỏ: phương pháp dùng chiều dài tứ mã cố định và phương pháp thích nghi như kiểu mã Huffman.", "order_start": 0, "order_end": 1091, "word_count": 244}
{"parent_id": "29b77d4f-baf0-42ab-82f9-e07cd20c2ec4", "subject": "Xulyanh", "section": "7.2.1. Phương pháp mã hóa loạt dài", "title_path": "7.2.1. Phương pháp mã hóa loạt dài", "content": "[Xulyanh / 7.2.1. Phương pháp mã hóa loạt dài] trữ các ảnh Bitmap theo dạng PCX, BMP. Phương pháp RLC có thể chia thành 2 phương pháp nhỏ: phương pháp dùng chiều dài tứ mã cố định và phương pháp thích nghi như kiểu mã Huffman. Giả sử các mạch gồm M bits. Để tiện trình bày, đặt M = 2m – 1. Như vậy mạch cũ được thay bởi mạch mới gồm m bits. Với cách thức này, mọi mạch đều được mã hóa bởi từ mã có cùng độ dài. Người ta cũng tính được, với M = 15, p = 0,9, ta sẽ có m và tỷ số nén là 1,95. Với chiều dài cố định, việc cài đặt thuật toán là đơn giản. Tuy nhiên, tỷ lệ nén sẽ không tốt bằng chiều dài biến đổi hay gọi là mã RLC thích nghi.", "order_start": 1091, "order_end": 1681, "word_count": 138}
{"parent_id": "1b2a807f-dab2-4b51-b90b-5afef344f7f1", "subject": "Xulyanh", "section": "7.2.2. Phương pháp mã hóa Huffman", "title_path": "7.2.2. Phương pháp mã hóa Huffman", "content": "[Xulyanh / 7.2.2. Phương pháp mã hóa Huffman] Phương pháp mã hóa Huffman là phương pháp dựa vào mô hình thông kê. Dựa vào dữ liệu gốc, người ta tính tần suất xuất hiện của các ký tự. Việc tính tần suất được thực hiện bởi cách duyệt tuần tự tệp gốc từ đầu đến cuối. Việc xử lý ở đây tính theo bit. Trong phương pháp này người ta gán cho các ký tự có tần suất cao một từ mã ngắn, các ký tự có tần suất thấp từ mã dài. Nói một cách khác, các ký tự có tần suất càng cao được gán mã càng ngắn và ngược lại. Rõ ràng với cách thức này, ta đã làm giảm chiều dài trung bình của từ mã hóa bằng cách dùng chiều dài biến đổi. Tuy nhiên, trong một số tình huống khi tần suất là rất thấp, ta có thể không được lợi một chút nào, thậm chí còn bị thiệt một ít bit.", "order_start": 0, "order_end": 701, "word_count": 160}
{"parent_id": "cfaf8961-a459-4ce1-b9e0-005cb53dd0fd", "subject": "Xulyanh", "section": " Giai đoạn thứ nhất:", "title_path": " Giai đoạn thứ nhất:", "content": "[Xulyanh /  Giai đoạn thứ nhất:] o Tính tần suất của các ký tự trong dữ liệu gốc: duyệt tệp gốc một cách tuần tự từ đầu đến cuối để xây dựng bảng mã. o Tiếp sau đó là sắp xếp lại bảng mã theo thứ tự tần suất giảm dần.", "order_start": 0, "order_end": 184, "word_count": 45}
{"parent_id": "486fa9d2-8c6e-431c-b238-3fc872b11806", "subject": "Xulyanh", "section": " Giai đoạn thứ hai: mã hóa:", "title_path": " Giai đoạn thứ hai: mã hóa:", "content": "[Xulyanh /  Giai đoạn thứ hai: mã hóa:] o Duyệt bảng tần suất từ cuối lên đầu để thực hiện ghép 2 phần tử có tần suất xuất hiện thấp nhất thành một phần tử duy nhất. Phần tử này có tần suất bằng tổng 2 tần suất thành phần. o Tiến hành cập nhật lại bảng và đương nhiên loại bỏ 2 phần tử đã xét. Quá trình được lặp lại cho đến khi bảng chỉ có một phần tử. o Quá trình này gọi là quá trình tạo cây mã Huffman vì việc tập hợp được tiến hành nhờ một cây nhị phân 2 nhánh. Phần tử có tần suất thấp ở bên phải, phần tử kia ở bên trái. Với cách tạo cây này, tất cả các bit dữ liệu/ký tự là nút lá; các nút trong là các nút tổng hợp. o Sau khi cây đã tạo xong, người ta tiến hành gán mã cho các nút lá. Việc mã hóa rất đơn giản: mỗi lần xuống bên phải ta thêm 1 bit “1” vào từ mã; mỗi lần xuống bên trái ta thêm một bit “0”. Tất nhiên có thể làm ngược lại, chỉ có giá trên mã thay đổi còn tổng chiều dài là không đổi. Cũng chính do lý do này mà cây có tên gọi là cây mã Huffman như trên đã gọi. Quá trình giải nén tiến hành theo chiều ngược lại khá đơn giản.", "order_start": 0, "order_end": 1009, "word_count": 236}
{"parent_id": "486fa9d2-8c6e-431c-b238-3fc872b11806", "subject": "Xulyanh", "section": " Giai đoạn thứ hai: mã hóa:", "title_path": " Giai đoạn thứ hai: mã hóa:", "content": "[Xulyanh /  Giai đoạn thứ hai: mã hóa:] ay đổi còn tổng chiều dài là không đổi. Cũng chính do lý do này mà cây có tên gọi là cây mã Huffman như trên đã gọi. Quá trình giải nén tiến hành theo chiều ngược lại khá đơn giản. Người ta cũng phải dựa vào bảng mã tạo ra trong giai đoạn nén (bảng này được giữ lại trong cấu trúc của tệp nén cùng với dữ liệu nén). Ví dụ, với một tệp dữ liệu mà tần suất các ký tự cho bởi. Lưu ý rằng, trong phương pháp Huffman, mã của ký tự là duy nhất và không mã nào là phần bắt đầu của mã khác. Vì vậy, khi đọc tệp nén từng bit từ đầu đến cuối ta có thể duyệt cây mã cho đến một lá, tức là ký tự đã được giải nén.", "order_start": 1009, "order_end": 1610, "word_count": 141}
{"parent_id": "c3a3d397-f641-49e2-99fc-8e6a8acb7d3e", "subject": "Xulyanh", "section": "7.2.3. Phương pháp LZW", "title_path": "7.2.3. Phương pháp LZW", "content": "[Xulyanh / 7.2.3. Phương pháp LZW] Khái niệm nén từ điển được Jacob Lempel và Abraham Ziv đưa ra lần đầu tiên vào năm 1997, sau đó phát triển thành một họ giải thuật nén từ điển LZ. Năm 1984, Terry Welch đã cải tiến giải thuật LZ thành một giải thuật mới hiệu quả hơn và đặt tên là LZW. Phương pháp nén từ điển dựa trên việc xây dựng từ điển lưu các chuỗi ký tự có tần suất lặp lại cao và thay thế bằng từ mã tương ứng mỗi khi gặp lại chúng. Giải thuật LZW hay hơn các giải thuật trước nó ở kỹ thuật chức từ điển cho phép nâng cao tỉ lệ nén. Giải thuật nén LZW được sử dụng cho tất cả các loại file nhị phân. Nó thường được dùng để nén các loại văn bản, nh đen trắng, ảnh màu, ảnh đa mức xám… và là chuẩn nén cho các dạng ảnh GIF và TIFF. Mức độ hiệu quả của LZW không phụ thuộc vào số bít màu của ảnh.", "order_start": 0, "order_end": 767, "word_count": 174}
{"parent_id": "29309d1d-9513-4433-87f0-10c2b384226c", "subject": "Xulyanh", "section": "Phương pháp", "title_path": "Phương pháp", "content": "[Xulyanh / Phương pháp] Giải thuật nén LZW xây dựng một từ điển lưu các mẫu có tần suất xuất hiện cao trong ảnh. Từ điển là tập hợp những cặp từ vựng và nghĩa của nó. Trong đó, từ vựng sẽ là các từ mã được sắp xếp theo thứ tự nhất định. Nghĩa là một chuỗi con trong dữ liệu ảnh. Từ điển được xây dựng đồng thời với quá trình đọc dữ liệu. Sự có mặt của một chuỗi con trong từ điển khẳng định rằng chuỗi đó đã từng xuất hiện trong phần dữ liệu đã đọc. Thuật toán liên tục “tra cứu” và cập nhật từ điển sau mỗi lần đọc một ký tự ở dữ liệu đầu vào. Do kích thước bộ nhớ không phải vô hạn và để đảm bảo tốc độ tìm kiếm, từ điển chỉ giới hạn 4096 ở phần tử dùng để lưu lớn nhất là 4096 giá trị của các từ mã. Như vậy độ dài lớn nhất của từ mã là 12 bits (4096 = 212). Cấu trúc từ điển như sau: 256 từ mã đầu tiên theo thứ tự từ 0…255 chữa các số nguyên từ 0…255. Đây là mã của 256 kí tự cơ bản trong bảng mã ASCII.  Từ mã thứ 256 chứa một mã đặc biệt là “mã xóa” (CC – Clear Code). Mục đích việc dùng mã xóa nhằm khắc phục tình trạng số mẫu lặp trong ảnh lớn hơn 4096.", "order_start": 0, "order_end": 1039, "word_count": 245}
{"parent_id": "29309d1d-9513-4433-87f0-10c2b384226c", "subject": "Xulyanh", "section": "Phương pháp", "title_path": "Phương pháp", "content": "[Xulyanh / Phương pháp] bản trong bảng mã ASCII.  Từ mã thứ 256 chứa một mã đặc biệt là “mã xóa” (CC – Clear Code). Mục đích việc dùng mã xóa nhằm khắc phục tình trạng số mẫu lặp trong ảnh lớn hơn 4096. Khi đó một ảnh được quan niệm là nhiều mảnh ảnh, và từ điển là một bộ từ điển gồm nhiều từ điển con. Cứ hết một mảnh ảnh người ta lại gửi một mã xóa để báo hiệu kết thúc mảnh ảnh cũ, bắt đầu mảnh ảnh mới đồng thời khởi tạo lại từ điển cho mảnh ảnh mới. Mã xóa có giá trị là 256.  Từ mã thứ 257 chứa mã kết thúc thông tin (EOI – End Of Information). Mã này có giá trị là 257. Như chúng ta đã biết, một file ảnh GIF có thể chứa nhiểu ảnh. Mỗi một ảnh sẽ được mã hóa riêng. Chương trình giải mã sẽ lặp đi lặp lại thao tác giải mã từng ảnh cho đến khi gặp mã kết thúc thông tin thì dừng lại.  Các từ mã còn lại (từ 258 đến 4095) chứa các mẫu thương lặp lại trong ảnh. 512 phần tử đầu tiên của từ điển biểu diễn bằng 9 bit. Các từ mã từ 512 đến 1023 biểu diễn bởi 10 bit, từ 1024 đến 2047 biểu diễn bởi 11 bit và từ 2048 đến 4095 biểu diễn bởi 12 bit.", "order_start": 1039, "order_end": 2067, "word_count": 242}
{"parent_id": "b7d0423a-f418-4305-a917-19d9364b977a", "subject": "Xulyanh", "section": "Thuật toán nén LZW:", "title_path": "Thuật toán nén LZW:", "content": "[Xulyanh / Thuật toán nén LZW:] w = null; while ( đọc ký tự k ) { if k là EOI hoặc EOF in ra mã của w; }elseif wk tồn tại trong từ điển { w = wk; }else{ thêm wk vào từ điển; in ra mã của w; w = k; } } Tư tưởng của thuật toán trên có thể hiểu như sau: nếu còn dữ liệu đầu vào thì tiếp tục đọc. Một chuỗi mới sẽ được tạo ra từ chuỗi cũ (chuỗi này ban đầu trống, chuỗi này phải là chuỗi đã tồn tại trong từ điển) và kí tự vừa đọc vào. Sau đó kiểm tra xem chuỗi mới đã có trong từ điển chưa. Mục đích của công việc này là hi vọng kiểm tra xem chuỗi có số kí tự lớn nhất đã tồn tại trong từ điển. Nếu tồn tại ta lại tiếp tục đọc một kí tự tiếp theo và lặp lại công việc. Nếu chưa có trong từ điển, thì gửi chuỗi cũ ra ngoài và thêm chuỗi mới vào từ điển. Có thể xem lại phần ví dụ để hiểu rõ hơn. Ví dụ minh họa cơ chế nén của LZW. Cho chuỗi đầu vào là “ABCBCABCABCD” (Mã ASCII của A là 65, B là 66, C là 67) Từ điển ban đầu gồm 256 kí tự cơ bản và hai mã CC và EOI. Chuỗi đầu ra sẽ là 65 – 66 – 667 – 259 – 258 – 67 – 262 Đầu vào có kích thước: 12x8 = 96 bít (Mỗi ký tự ASCII cần 8 bít).", "order_start": 0, "order_end": 1051, "word_count": 265}
{"parent_id": "b7d0423a-f418-4305-a917-19d9364b977a", "subject": "Xulyanh", "section": "Thuật toán nén LZW:", "title_path": "Thuật toán nén LZW:", "content": "[Xulyanh / Thuật toán nén LZW:] Từ điển ban đầu gồm 256 kí tự cơ bản và hai mã CC và EOI. Chuỗi đầu ra sẽ là 65 – 66 – 667 – 259 – 258 – 67 – 262 Đầu vào có kích thước: 12x8 = 96 bít (Mỗi ký tự ASCII cần 8 bít). Đầu ra có kích thước là: 7x9 = 63 bít (Mỗi ký tự cần 9 bít để mã hóa, từ điển ban đầu đã có 258 ký tự). Tỉ lệ nén là 96: 63 ≅ 1,52", "order_start": 1051, "order_end": 1361, "word_count": 86}
{"parent_id": "b7b2762d-b22e-45f5-ba19-f69416ada123", "subject": "Xulyanh", "section": "Giải nén dữ liệu nén bằng LZW", "title_path": "Giải nén dữ liệu nén bằng LZW", "content": "[Xulyanh / Giải nén dữ liệu nén bằng LZW] Giải thuật giải nén gần như ngược lại với giải thuật nén. Với giải thuật nén, một từ mã ứng với một chuỗi sẽ được ghi ra tệp khi chuỗi ghép bởi chuỗi trên với kí tự vùa đọc chưa có mặt trong từ điển. Người ta cũng cập nhật ngay vào từ điển từ mã ứng với chuỗi tạo bởi chuỗi cũ với kí tự vừa đọc. Kí tự này đồng thời là kí tự đầu tiên trong chuỗi tương ứng với từ mã sẽ được ghi ra tiếp theo. Đây là điểm mấu chốt cho phép xây dựng thuật toán giải nén. Thuật toán được mô tả như sau: Đọc ký tự k; in k; w = k; while (đọc ký tự k ) /*k có thể là ký tự hoặc mã*/ { entry = ý nghĩa của k; in entry; thêm w + entry[0] vào từ điển; w = entry; } Ví dụ minh họa cơ chế giải nén của LZW với dữ liệu đã được nén ở trên 65 – 66 – 667 – 259 – 258 – 67 – 262.", "order_start": 0, "order_end": 746, "word_count": 185}
{"parent_id": "a6acc63d-d23a-464d-997f-0edeeb8ba048", "subject": "Xulyanh", "section": "Trường hợp ngoại lệ và cách xử lý", "title_path": "Trường hợp ngoại lệ và cách xử lý", "content": "[Xulyanh / Trường hợp ngoại lệ và cách xử lý] Đối với giải thuật LZW tồn tại một trường hợp được sinh ra nhưng chương trình giải nén có thể không giải mã được. Giả sử c là một ký tự, S là một chuỗi có độ dài lớn hơn 0. Nếu mã k của từ điển chứa giá trị là cS. Ngay sau đó k’ được dùng thay thế cho cSc. Trong chương trình giải nén, k’ sẽ xuất hiện trước khi nó được định nghĩa. Rất may là từ mã vừa đọc trong trường hợp này bao giờ cũng có nội dung trùng với tổ hợp của từ mã cũ với kí tự đầu tiên của nó. Điều này giúp cho quá trình cài đặt chương trình khắc phục được trường hợp ngoại lệ một cách dễ dàng.", "order_start": 0, "order_end": 561, "word_count": 130}
{"parent_id": "5f1b5d6b-8c6e-477e-9eb0-c59d4fa43514", "subject": "Xulyanh", "section": "7.2.4. Phương pháp mã hóa khối", "title_path": "7.2.4. Phương pháp mã hóa khối", "content": "[Xulyanh / 7.2.4. Phương pháp mã hóa khối] Phương pháp này lúc đầu được phát triển cho ảnh số 2 mức xám, sau đó hoàn thiện thêm bởi các phương pháp thích nghi và mở rộng cho ảnh số đa cấp xám. Cho một ảnh số I(x, y) kích thước MxN. Người ta chia nhỏ ảnh số thành các khối hình chữ nhật kích thước kx1, (k, 1) là rất nhỏ so với M, N. Như vậy ảnh gốc coi như gồm các khối con xếp cạnh nhau và có N x M/(k x 1) khối con. Ta có thể dùng phương pháp mã hóa Huffman cho từng khối của ảnh gốc, nghĩa là gán cho mỗi từ khối một từ mã nhị phân như ở phần trên. Một khó khăn gặp phải khi dùng mã hóa tới ưu Huffman đó là số lượng khối quá lớn. Giải pháp ở đây là dùng mã hóa gần tối ưu, đơn giản hơn để thực hiện mã hóa. Giả thiết các khối là độc lập nhau và số cấu hình là 2kl. Gọi p(I, k, l) là xác suất xuất hiện cấu hình I, entropy tương ứng là: Giá trị H(k,l) có thể được diễn giải là số bit / khối. Các từ mã gán cho các khối kl được tạo bởi các điểm trắng (cấu hình trội) là “0”. Các từ mã gán cho các khối k x l khác gồm kl màu (“1” cho đen, “0” cho trắng) đi tiếp sau bit 1 tiền tố “1”.", "order_start": 0, "order_end": 1044, "word_count": 248}
{"parent_id": "5f1b5d6b-8c6e-477e-9eb0-c59d4fa43514", "subject": "Xulyanh", "section": "7.2.4. Phương pháp mã hóa khối", "title_path": "7.2.4. Phương pháp mã hóa khối", "content": "[Xulyanh / 7.2.4. Phương pháp mã hóa khối] n cho các khối kl được tạo bởi các điểm trắng (cấu hình trội) là “0”. Các từ mã gán cho các khối k x l khác gồm kl màu (“1” cho đen, “0” cho trắng) đi tiếp sau bit 1 tiền tố “1”. Việc mã hóa theo số khối cũng được sử dụng nhiều trong các phương pháp khác như phương pháp dùng biến đổi sẽ trình bày trong mục 8.3 để giảm bớt không gian lưu trữ.", "order_start": 1044, "order_end": 1389, "word_count": 79}
{"parent_id": "03341332-6c7f-4817-97ab-73f4a4561689", "subject": "Xulyanh", "section": "Thuật toán", "title_path": "Thuật toán", "content": "[Xulyanh / Thuật toán] Giả sử p(0, k, x) là xác suất của khối chỉ tạo bởi các điểm trắng đã biết, tỷ số nén có thể tính được dễ dàng. Xác suất này có thể được thiết lập bởi mô hình lý thuyết cho một khối đặc biệt. Do vậy, ta chia khối làm hai loại: khối một chiều và khối hai chiều. Khối một chiều: Xác suất P(0, k, l) tính được nhờ vào mô hình của quá trình Markov bậc một. Quá trình này được biểu diễn nhiều ma trận dịch chuyển trạng thái Π: Với:  p(t/t) là xác suất có điền kiện trắng sang trắng.  p(d/d) là xác suất có điều kiện đen sang đen. Các xác suất khác có ý nghĩa tương tự. Điều này có thể giải thích như sau: xác suất xuất hiện một khối k x 1 chỉ gồm các điểm trắng bằng xác suất xuất hiện một điểm trắng tiếp theo k - 1 dịch chuyển trắng sang trắng. Dựa vào các quan hệ trên, ta tính được tỉ số nén Cr.", "order_start": 0, "order_end": 795, "word_count": 179}
{"parent_id": "31a2d509-59f3-4054-b058-c3d1fabb2bbd", "subject": "Xulyanh", "section": "Khối hai chiều:", "title_path": "Khối hai chiều:", "content": "[Xulyanh / Khối hai chiều:] Xác suất p(0, k, l) của các khối toàn trắng cũng tính được một cách tương tự như trên: Mối quan hệ này tương đương: Và tỷ số nén sẽ cho bởi công thức: Thực tế, khi cài đặt người ta hay chọn khối vuông và giá trị thích hợp k từ 4 đến 5", "order_start": 0, "order_end": 234, "word_count": 55}
{"parent_id": "85a28bab-1c01-4c52-b603-7fcda28e16fc", "subject": "Xulyanh", "section": "7.2.5. Phương pháp thích nghi", "title_path": "7.2.5. Phương pháp thích nghi", "content": "[Xulyanh / 7.2.5. Phương pháp thích nghi] Thuật ngữ “thích nghi” thường dùng để chỉ sự thích hợp của các từ mã theo một nghĩa nào đấy. Như trong phương pháp RLC ở trên, thay vì dùng chiều dài từ mã cố định m bít, người ta dùng chiều dài biến đổi và trên cơ sở đó có phương pháp RLC thích hợp. Trong phương pháp mã hóa khối, người ta sử dụng chiều dài khối cố định gồm k x l điểm ảnh. Tuy nhiên, với ảnh không t uần nhất, phương pháp mã hóa này bộc lộ nhiều nhược điểm. Vì rằng, với ảnh không đồng nhất, chính sự không thuần nhất của ảnh quyết định sự thích nghi với điều kiện cục bộ. Một cải tiến cho vấn đề này là cố định một kích thước của khối, còn kích thước kia coi như là hàm của một tác động trung bình theo hàng (với l = 1) hay theo một nhóm hàng (l > 1). Tác động được quan tâm cũng giống như các phương pháp là sự dịch chuyển các điểm trắng sang đen trên hàng. Một cách lý thuyết người ta cũng tính được giá trị tối ưu của k(kotp): N là số điểm ảnh trên hàng. Trên cơ sở này, người ta áp dụng mã hóa khối tự động thích nghi cho một số ứng dụng  Mã đoạn hay khối k1 tự động thích nghi với tác động cục bộ.", "order_start": 0, "order_end": 1074, "word_count": 241}
{"parent_id": "85a28bab-1c01-4c52-b603-7fcda28e16fc", "subject": "Xulyanh", "section": "7.2.5. Phương pháp thích nghi", "title_path": "7.2.5. Phương pháp thích nghi", "content": "[Xulyanh / 7.2.5. Phương pháp thích nghi] otp): N là số điểm ảnh trên hàng. Trên cơ sở này, người ta áp dụng mã hóa khối tự động thích nghi cho một số ứng dụng  Mã đoạn hay khối k1 tự động thích nghi với tác động cục bộ.  Mã đoạn hay khối k1 tự động thích nghi 1 chiều.  Mã khối k1 tự động thích nghi 2 chiều.", "order_start": 1074, "order_end": 1347, "word_count": 65}
{"parent_id": "bbfdb510-e6ab-4281-8347-e02f2e87cb9a", "subject": "Xulyanh", "section": "7.2.6. Biến đổi Cosin và chuẩn nén JPEG", "title_path": "7.2.6. Biến đổi Cosin và chuẩn nén JPEG", "content": "[Xulyanh / 7.2.6. Biến đổi Cosin và chuẩn nén JPEG] JPEG là viết tắt của Joint Photographic Expert Group (nhóm các chuyên gia phát triển ảnh này). Chuẩn JPEG được công nhận là chuẩn ảnh quốc tế năm 1990 phục vụ các ứng dụng truyền ảnh cho các lĩnh vực như y học, khoa học, kỹ thuật, ảnh nghệ thuật… Chuẩn JPEG được sử dụng để mã hóa ảnh đa mức xám, ảnh màu. Nó không cho kết quả ổn định lắm với ảnh đen trắng. Chuẩn JPEG cung cấp giải thuật cho cả hai loại nén là nén không mất mát thông tin và nén mất mát thông tin. Trong phần dưới đây, chúng tôi trình bày chi tiết về một trong các dạng nén biến đổi chấp nhận mất mát thông tin dùng biến đổi Cosin của chuẩn JPEG: Biến đổi Cosin tuần tự (Sequential DTC - based). Biến đổi Cosin tuần tự là kỹ thuật đơn giản nhất nhưng được dùng phổ biến nhất và nó đáp ứng được hầu hết các đặc tính cần thiết cho hần lớn các ứng dụng.", "order_start": 0, "order_end": 818, "word_count": 175}
{"parent_id": "bbfdb510-e6ab-4281-8347-e02f2e87cb9a", "subject": "Xulyanh", "section": "7.2.6. Biến đổi Cosin và chuẩn nén JPEG", "title_path": "7.2.6. Biến đổi Cosin và chuẩn nén JPEG", "content": "[Xulyanh / 7.2.6. Biến đổi Cosin và chuẩn nén JPEG] (Sequential DTC - based). Biến đổi Cosin tuần tự là kỹ thuật đơn giản nhất nhưng được dùng phổ biến nhất và nó đáp ứng được hầu hết các đặc tính cần thiết cho hần lớn các ứng dụng. Mã hóa JPEG bao gồm nhiều công đoạn, sơ đồ thuật toán nén và giải nén được mô tả dưới đây: Quá trình giải nén sẽ được làm ngược lại, người ta giải mã từng phần ảnh nén tương ứng với phương pháp nén đã sử dụng trong phần nén nhờ các thông tin liên quan ghi trong phần Header của file nén. Kết quả thu được là hệ số đã lượng tử. Các hệ số này được khôi phục về giá trị trước khi lượng tử hóa bằng bộ tương tự hóa. Tiếp đó đem biến đổi Cosin ngược ta được ảnh ban đầu với độ trung thực nhất định.", "order_start": 818, "order_end": 1492, "word_count": 150}
{"parent_id": "a86ba44b-c391-4541-86ba-db2fc79a1beb", "subject": "Xulyanh", "section": "Sơ đồ thuật toán giải nén JPEG", "title_path": "Sơ đồ thuật toán giải nén JPEG", "content": "[Xulyanh / Sơ đồ thuật toán giải nén JPEG] Bảng mã và bảng lượng tử trong sơ đồ giải nén được dựng lên nhờ những thông tin ghi trong phần cấu trúc đầu tệp (Header) của file ảnh nén. Quá trình nén chịu trách nhiệm tạo ra và ghi lại những thông tin này. Phần tiếp theo sẽ phân tích tác dụng của từng khối trong sơ đồ.", "order_start": 0, "order_end": 272, "word_count": 59}
{"parent_id": "3fa2124d-96cb-4c5f-ada0-23df63b379e2", "subject": "Xulyanh", "section": "Phần khối", "title_path": "Phần khối", "content": "[Xulyanh / Phần khối] Chuẩn nén JPEG phân ảnh ra các khối o Công đoạn biến đổi nhanh Cosin hai chiều cho các khối 8x8 tỏ ra hiệu quả hơn. Biến đổi Cosin cho các khối có cùng kích thước có thể giảm được một phần tính toán chung như việc tính hệ số C i j cho 3 tầng (8 = 23 ), số các hệ số là: 4 +2 + √:) Nếu với một ảnh 1024 x 1024, phép biến đổi nhanh Cosin một chiều theo hàng ngang hoặc hàng dọc ta phải qu 10 tầng (1024 = 210). Số các hệ số C i j là: 512 + 256 + 128 + 64 + 8 + 4 + 2 + 1 = 1021. Thời gian tính toán các hệ số C i j với toàn bộ ảnh 1024 x 1024 lớn gấp 150 lần so với thời gian tính toán các hệ số này cho các khối. Biến đổi Cosin đối với các khối có kích thước nhỏ sẽ làm tăng độ chính xác khi tính toán với số dấu phẩy tĩnh, giảm thiểu sai số do làm tròn sinh ra. Do điểm ảnh hàng xóm có độ tương quan cao hơn, do đó phép biến đổi Cosin cho từng khối nhỏ sẽ tập trung năng lượng hơn và một số ít các hệ số biến đổi. Việc loại bớt một số hệ số năng lượng thấp trong các khối chỉ tạo ra mất mát thông tin cục bộ giúp nâng cao chất lượng ảnh.", "order_start": 0, "order_end": 1037, "word_count": 254}
{"parent_id": "3fa2124d-96cb-4c5f-ada0-23df63b379e2", "subject": "Xulyanh", "section": "Phần khối", "title_path": "Phần khối", "content": "[Xulyanh / Phần khối] ập trung năng lượng hơn và một số ít các hệ số biến đổi. Việc loại bớt một số hệ số năng lượng thấp trong các khối chỉ tạo ra mất mát thông tin cục bộ giúp nâng cao chất lượng ảnh. Ảnh sẽ được chia làm B khối: Các khối được xác định bởi bộ số (m,n) với m = [0…MB-1] và n = [0…NB-1], ở đây m chỉ thứ tự của khối theo chiều rộng, n chỉ thứ tự của khối theo chiều dài. Phân tích khối thực chất là xác định tương quan giữa tọa độ riêng trong khối với tọa độ thực của điểm ảnh trong ảnh ban đầu. Nếu ảnh ban đầu kí hiệu Image[i,j] thì ma trận biểu diễn khối (m,n) là x[u, v] được tính:", "order_start": 1037, "order_end": 1617, "word_count": 132}
{"parent_id": "91b9467f-46fa-4b3f-8984-840df4eb0ad3", "subject": "Xulyanh", "section": "Biến đổi Cosin", "title_path": "Biến đổi Cosin", "content": "[Xulyanh / Biến đổi Cosin] Biến đổi là một trong những công đoạn lớn trong các phương pháp nén sử dụng phép biến đổi. Nhiệm vụ của công đoạn biến đổi là tập trung năng lượng vào một số ít các hệ số biến đổi. Công thức biến đổi cho mỗi khối là: Trong đó: Thuật toán biến đổi nhanh Cosin hai chiều cho mỗi khối trong trường hợp này sẽ bao gồm 16 phép biến đổi nhanh Cosin một chiều. Đầu tiên, người ta biến đổi nhanh Cosin một chiều cho các dãy điểm ảnh trên mỗi hàng. Lầ lượt thực hiện cho 8 hàng. Sau đó đem biến đổi nhanh Cosin một chiều theo từng cột của ma trận vừa thu được sau 8 phép biến đổi trên. Cũng lần lượt thực hi ện cho 8 c Ma trận cuối cùng sẽ là ma trận hệ số biến đổi của khối tương ứng. Trong sơ đồ giải nén ta phải dùng phép biến đổi Cosin ngược.", "order_start": 0, "order_end": 737, "word_count": 163}
{"parent_id": "91b9467f-46fa-4b3f-8984-840df4eb0ad3", "subject": "Xulyanh", "section": "Biến đổi Cosin", "title_path": "Biến đổi Cosin", "content": "[Xulyanh / Biến đổi Cosin] phép biến đổi trên. Cũng lần lượt thực hi ện cho 8 c Ma trận cuối cùng sẽ là ma trận hệ số biến đổi của khối tương ứng. Trong sơ đồ giải nén ta phải dùng phép biến đổi Cosin ngược. Công thức biến đổi ngược cho khối 88: trong đó:", "order_start": 737, "order_end": 966, "word_count": 52}
{"parent_id": "6b647985-c34d-4cf4-836c-d428a4387130", "subject": "Xulyanh", "section": "Lượng tử hóa", "title_path": "Lượng tử hóa", "content": "[Xulyanh / Lượng tử hóa] Khối lượng tử hóa trong sơ đồ nén đóng vai trò quan trong và quyết định tỉ lệ nén của chuẩn nén j. Đầu vào của khối lượng tử hóa là các ma trận hệ số biến đổi Cosin của các khối điểm ảnh. Để giảm số bộ lượng tử, người ta tìm cách quy các hệ số ở các khối về cùng một khoảng phân bố. Chuẩn nén j chỉ sử dụng một bộ lượng tử hóa. Giả sử rằng các hệ số đều có hàm tính xác suất xuất hiện như nhau. Chúng ta sẽ căn chỉnh lại hệ số yj bằng phép gán: Với μj là trung bình cộng của hệ số thứ j σj là độ lệch cơ bản của hệ số thư j. Như vậy chúng ta sẽ đồng nhất được mức quyết định và mức tạo lại cho tất cả các hệ số. Do đó, các hệ số được biểu diễn cùng bằng một số lượng bit. Có nhiều cách tiếp cận để tính được các mức quyết định và mức tạo lại. Lloyd – Max đưa ra giải thuật sau: Buóc 1: Chçn giá tr khōi tao: N là múc luong tir Buóc 2: Cho i bién thiên tù i dêr -1 thu. hiên các công vic sau: a. Tính di theo công thúx. b. Tính r; theo công thúc: Buóc 3: Tính Buóc 4: Néu rη-1 ≠ r’ diu chinh lai ro và lp lai tù buóc 2 dén buróc 4.", "order_start": 0, "order_end": 1030, "word_count": 249}
{"parent_id": "6b647985-c34d-4cf4-836c-d428a4387130", "subject": "Xulyanh", "section": "Lượng tử hóa", "title_path": "Lượng tử hóa", "content": "[Xulyanh / Lượng tử hóa] n tù i dêr -1 thu. hiên các công vic sau: a. Tính di theo công thúx. b. Tính r; theo công thúc: Buóc 3: Tính Buóc 4: Néu rη-1 ≠ r’ diu chinh lai ro và lp lai tù buóc 2 dén buróc 4. Trong quá trình cài đặt tạo ra một bộ lượng tử hóa, Lloyd và Max đã có nhiều cải tiến để tính toán dễ dàng hơn. Xác định d1 bằng công thức trong bước 2a được tiến hành theo phương pháp Newton-Raphson. Sau đây là các bước mô tả toàn bộ công việc của khối lượng từ hóa tác động lên các hệ số biến đổi Cosin: Buóc 1: Tính trung binh cng μ và ∂ lêch co bån σ cho tùng h só δ mōi vi trí trong khói Vói yj là h só thú j, n là só khói. Buóc 2: Lua chon ti l só h só giù lai trong môt khói. Buóc 3: Giū lai các h só có ∂ lch co bn lón hon Buróc 4: Lâp ma trân I sao cho: Tij =1 néu h só (i,j) dugc giū lai. Buóc 5: Cn chinh lai gi tr ca các h só xoay chiu duęc gi lai δ các khói: Buróc 6: Tính phân bó cùa các giá tri xoay c’ iêu dã cn chinh. Buóc 7: Tinh do lech co bån cua cic phân b ira tnh. Buróc 8: Luong tir hóa cac h só x ay c. u bng c.", "order_start": 1030, "order_end": 2046, "word_count": 252}
{"parent_id": "6b647985-c34d-4cf4-836c-d428a4387130", "subject": "Xulyanh", "section": "Lượng tử hóa", "title_path": "Lượng tử hóa", "content": "[Xulyanh / Lượng tử hóa] lai δ các khói: Buróc 6: Tính phân bó cùa các giá tri xoay c’ iêu dã cn chinh. Buóc 7: Tinh do lech co bån cua cic phân b ira tnh. Buróc 8: Luong tir hóa cac h só x ay c. u bng c.ch si dung bô lugng tùr Lloyd- Max sau khi dã dieu chinh múc -uyét dinh mýc tao lai cùa nó theo cách sau: Thành phần một chiều sẽ không lượng tử hóa. Đến đây, ta chuyển sang bước nén.", "order_start": 2046, "order_end": 2408, "word_count": 85}
{"parent_id": "52525e04-914e-4752-9fdd-5eec3456bf0f", "subject": "Xulyanh", "section": "Nén dữ liệu", "title_path": "Nén dữ liệu", "content": "[Xulyanh / Nén dữ liệu] Đầu vào của khối nén gồm hai thành phần: thành phần các hệ số một chiều và thành phần các hệ số xoay chiều. Thành phần các hệ số một chiều Ci(0, 0) với i = 0,1,…,63 chứa phần lớn năng lượng tín hiệu hình ảnh. Người ta không nén trực tiếp các giá trị Ci(0, 0) mà xác định độ lệch của Ci(0, 0): di = Ci+1(0, 0) – Ci(0, 0) di có giá trị nhở hơn nhiều so với Ci nên trong biểu diễn dấu phẩy động theo chuẩn IEE754 thường chưa nhiều chuỗi bit 0 nên có thể cho hiệu suất nén cao hơn. Giá trị C0(0, 0) và các độ lệch d1, được ghi ra một tệp tạm. Tệp này được nén bằng phương pháp nén Huffman. Thành phần các hệ số xoay chiều C1(m, n) với 1≤m≤7, 1≤n≤7 chứa các thông tin chi tiết của ảnh. Để nâng cao hiệu quả nén cho mỗi bộ hệ số trong một khối, người ta xếp chúng lại theo thứ tự ZigZag. Tác dụng của sắp xếp lại theo thứ tự ZigZag là tạo ra nhiều loại hệ số giống nhau. Chúng ta biết rằng năng lượng của khối hệ số giảm dần từ góc trên bên trái xuống góc dưới bên phải nên việc sắp xếp lại các hệ số theo thứ tự ZigZag sẽ tạo điều kiện cho các hệ số xấp xỉ nhau (cùng mức lượng tử) nằm trên một dòng.", "order_start": 0, "order_end": 1095, "word_count": 246}
{"parent_id": "52525e04-914e-4752-9fdd-5eec3456bf0f", "subject": "Xulyanh", "section": "Nén dữ liệu", "title_path": "Nén dữ liệu", "content": "[Xulyanh / Nén dữ liệu] dần từ góc trên bên trái xuống góc dưới bên phải nên việc sắp xếp lại các hệ số theo thứ tự ZigZag sẽ tạo điều kiện cho các hệ số xấp xỉ nhau (cùng mức lượng tử) nằm trên một dòng. Mỗi khối ZigZag này được mã hóa theo phương pháp RLE. Cuối mỗi khối đầu ra của RLE, ta đặt dấu kết thúc khối EOB (End Of Block). Sau đó, các khối được dồn lại và mã hóa một lần bằng phương pháp mã Huffman. Nhờ có dấu kết thúc khối nên có thể phân biệt được hai khối cạnh nhau khi giải mã Huffman. Hai bảng mã Huffman cho hai thành phần hệ số tất nhiên sẽ khác nhau. Để có thể giải nén được, chúng ta phải ghi lại thông tin như: kích thước ảnh, kích thước khối, ma trận Y, độ lệch tiêu chuẩn, các mức tạo lại, hai bảng mã Huffman, kích thước khối nén một chiều, kích thước khối nén xoay chiều… và ghi nối tiếp vào hai file nén của thành phần hệ số. Cài đặt giải thuật cho nén thực sự phức tạp. Chúng ta phải nắm được các kiến thức về nén RLE, Huffman, biến đổi Cosin, xây dựng bộ lượng tử hóa Lloyd-Max…Nén và giải nén hơi chậm nhưng bù lại, thời gian truyền trên mạng nhanh hơn do kích thước tệp nén nhỏ.", "order_start": 1095, "order_end": 2180, "word_count": 235}
{"parent_id": "52525e04-914e-4752-9fdd-5eec3456bf0f", "subject": "Xulyanh", "section": "Nén dữ liệu", "title_path": "Nén dữ liệu", "content": "[Xulyanh / Nén dữ liệu] thức về nén RLE, Huffman, biến đổi Cosin, xây dựng bộ lượng tử hóa Lloyd-Max…Nén và giải nén hơi chậm nhưng bù lại, thời gian truyền trên mạng nhanh hơn do kích thước tệp nén nhỏ. Với những ưu điểm của mình được ISO chấp nhận là chuẩn ảnh quốc tế và được biết đến dưới mã số ISO 10918-1.", "order_start": 2180, "order_end": 2467, "word_count": 60}
{"parent_id": "1144452a-545d-4315-8613-1df9228e147a", "subject": "Xulyanh", "section": "7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace)", "title_path": "7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace)", "content": "[Xulyanh / 7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace)] Phương pháp này là tổ hợp của hai phương pháp: Mã hóa thích nghi và biến đổi. Tỷ số nén là khá cao, thường là 1 . Về nguyên tắc, phương pháp này dựa vào mô hình phân cấp quan sát của con người. Bắt đầu từ ảnh gốc x(m, n) qua bộ lọc dải thấp ta thu được tín hiệu x1(m, n). Bộ lọc này được thiết kế để tính trung bình cục bộ dựa vào đáp ứng xung 2 chiều gần với đường cong Gauss. Bộ lọc này đòng vai trò “dự đoán” với sai số e1(m, n) tính bởi: Như vậy là mã hóa của x1(m, n) và e1(m, n) là tương đương với mã hóa của x(m, n). Với cách biến đổi như trên e1(m, n) thuộc loại dải cao. Vì mắt người ít cảm nhận được tín hiệu với tần số cao nên ta có thể dùng một lượng bit ít hơn để mã hóa cho nó. Mặt khác tín hiệu x1(m, n) thuộc loại dải thấp, nên theo lý thuyết sẽ lấy mẫu số mẫu sẽ ít hơn. Quá trình này được lặp lại bằng cách dùng các bộ lọc thấp khác nhau và ta sẽ thu được các tín hiệu xi(m, n), i=1,2,… Với mỗi lần lặp kích thước của ảnh sẽ giảm đi một lượng bằng fi /fi+1. Theo cách này, ta có một cấu trúc xếp chồng tự như cấu trúc Kim tự tháp mà kích thước giảm dần từ gốc đến đỉnh.", "order_start": 0, "order_end": 1087, "word_count": 252}
{"parent_id": "1144452a-545d-4315-8613-1df9228e147a", "subject": "Xulyanh", "section": "7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace)", "title_path": "7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace)", "content": "[Xulyanh / 7.3.1. Phương pháp Kim tự tháp Laplace (Pyramide Laplace)] i mỗi lần lặp kích thước của ảnh sẽ giảm đi một lượng bằng fi /fi+1. Theo cách này, ta có một cấu trúc xếp chồng tự như cấu trúc Kim tự tháp mà kích thước giảm dần từ gốc đến đỉnh. Nhân chập Gauss được dùng ở đây có kích thước 5x5. Các tín hiệu ra sau đó được lượng hóa và mẫu hóa. Theo kết quả đã công bố [6] với bộ lọc giải thấp một chiều tách được với các trọng số: g(0) = 0,7, g(-1) = g(1) = 0,25 và g(-2) = g(2) = 0,1. Tỉ số nén dao động từ 6/1 đến 32/1. Tuy nhiên, nếu tỉ số nén cao thì ảnh kết quả sẽ có biến dạng.", "order_start": 1087, "order_end": 1608, "word_count": 123}
{"parent_id": "5342cf58-79e8-4daa-86f9-cbc3d17cb0d5", "subject": "Xulyanh", "section": "7.3.2. Phương pháp mã hóa dựa vào biểu diễn ảnh", "title_path": "7.3.2. Phương pháp mã hóa dựa vào biểu diễn ảnh", "content": "[Xulyanh / 7.3.2. Phương pháp mã hóa dựa vào biểu diễn ảnh] Như đã biết, trong xử lý ảnh tùy theo các ứng dụng mà ta cần toàn bộ ảnh hay chỉ những đặc tính quan trọng của ảnh. Các phương pháp phân vùng ảnh trong chương sáu như hợp vùng, tách, tách và hợp là rất hữu ích và có thể để nén ảnh. Có thể có nhiều phương pháp khác, song dưới đây chúng ta chỉ đề cập đến hai phương pháp: vùng gia tăng và phương pháp tách hợp.", "order_start": 0, "order_end": 359, "word_count": 80}
{"parent_id": "9d3f9c69-2c17-4ac8-806f-95115270189c", "subject": "Xulyanh", "section": "7.3.2.1. Mã hóa dựa vào vùng gia tăng", "title_path": "7.3.2.1. Mã hóa dựa vào vùng gia tăng", "content": "[Xulyanh / 7.3.2.1. Mã hóa dựa vào vùng gia tăng] Kỹ thuật vùng gia tăng thực chất là hợp các vùng có cùng một tính chất nào đó. Kết quả của nó là một ảnh được phân đoạn giống như một ô trong trò xếp chữ (Puzzle). Tuy nhiên, cần lưu ý rằng tất cả các đường bao thu được không tạo nên một ảnh giống ảnh gốc. Việc xác định tính chất miền đồng nhất xác định độ phức tạp của phương pháp. Để đơn giản, tiêu chuẩn chọn ở đây là khoảng mức xám. Như vậy, miền đồng nhất là tập hợp các điểm ảnh có mức xám thuộc khoảng đã chọn. Cũng cần lưu ý thêm rằng, ảnh gốc có thể có đường bao và các kết cấu (Texture). Trong miền texture, độ xám biến đổi rất chậm. Do vậy, nếu không chú ý sẽ chia ảnh thành quá nhiều miền và gây nên các bao giả. Giải pháp để khắc phục hiện tượng này là ta dùng một bộ lọc thích hợp hay lọc trung vị. Sau giai đoạn này, ta thu được ảnh phân đoạn với các đường viền kín, độ rộng 1 pixel. Để loại bỏ các đường bao giả, ta có thể dùng phương pháp gradient (xem chương năm). Sau khi đã thu được các đường bao đúng, người ta tiến hành mã hóa (xấp xỉ) đường bao bởi các đường cong trong hình học, ví dụ bởi các đoạn thẳng hay đường cong.", "order_start": 0, "order_end": 1094, "word_count": 241}
{"parent_id": "9d3f9c69-2c17-4ac8-806f-95115270189c", "subject": "Xulyanh", "section": "7.3.2.1. Mã hóa dựa vào vùng gia tăng", "title_path": "7.3.2.1. Mã hóa dựa vào vùng gia tăng", "content": "[Xulyanh / 7.3.2.1. Mã hóa dựa vào vùng gia tăng] t (xem chương năm). Sau khi đã thu được các đường bao đúng, người ta tiến hành mã hóa (xấp xỉ) đường bao bởi các đường cong trong hình học, ví dụ bởi các đoạn thẳng hay đường cong. Nếu ảnh gốc có độ phân giải không thích hợp, người ta dùng khoảng 1,3 bit cho một điểm biên. Phương pháp này thể hiện ưu điểm: đó là mô hình tham số. Các tham số ở đây là số vùng, độ chính xác mô tả. Tuy nhiên, tham số khoảng mức xám là quan trọng nhất vì nó có ảnh hưởng đến tỉ số nén. Một tham số cũng không kém phần quan trọng là số điểm của các đường bao bị coi là giả. Thường số điểm này không vượt quá 20 điểm.", "order_start": 1094, "order_end": 1691, "word_count": 134}
{"parent_id": "7349e46f-ab4b-4a1c-9867-c21a140dc654", "subject": "Xulyanh", "section": "7.3.2.2. Phương pháp tách – hợp", "title_path": "7.3.2.2. Phương pháp tách – hợp", "content": "[Xulyanh / 7.3.2.2. Phương pháp tách – hợp] Cũng như đã chỉ ra trong chương sáu, phương pháp tách – hợp khắc phục được một số nhược điểm của phương pháp phân vùng dựa vào tách vùng hay hợp vùng. Trong phương pháp mã hóa này, người ta thay tiêu chuẩn chọn vùng đơn giản ở trên bằng một tiêu chuẩn khác hiệu quả hơn. Nguyên tắc chung của phương pháp mô hình biên – texture. Nhìn chung đường biên dễ nhạy cảm với mắt người, còn texture thì ít nhạy cảm hơn. Người ta mong muốn rằng đường phân ranh giữa các vùng là đồng nhất với các đường bao. Lưu ý rằng cần quyết định phân vùng một phần của ảnh sao cho nó không được vắt chéo đường bao. Đây là một tiêu chuẩn kiểm tra quan trọng. Các đường bao thường nhận được bởi các bộ lọc thông cao, đẳng hướng. Để có thể quản lý các điểm thuộc một vùng một các tốt hơn, tiêu chuẩn kiểm tra thứ hai cũng được xem xét đó là dấu: “các điểm nằm về một phía của đường bao có cùng dấu”. Nhìn chung, phương pháp gồm hai giai đoạn. giai đoạn đầu thực hiện việc tách vùng, giai đoạn sau thực hiện việc hợp vùng. Quá trình tách thực hiện trước. Người ta chia ảnh gốc thành các vùng nhỏ kích thước 99.", "order_start": 0, "order_end": 1083, "word_count": 228}
{"parent_id": "7349e46f-ab4b-4a1c-9867-c21a140dc654", "subject": "Xulyanh", "section": "7.3.2.2. Phương pháp tách – hợp", "title_path": "7.3.2.2. Phương pháp tách – hợp", "content": "[Xulyanh / 7.3.2.2. Phương pháp tách – hợp] i giai đoạn. giai đoạn đầu thực hiện việc tách vùng, giai đoạn sau thực hiện việc hợp vùng. Quá trình tách thực hiện trước. Người ta chia ảnh gốc thành các vùng nhỏ kích thước 99. Tiếp theo, tiến hành xấp xỉ các vùng ảnh đó bằng một đa thức có bậc nhỏ hơn 3. Sau quá trình tách ta thu được trong một số vùng của ảnh các hình vuông liên tiếp. chúng sẽ tạo nên một miền gốc lớn và không nhất thiết vuông. Như vậy, trong trường hợp này phải xấp xỉ bằng rất nhiều các đa thức giống nhau. Rõ dàng là việc mã hóa riêng biệt các đa thức là điều kiện hiệu quả và người nghĩ đến hợp các vùng để giảm độ dư thừa này. Quá trình hợp được tiến hành như sau: nếu hai vùng có thể được xấp xỉ bởi 2 đa thức tương tự, người ta hợp chúng làm một và chỉ dùng một đa thức xấp xỉ. Nếu mức độ thay đổi là thấp, ta sẽ có nhiều cặp vùng tương tự. Để có thể nhận được kết quả không phụ thuộc vào lần hợp đầu, người ta xây dựng đồ thị “vùng kế cận”. Các nút của đồ thị này là các vùng và các liên hệ biểu diễn mối không tương đồng. Sự liên hệ với mức không tương đồng thấp chỉ ra rằng hai vùng cần hợp lại.", "order_start": 1083, "order_end": 2164, "word_count": 243}
{"parent_id": "7349e46f-ab4b-4a1c-9867-c21a140dc654", "subject": "Xulyanh", "section": "7.3.2.2. Phương pháp tách – hợp", "title_path": "7.3.2.2. Phương pháp tách – hợp", "content": "[Xulyanh / 7.3.2.2. Phương pháp tách – hợp] g đồ thị “vùng kế cận”. Các nút của đồ thị này là các vùng và các liên hệ biểu diễn mối không tương đồng. Sự liên hệ với mức không tương đồng thấp chỉ ra rằng hai vùng cần hợp lại. Sau bước hợp này, đồ thị được cập nhật lại và quá trình hợp được lặp lại cho đến khi tiêu chuẩn là thỏa mãn. Quá trình hợp dừng có thể quyết định bởi chất lượng ảnh nén hay một tiêu chuẩn nào khác. Ta có thể thấy rằng phương pháp này khá phức tạp song bù lại nó cho tỉ số nén khá cao 60:1.", "order_start": 2164, "order_end": 2634, "word_count": 108}
{"parent_id": "5d30be69-113f-45c5-b147-0fa32671851c", "subject": "Xulyanh", "section": "7.4. CÂU HỎI ÔN TẬP CHƯƠNG", "title_path": "7.4. CÂU HỎI ÔN TẬP CHƯƠNG", "content": "[Xulyanh / 7.4. CÂU HỎI ÔN TẬP CHƯƠNG] Câu 1: Thực hiện mã hóa ảnh sau bằng thuật toán Huffman. Được biết ảnh được chia làm các khối kích thước 2x2 để làm đơn vị mã hóa (Mỗi khối này sẽ như là một chữ cái của bức ảnh). Câu 2: Thực hiện mã hóa sau đó giải mã ảnh sau bằng kỹ thuật LZW. Được biết ảnh được chia làm các khối kích thước 1x2 để làm đơn vị mã hóa. Và từ điền gốc bao gồm 4 đơn vị mã hóa sau 00, 01, 10, 11 tương đương với giá trị từ 0 đến 3, từ điển sẽ được xây dựng tiếp theo từ giá trị 4. Bức ảnh sẽ được đọc từ trái qua phải và từ trên xuống dưới. Coi từ điền là đủ lớn để không thiếu chỗ.", "order_start": 0, "order_end": 564, "word_count": 135}
{"parent_id": "c227c763-5003-4429-bbd6-b86aeaeb493d", "subject": "Xulyanh", "section": "TÀI LIỆU THAM KHẢO", "title_path": "TÀI LIỆU THAM KHẢO", "content": "[Xulyanh / TÀI LIỆU THAM KHẢO] [1]. Đỗ Năng Toàn, Phạm Việt Bình (2008), Giáo trình xử lý ảnh – ĐH Thái Nguyên, Nxb Khoa học và kỹ thuật, 2008. [2]. Phạm Việt Bình, Cao Lê Mạnh Hà, Đỗ Năng Toàn (2005), “Một cách tiếp cận mới trong phát hiện biên của ảnh đa cấp xám”, Kỷ yếu Hội thảo Quốc gia lần thứ 8 - Một số vấn đề chọn lọc của Công nghệ Thông tin và Truyền thông, Hải Phòng 25-27/08 /2005, Nxb KH&KT, Hà Nội 2006, 92-102. [3]. Nguyễn Quốc Trung (2004), Xử lý tín hiệu và lọc số, Nxb và Kỹ thuật, 2004. [4]. Lương Mạnh Bá, Nguyễn Thanh Thủy (2003), Nhập Môn Xử lý ảnh số, Nxb Khoa học và Kỹ thuật, 2003. [5]. Nguyễn Kim Sách (1997), Xử lý ảnh và Video số, Nxb Khoa học và Kỹ thuật, 1997. [6]. J.R.Paker (1997), Algorithms for Image processing and Computer Vision. John [7]. Randy Crane (1997), A simplified approach to image processing, Prentice-Hall, Inc.[8]. John C.Russ (1995), The Image Procesing Handbook. CRC Press, Inc.T (c) 1991 by McGrow Hill Book Company (UK) Limited.[10]. Anil K.Jain (1989), Fundamental of Digital Image Processing. Prentice Hall, I Engwood cliffs. [11]. T.", "order_start": 0, "order_end": 1058, "word_count": 197}
{"parent_id": "c227c763-5003-4429-bbd6-b86aeaeb493d", "subject": "Xulyanh", "section": "TÀI LIỆU THAM KHẢO", "title_path": "TÀI LIỆU THAM KHẢO", "content": "[Xulyanh / TÀI LIỆU THAM KHẢO] ook. CRC Press, Inc.T (c) 1991 by McGrow Hill Book Company (UK) Limited.[10]. Anil K.Jain (1989), Fundamental of Digital Image Processing. Prentice Hall, I Engwood cliffs. [11]. T. Pavlidis (1982), Algorithms for Graphics and Image Processing, Computer Science Press.", "order_start": 1058, "order_end": 1325, "word_count": 39}
